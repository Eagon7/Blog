import{_ as t,o as e,c as a,U as o}from"./chunks/framework.c6ee4a63.js";const x=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"articles/FontEnd/react/storage/jotai/index.md","lastUpdated":null}'),r={name:"articles/FontEnd/react/storage/jotai/index.md"},n=o('<h2 id="jotai-原子状态管理" tabindex="-1">Jotai 原子状态管理 <a class="header-anchor" href="#jotai-原子状态管理" aria-label="Permalink to &quot;Jotai  原子状态管理&quot;">​</a></h2><h3 id="原子式解决了什么问题" tabindex="-1">原子式解决了什么问题 <a class="header-anchor" href="#原子式解决了什么问题" aria-label="Permalink to &quot;原子式解决了什么问题&quot;">​</a></h3><p>reactHook 使State的拆分和逻辑共享变得更容易，但useState 和 useContext对于多个store仍需要维护多个Context Provider 因为当Context改变，所有消费该context的组件都会重新渲染即使是组件仅用到了context的一部分，容易导致不必要的无用渲染，造成性能损失。（比如react-redux v6完全基于Context API而导致性能大幅下降，v7又回退到之前的内部订阅方案，context更适合放类似主题这种变化不大的全局数据，而并不适合存放频繁更新的复杂状态集合。</p><p>原子化、组件内状态，但是api较多，它通过将原子状态进行派生、组合成新的状态(类似<strong>vue的computed</strong>)</p><ul><li>所谓组件内状态，其实就是内部使用了useState，state变化，触发更新渲染罢了</li><li>有兴趣可以阅读<a href="https://juejin.cn/post/7230335974085492773" title="https://juejin.cn/post/7230335974085492773" target="_blank" rel="noreferrer">手动实现Recoil原理</a></li></ul>',5),i=[n];function s(c,l,d,_,p,u){return e(),a("div",null,i)}const f=t(r,[["render",s]]);export{x as __pageData,f as default};
