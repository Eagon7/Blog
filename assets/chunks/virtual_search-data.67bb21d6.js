const e={map:'[{"resume":["0.0"],"中间件":["1.0"],"守卫":["1.1"],"拦截器":["1.2"],"管道":["1.3"],"注入基本数据":["2.0"],"案例":["3.0","31.5"],"控制反转":["4.0"],"依赖注入":["4.1"],"nest":["5.0","5.2"],"module":["5.1","5.4"],"provider":["5.3"],"动态module":["5.6"],"hi":["6.0"],"核心概念概览":["6.1"],"重点1":["6.2"],"他代表了一个http请求的执行上下文":["7.0"],"nestjs":["8.0"],"register":["9.0"],"js":["11.0"],"react":["12.0","17.0","18.0","19.0","22.0"],"api分类":["12.1"],"hooks":["12.2"],"useref":["12.3","26.0"],"数据更新驱动类":["12.4"],"usestate":["12.5"],"usereducer":["12.6"],"usecontext":["12.7"],"useimperativehandle":["12.8"],"项目列表":["13.0"],"高阶组件hoc":["13.1"],"生命周期":["14.0"],"useeffect":["14.1"],"uselayouteffect":["14.2"],"useinsertioneffect":["14.3"],"类组件生命周期在函数组件内使用effect替代方案":["14.4"],"props":["15.0","15.8"],"监听props改变":["15.1"],"render":["15.2","15.3"],"组合模式":["15.4"],"操作props":["15.5"],"混入":["15.6"],"抽离props":["15.7"],"demo":["15.9"],"ref":["16.0"],"获取ref的三种方式":["16.1"],"转发ref":["16.2"],"组合转发ref":["16.3"],"高阶组件转发":["16.4"],"出现背景":["17.1","19.3"],"核心概念":["17.2"],"使用教程":["17.3","20.4"],"自动缓存和数据同步":["17.4"],"加载状态管理":["17.5"],"数据同步和预取":["17.6"],"自动缓存失效处理":["17.7"],"服务器状态更新":["17.8"],"更少的重复代码":["17.9"],"api":["17.10"],"总结":["17.11"],"快速上手":["18.1"],"原理分析":["18.2"],"核心api":["18.3"],"常见的状态管理模式":["19.1","20.1"],"flex":["19.2"],"架构特点":["19.4"],"jotai":["20.0","20.2"],"原子式解决了什么问题":["20.3"],"实际使用":["20.14"],"redux":["21.0"],"api介绍":["21.1"],"摘要":["21.2"],"context":["24.0"],"reducer":["25.0"],"与state的区别":["25.1"],"命名原因":["25.2"],"reduce实现reducer":["25.4"],"实现usereducer":["25.5"],"实际用途":["25.6"],"vue":["27.0"],"前置":["29.0"],"时间复杂度":["30.0"],"nest主要设计模式":["31.0"],"dependency":["31.1"],"inversion":["31.2"],"好处":["31.3"],"如何控制反转":["31.4"],"设计模式":["32.0"],"myindex":["33.0"],"记录和楠楠的日常生活":["34.0"],"我们的故事":["35.0"],"根据空格拆分字符串":["36.0"]},{"0":["20.14","21.1"],"1":["5.2","6.1","12.5","14.2","19.1","19.4","20.1","20.5","31.3","36.0"],"2":["5.2","20.6"],"3":["20.7","36.0"],"4":["20.8"],"5":["20.9"],"6":["20.10"],"7":["20.11"],"8":["20.12"],"9":["20.13"],"69":["36.0"],"168":["36.0"],"192":["36.0"],"200":["36.0"],"48512":["36.0"],"info":["1.0","12.8"],"存在意义":["1.0"],"处理http请求的函数":["1.0"],"他可以在请求到达控制器之前":["1.0"],"之后执行一些操作":["1.0"],"他可以是全局的也可以是局部的":["1.0"],"场景":["1.0","12.3"],"身份验证":["1.0"],"日志记录":["1.0"],"guard":["1.1"],"是一种用于保护路由的机制":["1.1"],"他可以在请求到达控制器之前或者之后执行一些操作":["1.1"],"守卫可以用于实现身份验证":["1.1"],"权限控制":["1.1"],"缓存等功能":["1.1"],"在nestjs中收尾可以是全局的也可以是局部的":["1.1"],"守卫路由":["1.1"],"execution":["1.1"],"context":["1.1"],"处理http请求和响应的函数":["1.2"],"在请求到达控制器之前之后执行一些操作":["1.2"],"拦截器可以实现日志记录":["1.2"],"错误处理":["1.2"],"数据转换":["1.2"],"在nestjs中拦截器可以是全局的也可局部":["1.2"],"管道是数据流入controller前进行的一波数据处理":["1.3"],"因为普通数据服务不是class":["2.0"],"所以要使用":["2.0"],"inject来注入":["2.0"],"typescript":["2.0","3.0","20.6","31.1","31.5"],"module":["2.0"],"providers":["2.0"],"provide":["2.0"],"app":["2.0","17.9","25.5"],"name":["2.0","15.4","18.3"],"usevalue":["2.0"],"使用普通值":["2.0"],"injectable":["2.0","3.0"],"export":["2.0","3.0","16.1","17.9","20.14"],"class":["2.0","3.0","16.1","16.3","31.1","31.5"],"authservice":["2.0"],"第三方发送短信服务":["3.0"],"根据不同配置使用不同的第三方运营商":["3.0"],"sms":["3.0"],"serivce":["3.0"],"ts":["3.0","12.3","12.5","14.1","20.14","25.4"],"appcontroller":["3.0"],"constructor":["3.0","31.1"],"private":["3.0"],"ali":["3.0"],"aliservice":["3.0"],"tencent":["3.0"],"ioc":["4.0","4.1"],"di":["4.1"],"的具体实现":["4.1"],"请求声明周期":["5.0"],"controller":["5.1","31.1"],"service的关系":["5.1"],"提供了一个模块化的方式来组织和管理您的应用程序的代码":["5.1"],"请求生命周期":["5.2"],"img":["5.2"],"java":["5.2"],"收到请求":["5.2"],"提供服务":["5.3"],"用于表示应用程序中可注入的任何东西":["5.3"],"除了服务":["5.3"],"还可以提供其他类型的对象":["5.3"],"模块是一个子程序":["5.4"],"用于定义控制器":["5.4"],"提供者或向其他模块开放提供者":["5.4"],"开放模块的api":["5.4"],"默认情况下控制器":["5.4"],"提供者在当前模块可用":["5.4"],"我是eagon":["6.0"],"模块":["6.1"],"modules":["6.1"],"nestjs":["6.2"],"提供了许多属性和方法":["7.0"],"可用于在请求的生命周期内访问":["7.0"],"接收账号密码argon2":["9.0"],"关键词":["12.1"],"concurrent":["12.1"],"table":["12.1"],"tr":["12.1"],"th":["12.1"],"使用范围":["12.1"],"hooks":["12.1"],"details":["12.3","12.5","15.6","15.7","16.1","16.2","16.3","20.6","20.7","20.8","20.9","20.10"],"稳定引用":["12.3"],"获取dom节点":["12.3"],"获取上一次的值":["12.3"],"闭包":["12.3"],"异步访问到旧变量的问题":["12.3"],"code":["12.3","14.4","15.6","15.7","15.9","16.1","16.2","16.3","17.9","20.6","20.8","20.9","20.10","20.14","25.4","25.5","36.0"],"group":["12.3","14.4","15.9","17.9","20.14","25.4","25.5"],"典型的闭包循环案例":["12.3"],"每次循环调用settimeout的时候都会保存当前的作用域":["12.3"],"const":["12.5","17.9","20.14","25.5","36.0"],"state":["12.5","25.5","25.6"],"setstate":["12.5"],"initialstate":["12.5"],"参数接收一个初始值":["12.5"],"返回一个数组":["12.5"],"数组的第一个元素是当前的state":["12.5"],"第二个元素是更新state的函数":["12.5"],"注意事项":["12.5"],"对于拥有许多状态更新逻辑的组件来说":["12.6"],"过于分散的事件处理程序可能会令人不知所措":["12.6"],"对于这种情况":["12.6"],"你可以将组件的所有状态更新":["12.6"],"增删改查":["12.6"],"逻辑整合到一个外部函数中":["12.6"],"这个函数叫作":["12.6"],"reducer":["12.6","21.1"],"reducer是弥补usestate在逻辑复杂情况下的缺陷":["12.6"],"它分为三个步骤":["12.6"],"作用":["12.7"],"解决了什么问题":["12.8"],"子组件通过ref抛出方法供父组件调用":["12.8"],"react函数":["12.8"],"组件":["12.8","15.9"],"父组件需要直接访问子组件的实例方法或属性的问题":["12.8"],"在":["12.8"],"react":["12.8","14.0","14.3","14.4","16.3","17.9"],"中":["12.8"],"父组件通常通过":["12.8"],"props":["12.8","15.3","15.6"],"向子组件传递数据和回调函数来实现组件之间的通信":["12.8"],"这种方式可以确保数据流的单向性":["12.8"],"return":["14.1","16.3"],"destory":["14.1"],"和":["14.2","15.9","20.3"],"useeffect":["14.2","14.3","14.4","15.1"],"不同的地方是采用了同步执行":["14.2"],"在介绍":["14.3"],"用途之前":["14.3"],"先看一下":["14.3"],"的执行时机":["14.3"],"jsx":["14.3","14.4","15.2","15.3","15.4","15.6","15.7","15.8","15.9","16.1","16.2","16.3"],"console":["14.3"],"log":["14.3"],"执行":["14.3"],"模块渲染后":["14.4"],"componentdidmount":["14.4"],"请求数据":["14.4"],"事件监听":["14.4"],"操纵dom":["14.4"],"切记":["14.4"],"dep":["14.4"],"这里要记住":["14.4"],"这样当前":["14.4"],"effect":["14.4","18.3"],"没有任何依赖项":["14.4"],"也就只有初始化执行一次":["14.4"],"模块卸载前":["14.4"],"componentwillunmount":["14.4"],"函数组件中可以用":["15.1"],"children":["15.2","15.3","15.4","16.1"],"模式":["15.2","15.3"],"①":["15.2"],"container":["15.3","15.4"],"containerprops":["15.3","15.4"],"如果":["15.4"],"的":["15.4"],"既有函数也有组件":["15.4"],"这种情况应该怎么处理呢":["15.4"],"haha":["15.4"],"首先在":["15.4"],"抽象props":["15.5"],"view":["15.6","15.7","16.1","16.2","16.3","20.6","20.8","20.9","20.10"],"the":["15.6","15.7","16.1","16.2","16.3","20.6","20.8","20.9","20.10"],"的显式注入和隐式注入":["15.8"],"显式注入":["15.8"],"功能":["15.9"],"用于表单状态管理的":["15.9"],"form":["15.9","16.3"],"formitem":["15.9"],"用于管理表单状态":["15.9"],"用于管理":["15.9"],"input":["15.9"],"输入框组件":["15.9"],"编写的组件能够实现的功能是":["15.9"],"①form":["15.9"],"组件可以被":["15.9"],"ref":["15.9","16.4"],"获取实例":["15.9"],"然后可以调用实例方法":["15.9"],"submitform":["15.9"],"获取表单内容":["15.9"],"用于提交表单":["15.9"],"ref是一个字符串":["16.1"],"类组件":["16.1"],"extends":["16.1","16.3"],"component":["16.1","16.3"],"render":["16.1","16.3"],"div":["16.1","16.3"],"hello":["16.1"],"world":["16.1"],"default":["16.1","17.9"],"跨层级获取ref":["16.2"],"如果我想在父组件":["16.2"],"获取":["16.2"],"孙":["16.2"],"子":["16.2"],"组件的实例":["16.2"],"通过回调函数将子组件的ref作为参数":["16.2"],"表单组件":["16.3"],"index":["16.3","25.4"],"如果通过高阶组件包裹一个原始类组件":["16.4"],"就会产生一个问题":["16.4"],"如果高阶组件":["16.4"],"hoc":["16.4"],"没有处理":["16.4"],"那么由于高阶组件本身会返回一个新组件":["16.4"],"query":["17.0"],"解决问题":["17.1"],"灵魂拷问q":["17.1"],"为什么用axios不可以":["17.1"],"为什么需要出现react":["17.1"],"querya":["17.1"],"尽管可以使用普通的":["17.1"],"axios":["17.1"],"解决普通请求代码重复":["17.2"],"tsx":["17.9","36.0"],"befor":["17.9"],"import":["17.9","20.6","20.14","25.4"],"as":["17.9"],"from":["17.9","20.14","25.4"],"function":["17.9"],"存储":["17.9"],"后端返回数据":["17.9"],"zen":["17.9"],"setzen":["17.9"],"usestate":["17.9"],"加载状态":["17.9"],"isloading":["17.9","17.10"],"setisloading":["17.9"],"false":["17.9"],"是否请求成功":["17.9"],"iserror":["17.9"],"setiserror":["17.9"],"apiname":["17.10"],"are":["17.10"],"data":["17.10"],"查询返回的数据":["17.10"],"表示查询是否正在加载中":["17.10"],"router":["18.0"],"后端概念":["18.0"],"demo":["18.3"],"link":["18.3"],"普通链接":["18.3"],"全局存储":["19.0"],"global":["19.1","20.1"],"全局式":["19.1","20.1"],"架构":["19.2"],"解决痛点":["19.3"],"flux架构解决前端应用程序中状态管理和数据流动的复杂性问题":["19.3"],"在传统的mvc":["19.3"],"详细介绍":["19.4"],"flux架构通过引入单向数据流的概念":["19.4"],"将数据的流动变得可控和可预测":["19.4"],"它明确了数据流动的路径":["19.4"],"并将状态的修改限制在特定的流程中":["19.4"],"这样做的好处包括":["19.4"],"易于追踪和调试":["19.4"],"由于数据流是单向的":["19.4"],"引用来源":["20.0"],"原子状态管理":["20.2"],"reacthook":["20.3"],"使state的":["20.3"],"拆分":["20.3"],"创建":["20.5"],"atom":["20.5","20.14"],"派生atom":["20.5"],"使用":["20.5"],"useatom":["20.5"],"异步派生":["20.6"],"函数组件内更新方式":["20.7"],"atom内更新方式":["20.8"],"异步更新atom":["20.9"],"区别于第二条异步获取":["20.9"],"异步更新不会阻塞线程":["20.9"],"渲染问题":["20.10"],"当我们点击add时":["20.10"],"发现a和b都重新渲染了":["20.10"],"但是问题来了":["20.10"],"a为什么要重新渲染呀":["20.10"],"a只是触发了更新操作":["20.10"],"provider":["20.12"],"store":["20.13","20.14"],"createstore":["20.14"],"jotai":["20.14"],"mystore":["20.14"],"countatom":["20.14"],"纯函数":["21.1"],"middleware":["21.2"],"中间件":["21.2"],"action":["25.0","25.5"],"state是用户触发函数来执行具体的一步一步操作":["25.1"],"reducer是根据reduce命名":["25.2"],"js":["25.4","25.5"],"tasksreducer":["25.4"],"let":["25.4"],"actions":["25.4"],"type":["25.4","36.0"],"added":["25.4"],"通过usestate保存当前状态":["25.5"],"new":["25.5"],"usereducer是react提供的一个hook":["25.6"],"用于管理组件的状态":["25.6"],"injection":["31.1"],"依赖注入":["31.1"],"userservice":["31.1"],"getlist":["31.1","31.5"],"id":["31.1"],"获取用户的逻辑":["31.1"],"this":["31.1"],"of":["31.2"],"控制反转需要的条件如下":["31.4"],"abstract":["31.5"],"service":["31.5"],"void":["31.5"],"putlist":["31.5"],"str":["36.0"],"remote":["36.0"],"addr":["36.0"],"status":["36.0"],"content":["36.0"],"method":["36.0"],"get":["36.0"],"proto":["36.0"],"http":["36.0"],"layout":["37.0"]},{"0":["12.3","36.0"],"1":["12.6","14.1","20.8","25.4","31.4"],"2":["6.1","12.5","12.6","19.4","25.4"],"3":["5.2","12.6","19.4"],"4":["5.2"],"5":["5.2","12.1","36.0"],"10":["12.3","36.0"],"11":["36.0"],"14":["36.0"],"200":["17.9"],"605":["36.0"],"9226":["36.0"],"错误处理":["1.0"],"details":["1.0","15.4","20.5"],"中间件可以执行以下任务":["1.0"],"执行任何代码操作":["1.0"],"对请求对象进行更改":["1.0"],"结束当前请求生命周期":["1.0"],"调用下一个中间件函数":["1.0"],"如果当前中间件没有":["1.0"],"手动结束生命周期":["1.0"],"执行上下文":["1.1"],"typescript":["1.1","1.2","4.1","20.5","20.7","20.8","20.9"],"n":["1.1"],"g":["1.1"],"gu":["1.1"],"xxx":["1.1"],"no":["1.1"],"spec":["1.1"],"injectable":["1.1","1.2"],"export":["1.1","1.2"],"class":["1.2"],"logginginterceptor":["1.2"],"implements":["1.2"],"nestinterceptor":["1.2"],"其中数据处理包含了对数据的转换":["1.3"],"constractor":["2.0"],"inject":["2.0","3.0"],"private":["2.0","31.5"],"appname":["2.0"],"注册类":["2.0"],"使用类将提供者注册到服务是最常用的方式":["2.0"],"autherservice":["2.0"],"以上是简写形式":["2.0"],"完整写法应该如下":["2.0"],"tencentservices":["3.0"],"smsservice":["3.0"],"base":["3.0"],"key":["3.0","15.9","31.5"],"baseconfig":["3.0"],"configtype":["3.0"],"typeof":["3.0"],"getsmsservice":["3.0"],"type":["3.0"],"string":["3.0","20.9","31.5"],"const":["3.0","15.4","16.2","16.3","20.6","20.8","20.9","31.1"],"面向对象中的设计原则":["4.0"],"用来减少计算机代码之前的耦合度":["4.0"],"在类以外的地方提供服务":["4.1"],"类内部调用的是该具体服务的抽象":["4.1"],"provider":["5.0"],"同时还允许您使用依赖注入和模块之间的依赖关系来构建更加可扩展的应用程序":["5.1"],"module是nestjs应用程序的基本构建块":["5.1"],"每个模块都有一个独立的作用域":["5.1"],"其中包含一组相关的controller":["5.1"],"全局绑定的中间件":["5.2"],"模块绑定的中间件":["5.2"],"全局守卫":["5.2"],"控制层守卫":["5.2"],"例如":["5.3"],"factory":["5.3"],"工厂":["5.3"],"配置对象":["5.3"],"连接对象等":["5.3"],"提供者使用":["5.3"],"即模块作用域":["5.4"],"若果向其他模块提供服务可以将提供者定义在export属性中":["5.4"],"其他模块需要再imports属性中引入当前模块":["5.4"],"模块是":["5.4"],"设计模式模式":["5.4"],"的":["5.4"],"多个模块共享当前模块实例":["5.4"],"今天给大家分享nest基础系列":["6.0"],"组合所有逻辑的地方":["6.1"],"我理解为di的container":["6.1"],"控制器":["6.1"],"处理https时的生命周期":["6.2"],"executioncontext是在每个请求到达控制器之前被nestjs封装产生的":["7.0"],"他的请求是将请求的上下文":["7.0"],"hash":["9.0"],"加密插入数据库":["9.0"],"具体功能":["12.1"],"td":["12.1"],"rowspan":["12.1"],"数据更新驱动":["12.1"],"因为var不会新建作用域":["12.3"],"所以所有的settimeout都是共享一个作用域":["12.3"],"当for循环同步任务执行完毕后开始执行settimeout此时因为循环完成i的值已经为10":["12.3"],"并且所有的settimout共享一个作用域":["12.3"],"所以打印出来的结果都是10":["12.3"],"for":["12.3"],"var":["12.3"],"i":["12.3"],"在函数组件":["12.5"],"一次执行上下文中":["12.5"],"的值是":["12.5"],"固定不变的":["12.5"],"如果两次":["12.5"],"dispatchaction":["12.5"],"传入":["12.5"],"相同的":["12.5"],"值":["12.5"],"那么组件就":["12.5"],"将设置状态的逻辑":["12.6"],"修改成dispatch":["12.6"],"的一个":["12.6"],"action":["12.6"],"编写":["12.6"],"一个":["12.6"],"函数":["12.6"],"传递数据":["12.7"],"但有时候父组件需要直接访问子组件的方法":["12.8"],"例如触发子组件的某个功能或获取子组件的状态":["12.8"],"传统的解决方案是使用":["12.8"],"ref":["12.8","16.1"],"来引用子组件的实例":["12.8"],"然后通过":["12.8"],"current":["12.8","16.3"],"来访问子组件的方法或属性":["12.8"],"但是":["12.8","14.4"],"这种方式需要手动编写一些额外的代码":["12.8"],"不够直观和方便":["12.8"],"的出现解决了这个问题":["12.8"],"hooks也提供了":["14.0"],"dep":["14.1"],"第一个参数callback":["14.1"],"返回销毁函数":["14.1"],"下次执行useeffect会首先执行这个销毁函数":["14.1"],"首先":["14.2"],"是在":["14.2"],"dom":["14.2"],"更新之后":["14.2"],"浏览器绘制之前":["14.2"],"uselayouteffect":["14.3"],"打印":["14.3"],"增加定时器":["14.4"],"延时器":["14.4"],"return":["14.4","15.6","16.2","25.5"],"function":["14.4","15.3","15.6","15.7","16.2"],"解除事件监听器":["14.4"],"清除定时器":["14.4"],"模块组件props更新":["14.4"],"代替":["14.4"],"componentwillreceiveprops":["14.4"],"着实有点牵强":["14.4"],"首先因为二者的执行阶段根本不同":["14.4"],"一个是在render阶段":["14.4"],"一个是在commit阶段":["14.4"],"其次":["14.4"],"会初始化执行一次":["14.4"],"只有组件更新":["14.4"],"来作为":["15.1"],"props":["15.1","15.2","15.4","15.7","16.3"],"插槽组件":["15.2"],"container":["15.2","31.5"],"是container":["15.3"],"提供的本质是":["15.3"],"里打印":["15.4"],"看看是什么":["15.4"],"im":["15.4"],"此时需要用到一个api":["15.4"],"isvalidelement":["15.4"],"来判断当前children的值是elementdom还是函数":["15.4"],"view":["15.4","19.3","20.5","20.7"],"the":["15.4","20.5","20.7"],"code":["15.4","20.5","20.7"],"div":["15.4","25.5"],"tip":["15.5"],"抽象":["15.5"],"son":["15.6","15.7","15.8"],"console":["15.6","15.7","16.1","16.2","20.14"],"log":["15.6","15.7","16.1","16.2","20.14"],"father":["15.8"],"data":["15.8"],"resetform":["15.9"],"方法用于重置表单":["15.9"],"②form组件自动过滤掉除了formitem之外的其他react元素":["15.9"],"③formitem":["15.9"],"中":["15.9"],"name":["15.9"],"属性作为表单提交时候的":["15.9"],"还有展示的":["15.9"],"label":["15.9"],"④":["15.9"],"可以自动收集":["15.9"],"表单的值":["15.9"],"import":["15.9","20.5"],"react":["15.9","16.1","17.1","20.6"],"from":["15.9","20.6"],"useimperativehandle":["15.9"],"index":["16.1"],"componentdidmount":["16.1","16.3"],"this":["16.1","16.3"],"refs":["16.1"],"currentdom":["16.1"],"字符串模式获取元素或组件":["16.1"],"parentcomponent":["16.2"],"childref":["16.2"],"useref":["16.2"],"null":["16.2"],"useeffect":["16.2"],"childrencomponent":["16.2"],"setref":["16.2"],"组件":["16.3"],"forwardref":["16.3"],"所以当使用":["16.4"],"包装后组件的时候":["16.4"],"标记的":["16.4"],"会指向":["16.4"],"返回的组件":["16.4"],"或其他数据获取库来处理数据请求":["17.1"],"但在某些情况下":["17.1"],"使用":["17.1"],"query":["17.1"],"可以带来更多的好处和便利性":["17.1"],"自动缓存和数据同步":["17.1"],"后期维护困难":["17.2"],"后端返回的错误数据":["17.9"],"errormessage":["17.9"],"seterrormessage":["17.9"],"fetchdata":["17.9"],"开始获取数据":["17.9"],"将isloading置为true":["17.9"],"true":["17.9","17.10"],"fetch":["17.9"],"https":["17.9"],"api":["17.9"],"github":["17.9"],"com":["17.9"],"then":["17.9"],"async":["17.9"],"response":["17.9"],"如果请求返回status不为200":["17.9"],"则抛出后端错误":["17.9"],"if":["17.9"],"status":["17.9"],"message":["17.9"],"await":["17.9"],"如果数据正在加载":["17.10"],"该属性为":["17.10"],"否则为":["17.10"],"false":["17.10","20.14","37.0"],"iserror":["17.10"],"表示查询是否遇到了错误":["17.10"],"发送url请求到服务器端":["18.0"],"server会通过不同的地址返回不同的页面":["18.0"],"为什么需要路由":["18.0"],"不会触发刷新":["18.3"],"to":["18.3","20.14"],"navlink":["18.3"],"类似link":["18.3"],"状态管理":["19.0"],"也被称作单一数据源":["19.1","20.1"],"将所有的数据放到一个大对象中":["19.1","20.1"],"关键词":["19.1","20.1"],"model":["19.3"],"controller":["19.3"],"模式中":["19.3"],"数据的变化路径清晰可见":["19.4"],"可以更轻松地追踪数据的流动和变化过程":["19.4"],"更好的组件通信":["19.4"],"flux架构提供了明确的机制来处理组件之间的通信和状态共享":["19.4"],"使得组件间的交互更加可控和灵活":["19.4"],"状态的集中管理":["19.4"],"flux将应用程序的状态集中存储在存储器":["19.4"],"store":["19.4"],"ryun":["20.0"],"逻辑共享":["20.3"],"变得更容易":["20.3"],"但usestate":["20.3"],"atom":["20.6","20.8"],"useatom":["20.6"],"jotai":["20.6"],"fc":["20.6"],"valueatom":["20.8"],"mockdata":["20.9"],"new":["20.9","31.1"],"promise":["20.9"],"r":["20.9"],"settimeout":["20.9"],"并不需要重新渲染呀":["20.10"],"这是因为":["20.10"],"如果使用useatom":["20.10"],"即使你不引入它的value值":["20.10"],"但它由useatomvalue包裹":["20.10"],"当更新时":["20.10"],"useatomvalue会触发订阅事件":["20.10"],"从而触发渲染":["20.10"],"如果不理解可以阅读":["20.10"],"recoil原理":["20.10"],"理解":["20.10"],"解决渲染问题":["20.11"],"useatomvalue":["20.11"],"正常情况下":["20.12"],"无需用provider包裹组件":["20.12"],"createstore":["20.13"],"export出去":["20.13"],"statusatom":["20.14"],"监听发生变化":["20.14"],"sub":["20.14"],"value":["20.14"],"is":["20.14"],"changed":["20.14"],"get":["20.14"],"set":["20.14"],"接收两个参数":["21.1"],"一个是state":["21.1"],"一个是action":["21.1"],"中间件用于增强":["21.2"],"dispatch":["21.2","25.5"],"功能":["21.2"],"state":["25.0"],"reducer是把操作整合到一起":["25.1"],"它接收目前的结果和当前的值":["25.2"],"id":["25.4"],"text":["25.4"],"参观卡夫卡博物馆":["25.4"],"看木偶戏":["25.4"],"deleted":["25.4"],"usereducer":["25.5"],"reducer":["25.5"],"initialstate":["25.5"],"button":["25.5"],"onclick":["25.5"],"它的实际用途包括":["25.6"],"状态复杂逻辑":["25.6"],"当组件的状态逻辑较为复杂":["25.6"],"涉及多个状态变化时":["25.6"],"service":["31.1"],"read":["31.1"],"处理用户数据的逻辑":["31.1"],"result":["31.1"],"control":["31.2"],"解耦和模块化":["31.3"],"创建一个变量存贮依赖项":["31.5"],"dependencies":["31.5"],"host":["36.0"],"header":["36.0"],"user":["36.0"],"agent":["36.0"],"mozilla":["36.0"],"macintosh":["36.0"],"intel":["36.0"],"mac":["36.0"],"os":["36.0"],"x":["36.0"],"applewebkit":["36.0"]},{"1":["1.0","15.3","15.9","19.3","20.7","20.9","21.1"],"2":["14.1","19.1","20.1","20.14","31.3"],"3":["6.1","12.5","25.4"],"4":["19.4"],"6":["5.2"],"7":["5.2"],"8":["5.2"],"12":["36.0"],"15":["36.0"],"123":["15.8"],"1000":["12.3"],"3000":["20.9"],"必须使用next":["1.0"],"方法将控制权传递给下一个中间件函数":["1.0"],"否则请求将被挂起":["1.0"],"定义中间件":["1.0"],"code":["1.0","12.6","31.1"],"group":["1.0","12.6"],"typescript":["1.0","5.4","20.10"],"index":["1.0"],"ts":["1.0","2.0","12.6"],"class":["1.1","4.1"],"authgurad":["1.1"],"implements":["1.1"],"canactive":["1.1"],"canactivate":["1.1"],"contenxt":["1.1"],"executioncontext":["1.1","1.2"],"boolean":["1.1"],"promise":["1.1","20.6"],"observable":["1.1"],"intercept":["1.2"],"context":["1.2"],"next":["1.2"],"callhandler":["1.2"],"console":["1.2","12.3","14.4"],"log":["1.2","12.3","14.4"],"验证":["1.3"],"provider":["2.0","5.1","20.3"],"useclass":["2.0"],"动态注册":["2.0"],"下面实现根据不同的环境创建不同的服务":["2.0"],"首先安装":["2.0"],"dotenv":["2.0"],"扩展包":["2.0"],"用来读取":["2.0"],"env环境变量":["2.0"],"然后创建两个服务":["2.0"],"service":["2.0","3.0","6.1"],"与":["2.0"],"b":["2.0"],"tencnetservice":["3.0"],"if":["3.0"],"return":["3.0","15.7","17.9","31.1"],"privider":["3.0"],"curenv":["3.0"],"this":["3.0","16.2","31.5"],"config":["3.0"],"get":["3.0","20.8"],"其根本思想是":["4.0"],"借助于第三方":["4.0"],"abstrct":["4.1"],"phone":["4.1"],"playgame":["4.1"],"动态provider":["5.0"],"asynprovider":["5.0"],"service和其他提供者":["5.1"],"module的作用是将应用程序拆分为更小的可重用部分":["5.1"],"以便更好的组织代码和管理依赖关系":["5.1"],"路由守卫":["5.2"],"全局拦截器":["5.2"],"控制器之前":["5.2"],"injectable":["5.3"],"装饰器定义":["5.3"],"这样系统会分析":["5.3"],"constructor":["5.3"],"进行依赖注入":["5.3"],"模块提供者也是单例":["5.4"],"所以模块被多个其他模块使用":["5.4"],"那该模块的provider也是共享的":["5.4"],"导入其他模块":["5.4"],"nestjs核心基础概念":["6.0"],"controller处理请求":["6.1"],"服务":["6.1"],"传递给控制器":["7.0"],"拦截器":["7.0"],"管道":["7.0"],"login":["9.0"],"usestate":["12.1","15.9"],"数据驱动更新":["12.1"],"usereducer":["12.1"],"focus":["12.3","31.1"],"settimeout":["12.3","20.6"],"结果都是10":["12.3"],"let":["12.3"],"在每次循环的时候都会新建一个作用域":["12.3"],"所以当每次循环的时候settimout被分配到异步队列时都会保存当前的作用域i的值":["12.3"],"而不是所有的settimeout共享一个作用域":["12.3"],"不会更新":["12.5"],"当触发":["12.5"],"在":["12.5"],"当前执行上下文中获取不到最新的state":["12.5"],"只有再下一次组件":["12.5"],"rerender":["12.5"],"中才能获取到":["12.5"],"案例":["12.5"],"此时点击按钮":["12.5"],"log打印出来的值并不是更改过后的number":["12.5"],"在你的组件中":["12.6"],"使用":["12.6","12.8"],"参数":["12.6"],"const":["12.6","15.9","20.7","25.4"],"state":["12.6"],"dispatch":["12.6"],"避免props层层传递":["12.7"],"它允许子组件通过自定义的方式向父组件暴露自己的实例方法或属性":["12.8"],"父组件可以通过":["12.8"],"直接访问子组件的这些方法或属性":["12.8"],"而无需手动编写额外的代码":["12.8"],"父组件可以更直接地与子组件进行交互":["12.8"],"提供了更灵活的组件通信方式":["12.8"],"它使得父组件能够以更直观的方式调用子组件的方法":["12.8"],"从而简化了组件之间的通信逻辑":["12.8"],"需要注意的是":["12.8"],"api":["14.0"],"用于弥补函数组件没有生命周期的缺陷":["14.0"],"销毁定时器":["14.1"],"订阅等以防资源泄露":["14.1"],"第二个参数为依赖项":["14.1"],"依赖项发生变化则执行callback":["14.1"],"这样可以方便修改":["14.2"],"获取":["14.2"],"信息":["14.2"],"本质上是解决":["14.3"],"css":["14.3"],"in":["14.3"],"js":["14.3","31.1"],"产生的重绘问题":["14.3"],"style":["14.3"],"components库为例":["14.3"],"tip":["14.3"],"component":["14.3"],"你可以使用es6的标签模板字符串语法":["14.3"],"tagged":["14.3"],"props":["14.4","15.5"],"变化的时候才会执行":["14.4"],"props变化":["14.4"],"模块更新后":["14.4"],"componentdidupdate":["14.4"],"组件更新完成":["14.4"],"没有":["14.4"],"依赖项":["14.4"],"注意此时useeffect没有第二个参数":["14.4"],"没有第二个参数":["14.4"],"那么每一次执行函数组件":["14.4"],"都会执行该":["14.4"],"改变后的监听函数":["15.1"],"不过有一点值得注意":["15.1"],"上述可以在":["15.2"],"组件中":["15.2"],"通过":["15.2"],"reutrn":["15.3"],"这种方式作用是":["15.3"],"根据需要控制":["15.3"],"hello":["15.4","15.6","15.7"],"my":["15.4"],"is":["15.4"],"mes":["15.4"],"function":["15.4","15.9"],"一般用于跨层级传递":["15.5"],"div":["15.6","15.7"],"world":["15.6","15.7"],"father":["15.6"],"name":["15.8"],"隐式注入":["15.8"],"cloneelement":["15.9"],"children":["15.9"],"forwardref":["15.9","16.4"],"可接收父组件传递过来的ref确定具体渲染的dom":["15.9"],"myform":["15.9"],"可使父组件直接访问抛出方法":["15.9"],"a":["15.9"],"currentcominstance":["16.1"],"ref是一个函数":["16.1"],"node":["16.2"],"span":["16.2"],"ref":["16.2","16.3"],"通过forwardref转发":["16.2"],"newfahter组件是为了转发ref的中间组件":["16.2"],"给form组件实例":["16.3"],"绑定给":["16.3"],"form属性":["16.3"],"给index组件实例":["16.3"],"index属性":["16.3"],"button":["16.3"],"给button":["16.3"],"dom":["16.3"],"元素":["16.3"],"而并不是":["16.4"],"包裹的原始类组件":["16.4"],"为了解决这个问题":["16.4"],"可以对":["16.4"],"自带数据缓存和自动刷新功能":["17.1"],"它会自动缓存数据并定期刷新以保持数据的最新状态":["17.1"],"这减少了手动管理缓存的复杂性":["17.1"],"加载状态管理":["17.1"],"query内置状态管理":["17.1"],"你可以不用再写isloading":["17.1"],"无数据缓存":["17.2"],"json":["17.9"],"throw":["17.9"],"new":["17.9","20.6","25.0"],"error":["17.9","17.10"],"text":["17.9"],"string":["17.9","20.6"],"请求完成将isloading置为false":["17.9"],"接口请求成功":["17.9"],"将iserror置为false":["17.9"],"存储后端返回的数据":["17.9"],"catch":["17.9"],"接口请求错误":["17.9"],"将iserror置为true":["17.9"],"存储后端返回的错误数据":["17.9"],"如果查询出现错误":["17.10"],"单页应用需要路由切换":["18.0"],"通过url可以定位到页面":["18.0"],"但是会添加当前选中状态":["18.3"],"home":["18.3"],"activeclassname":["18.3"],"combinereducers":["19.1","20.1"],"multiple":["19.1","20.1"],"应用程序的状态分散在多个视图和控制器之间":["19.3"],"导致数据流动难以追踪和管理":["19.3"],"这样的架构往往会导致以下问题":["19.3"],"中":["19.4"],"使得状态的修改和管理更加一致和可控":["19.4"],"提升应用程序的可维护性和可扩展性":["19.4"],"flux架构的职责分离和分层结构使得应用程序的各个模块解耦":["19.4"],"提高了代码的可复用性和可测试性":["19.4"],"便于应用程序的扩展和维护":["19.4"],"人话":["19.4"],"数据单向易于追踪更改来源":["19.4"],"usecontext对于多个store仍需要维护多个context":["20.3"],"因为当context改变":["20.3"],"所有消费该context的组件都会重新渲染即使是组件仅用到了":["20.3"],"context的一部分":["20.3"],"from":["20.5","20.10"],"jotai":["20.5"],"fc":["20.5","20.10"],"mockdata":["20.6"],"r":["20.6"],"mock":["20.6","20.9"],"data":["20.6","20.9","31.1"],"valueatom":["20.7","20.9"],"atom":["20.7","20.9","20.10"],"addnumberatom":["20.8"],"ge":["20.8"],"a组件使用即订阅":["20.10"],"atom原子更新触发订阅事件从而更新":["20.10"],"解决办法":["20.10"],"参考7":["20.10"],"import":["20.10"],"react":["20.10","20.14"],"usesetatom":["20.11"],"如果有的组件只需要监听状态的变化值":["20.11"],"但如果需要控制某些组件的状态不发生更新":["20.12"],"可以用provider包裹":["20.12"],"使用jotai的provider提供给app":["20.13"],"其中":["20.13"],"default":["20.14","31.1"],"main":["20.14"],"reactdom":["20.14"],"返回一个新的state":["21.1"],"createstore":["21.1"],"返回一个增强后的":["21.2"],"用户触发事件名进而执行相应的处理函数":["25.1"],"例如":["25.1"],"然后返回下一个结果":["25.2"],"打卡列侬墙":["25.4"],"finalstate":["25.4"],"reduce":["25.4"],"output":["25.4"],"document":["25.4"],"getelementbyid":["25.4"],"type":["25.5"],"add":["25.5"],"message":["25.5"],"添加":["25.5"],"可以使用usereducer来更好地组织和管理状态的变化逻辑":["25.6"],"替代usestate":["25.6"],"在一些情况下":["25.6"],"使用usereducer可以替代多个独立的usestate":["25.6"],"export":["31.1"],"msg":["31.1"],"focused":["31.1"],"此时controller":["31.1"],"和":["31.1"],"存在了强耦合的关联":["31.1"],"控制反转":["31.2"],"需要一个管理容器":["31.4"],"container":["31.4"],"any":["31.5"],"注册方法":["31.5"],"register":["31.5"],"dependency":["31.5"],"khtml":["36.0"],"like":["36.0"],"gecko":["36.0"],"version":["36.0"],"safari":["36.0"],"15accept":["36.0"],"encoding":["36.0"],"gzipbody":["36.0"],"url":["36.0"]},{"0":["14.4","20.10"],"1":["20.6"],"2":["15.3","31.4"],"4":["6.1"],"9":["5.2"],"10":["5.2"],"3000":["20.6"],"中间件实例代码":["1.0"],"injectable":["1.0"],"export":["1.0","25.4"],"class":["1.0"],"loggermiddleware":["1.0"],"implements":["1.0"],"nestmiddleware":["1.0"],"use":["1.0"],"req":["1.0"],"const":["1.1","1.2","14.4","15.6","15.7","20.5","20.10"],"request":["1.1"],"switchtohttp":["1.1"],"getrequest":["1.1"],"return":["1.1","1.2","15.4"],"validaterequest":["1.1"],"function":["1.1","15.8","25.4"],"before":["1.2"],"now":["1.2"],"date":["1.2"],"他可以在控制器之前或之后对数据进行预处理":["1.3"],"import":["2.0"],"config":["2.0"],"from":["2.0"],"读取":["2.0"],"env":["2.0"],"到":["2.0"],"process":["2.0"],"环境变量中":["2.0"],"path":["2.0"],"join":["2.0"],"system":["3.0"],"provider":["3.0","20.14"],"send":["3.0"],"getsmsprovider":["3.0"],"使用":["3.0"],"nest":["3.0"],"实现具有依赖关系的对象之间的解耦":["4.0"],"第三方举例":["4.0"],"name":["4.1"],"string":["4.1"],"module":["5.0"],"controller提供一个路由处理器":["5.1"],"他可以将http请求映射到响应的处理器方法上":["5.1"],"并将处理器方法的结果作为http响应返回给client":["5.1"],"controller是处理":["5.1"],"控制器层拦截器":["5.2"],"路由拦截器":["5.2"],"全局管道":["5.2"],"提供者在模块的":["5.3"],"providers":["5.3"],"属性中定义":["5.3"],"用于注册到服务容器中":["5.3"],"用于被其他类依赖注入":["5.3"],"提供者可以在自身的constructor构造函数中依赖注入其他服务提供者":["5.3"],"imports":["5.4"],"jwtmodule":["5.4"],"registerasync":["5.4"],"configmodule":["5.4"],"inject":["5.4"],"configservice":["5.4"],"愿我们共同进步":["6.0"],"操作数据库以及处理所有逻辑的地方":["6.1"],"管道":["6.1"],"守卫等各个部分":["7.0"],"以便他们可以对请求进行处理和转换":["7.0"],"登录接收账号密码":["9.0"],"argon2":["9.0"],"订阅状态":["12.1"],"创建reducer":["12.1"],"更新试图":["12.1"],"usesyncexternalstore":["12.1"],"订阅外部数据源触发更新":["12.1"],"而是更改前的值":["12.5"],"这意味着log时更改未发生":["12.5"],"br":["12.5"],"原因":["12.5"],"setnumber是异步的":["12.5"],"触发handleclick时":["12.5"],"任务线程会先执行同步再执行异步":["12.5"],"所以log打印的是更改前的值":["12.5"],"外部log可以获取到最新的值的原因是":["12.5"],"在执行完同步的log后执行异步setnumber":["12.5"],"异步setnumber触发重新渲染":["12.5"],"重新执行index函数":["12.5"],"initstate":["12.6"],"实际使用":["12.6"],"type":["12.6"],"导致代码冗余":["12.7"],"应该与":["12.8"],"forwardref":["12.8"],"一起使用":["12.8"],"以便将子组件的引用传递给父组件":["12.8"],"总结来说":["12.8"],"解决了在":["12.8"],"组件中":["12.8"],"父组件需要直接访问子组件的实例方法或属性时":["12.8"],"通过更简洁":["12.8"],"直观的方式实现组件之间的通信的问题":["12.8"],"code":["12.8","16.4"],"group":["12.8"],"其原理主要是运用了":["14.0"],"对于":["14.1"],"执行":["14.1"],"react":["14.1","15.4","20.5"],"处理逻辑是采用异步调用":["14.1"],"这样浏览器只会绘制一次":["14.2"],"如果修改":["14.2"],"布局放在":["14.2"],"那":["14.2"],"templates":["14.3"],"为需要":["14.3"],"styled":["14.3"],"的":["14.3","15.3"],"定义一系列css属性":["14.3"],"当该组件的js代码被解析执行的时候":["14.3"],"components":["14.3"],"会动态生成一个":["14.3"],"选择器":["14.3"],"并把对应的":["14.3"],"alldemo":["14.4"],"functionlifecycle":["14.4"],"num":["14.4"],"setnum":["14.4"],"usestate":["14.4"],"组件挂载完成":["14.4"],"清除":["14.4"],"初始化会默认执行一次":["15.1"],"jsx":["15.1"],"属性访问到":["15.2"],"组件":["15.2"],"为":["15.2"],"渲染与否":["15.3"],"可以将需要传给":["15.3"],"直接通过函数参数的方式传递给执行函数":["15.3"],"alien":["15.4"],"let":["15.4","15.6"],"us":["15.4","15.6"],"learn":["15.4","15.6"],"map":["15.4"],"item":["15.4"],"focus":["15.4"],"if":["15.4","31.5"],"fatherprops":["15.6","15.7"],"mes":["15.6"],"father":["15.7"],"age":["15.7"],"formvalue":["15.9"],"setformvalue":["15.9"],"setvalue":["15.9"],"inputvalue":["15.9"],"callback":["15.9"],"renderelements":["15.9"],"这里是react":["15.9"],"children用来循环react":["15.9"],"element的方法":["15.9"],"foreach":["15.9"],"el":["15.9"],"null":["16.1","16.3","20.9","25.4"],"currentcomponentinstance":["16.1"],"forwardref的第二个参数是ref":["16.2"],"这个ref是grandfahter组件传递过来的":["16.2"],"至此一层一层从prop传递":["16.2"],"最终通过ref赋值":["16.2"],"grandfather":["16.2"],"button属性":["16.3"],"点击":["16.3"],"做一层处理":["16.4"],"高阶组件把组件作为参数":["16.4"],"我们想获取的ref其实是这个参数的实例":["16.4"],"forwardref的意义是可以让开发着手动控制ref的指向":["16.4"],"details":["16.4"],"view":["16.4"],"the":["16.4"],"isfetching等状态了":["17.1"],"它会自动管理数据加载状态":["17.1"],"数据同步和预取":["17.1"],"支持数据预取和自动同步":["17.1"],"提前获取数据并在后台刷新":["17.1"],"以保持数据最新":["17.1"],"无数据同步":["17.2"],"useeffect":["17.9"],"初始化请求数据":["17.9"],"div":["17.9"],"h1":["17.9"],"p":["17.9"],"加载中":["17.9"],"button":["17.9"],"onclick":["17.9"],"重试":["17.9"],"刷新":["17.9"],"after":["17.9"],"该属性将包含错误信息":["17.10"],"通常是一个错误对象":["17.10"],"包含有关查询错误的详细信息":["17.10"],"status":["17.10"],"表示查询的状态":["17.10"],"用于指示加载中":["17.10"],"更有语义的组织资源":["18.0"],"三种路由的实现方式":["18.0"],"browserrouter":["18.0"],"selected":["18.3"],"prompt":["18.3"],"满足条件时提示用户是否离开页面":["18.3"],"when":["18.3"],"stores":["19.1","20.1"],"多数据源模式":["19.1","20.1"],"将状态存放到多个数据源中":["19.1","20.1"],"数据流动不可控":["19.3"],"在mvc模式中":["19.3"],"视图可以直接修改模型的状态":["19.3"],"模型可以直接更新视图":["19.3"],"统一状态管理":["19.4"],"数据可预测性":["19.4"],"新状态":["19.4"],"旧状态":["19.4"],"事件":["19.4"],"tip":["19.4"],"flux":["19.4"],"的核心思想是单向数据流":["19.4"],"容易导致不必要的":["20.3"],"无用渲染":["20.3"],"造成性能损失":["20.3"],"比如react":["20.3"],"创建atom":["20.5","20.6"],"valueatom":["20.5","20.6"],"派生atom":["20.6"],"依赖某个atom":["20.6"],"text":["20.7"],"value":["20.7"],"set":["20.8","20.9"],"arg":["20.8","20.9"],"addnumberatom":["20.9"],"async":["20.9"],"get":["20.9"],"result":["20.9"],"useatom":["20.10"],"useatomvalue":["20.10"],"usesetatom":["20.10"],"jotai":["20.10"],"countatom":["20.10"],"a":["20.10"],"而没有更新操作":["20.11"],"请使用useatomvalue":["20.11"],"或者说":["20.12"],"用provider包裹的组件":["20.12"],"store中的状态":["20.13"],"是全局的":["20.13"],"dom":["20.14"],"client":["20.14"],"app":["20.14"],"tsx":["20.14"],"index":["20.14"],"css":["20.14"],"创建一个":["21.1"],"root":["21.1"],"存放":["21.1"],"比如":["21.2"],"redux":["21.2"],"thunk":["21.2"],"用户触发添加程序":["25.1"],"react中的reducer也是这样的他们都接受":["25.2"],"textcontent":["25.4"],"json":["25.4"],"stringify":["25.4"],"reducer":["25.4"],"default":["25.4"],"newstate":["25.5"],"接收状态事件":["25.5"],"计算新的状态":["25.5"],"switch":["25.5"],"从而将相关状态集中管理":["25.6"],"减少状态逻辑的分散":["25.6"],"可预测性":["25.6"],"无法复用":["31.1"],"若我们想用authservice时必须新注册一个类来实现":["31.1"],"并且需要改动getuser里面的代码":["31.1"],"那我们此时就需要解决这个问题":["31.1"],"使用di":["31.1"],"依赖是service":["31.1"],"依赖的标准需要拥有一个getlist方法":["31.1"],"并且接收一个id":["31.1"],"控制反转的本质就是降低耦合度":["31.2"],"更方便的依赖注入":["31.3"],"解析方法":["31.5"],"resolve":["31.5"],"page":["37.0"]},{"2":["19.3","21.1"],"3":["19.1","20.1","31.3","31.4"],"5":["6.1"],"9":["12.3"],"11":["5.2"],"12":["5.2"],"13":["5.2"],"14":["5.2"],"102":["36.0"],"300":["36.0"],"request":["1.0"],"res":["1.0"],"response":["1.0"],"next":["1.0"],"function":["1.0","12.8","16.4"],"console":["1.0","15.1","17.9","20.10"],"log":["1.0","17.9","20.10"],"中间件触发":["1.0"],"if":["1.1","15.9"],"true":["1.1"],"details":["1.1"],"定义一个authguard守卫类":["1.1"],"实现canactivate接口":["1.1"],"handle":["1.2"],"pipe":["1.2"],"tap":["1.2"],"after":["1.2"],"然后将数据传递给控制器或下一个管道":["1.3"],"管道的主要目的是增强应用的可靠性":["1.3"],"dirname":["2.0"],"const":["2.0","12.8","14.3"],"appservice":["2.0"],"node":["2.0","16.1"],"development":["2.0"],"bservice":["2.0"],"imports":["2.0"],"controllers":["2.0"],"快速配置env配置":["3.0"],"配置环境文件":["3.0"],"a":["3.0"],"import":["3.0","12.3"],"registeras":["3.0"],"from":["3.0","12.3"],"nestjs":["3.0"],"default":["3.0","25.5"],"ts注解":["4.0"],"或直接传递参数":["4.0"],"iphone":["4.1"],"extends":["4.1","16.4"],"静态模块":["5.0"],"http请求并返回http响应的类":["5.1"],"controller的作用是将路由映射到处理请求方法上":["5.1"],"在controller中可以使用nestjs提供的装饰器来定义":["5.1"],"路由":["5.1"],"中间件":["5.1"],"控制器管道":["5.2"],"路由管道":["5.2"],"路由参数管道":["5.2"],"需要使用":["5.3"],"装饰器声明该提供者":["5.3"],"注册到容器的提供者":["5.3"],"默认只对当前模块有效":["5.3"],"即作用域为模块":["5.3"],"usefactory":["5.4"],"return":["5.4","12.6","15.8","15.9","20.7","20.10","25.4","31.5"],"secret":["5.4"],"get":["5.4","20.6"],"pipes":["6.1"],"核验请求的数据":["6.1"],"过滤器":["6.1"],"当一个请求到达应用程序时":["7.0"],"nestjs框架会将他封装成一个executioncontext对象":["7.0"],"verify对密码进行解密":["9.0"],"解密符合":["9.0"],"usetransition":["12.1"],"concurrent模式下":["12.1"],"过渡更新任务":["12.1"],"结果是0":["12.3"],"react":["12.3","15.1","15.2","15.6","15.8","16.4"],"usestate获取到最新的number":["12.5"],"所以打印的值是最新的number":["12.5"],"人话":["12.5"],"点击button时触发的log和setnumber在第一任务线程":["12.5"],"第一线程执行完毕后执行第一线程引起的一系列任务":["12.5"],"外部在第二任务线程中执行的":["12.5"],"此时setnumber已执行完毕":["12.5"],"点击按钮后执行过程":["12.5"],"线程1":["12.5"],"handleclick":["12.5"],"宏任务log":["12.5"],"微任务setnumber":["12.5"],"触发线程2":["12.5"],"name":["12.6"],"switch":["12.6","25.4"],"case":["12.6","25.4","25.5"],"increment":["12.6"],"count":["12.6"],"demo":["12.8"],"jsx":["12.8","16.4","36.0"],"index":["12.8","15.6"],"childref":["12.8"],"useref":["12.8"],"null":["12.8"],"click":["12.8"],"chcildref":["12.8"],"logger":["12.8"],"hooks":["14.0"],"里面的":["14.0"],"对于每一个":["14.1"],"effect":["14.1"],"的":["14.1"],"callback":["14.1"],"执行是在浏览器绘制视图之后":["14.2"],"接下来又改":["14.2"],"就可能会导致浏览器再次回流和重绘":["14.2"],"而且由于两次绘制":["14.2"],"样式通过":["14.3"],"标签的形式插入到":["14.3"],"head":["14.3"],"标签里面":["14.3"],"动态生成的":["14.3"],"选择器会有一小段哈希值来保证全局唯一性来避免样式发生冲突":["14.3"],"这种模式下本质上是动态生成":["14.3"],"标签":["14.3"],"title":["14.3"],"组件销毁":["14.4"],"div":["14.4","20.10"],"number":["14.4"],"element":["15.2"],"对象":["15.2"],"作用":["15.2"],"可以根据需要控制":["15.2"],"tip":["15.3"],"这种情况":["15.3"],"在":["15.3"],"中":["15.3"],"判断是":["15.4"],"elment":["15.4"],"混入":["15.4"],"cloneelement":["15.4","15.8"],"一般不需要具体指出":["15.5"],"focus":["15.7"],"prop":["15.8"],"type":["15.9"],"displayname":["15.9"],"props":["15.9"],"混入props":["15.9"],"childrenitem":["15.9"],"value":["15.9","20.8"],"onchange":["15.9"],"ref模式获取元素或组件":["16.1"],"childspanref":["16.2"],"newfather":["16.2"],"forwardrefindex":["16.3"],"component":["16.4"],"class":["16.4"],"wrap":["16.4"],"这在提高用户体验和性能方面很有帮助":["17.1"],"自动缓存失效处理":["17.1"],"当数据过期或需要刷新时":["17.1"],"可以自动处理缓存失效并重新获取数据":["17.1"],"无需手动编写过期和刷新逻辑":["17.1"],"服务器状态更新":["17.1"],"无数据预取":["17.2"],"usequery":["17.9"],"query":["17.9"],"querykey":["17.9"],"owner":["17.9"],"repo":["17.9"],"repos":["17.9"],"issues":["17.9"],"headers":["17.9"],"authorization":["17.9"],"成功或错误状态":["17.10"],"例如":["17.10","36.0"],"可以是字符串":["17.10"],"loading":["17.10"],"success":["17.10"],"或":["17.10"],"hashrouter":["18.0"],"memoryrouter":["18.0"],"好处":["18.0"],"formishalffilledout":["18.3"],"message":["18.3"],"are":["18.3"],"you":["18.3"],"sure":["18.3"],"可在多个地方使用消费":["19.1","20.1"],"usestore":["19.1","20.1"],"这种双向的数据流动会导致数据的不一致和混乱":["19.3"],"难以调试和维护":["19.3"],"由于数据流动不可控":["19.3"],"它将应用程序分为四个主要部分":["19.4"],"br":["19.4"],"b":["19.4"],"view":["19.4"],"视图":["19.4"],"负责渲染用户界面":["19.4"],"接收用户输入并将其发送给":["19.4"],"dispatcher":["19.4"],"redux":["20.3"],"v6完全基于context":["20.3"],"api而导致性能大幅下降":["20.3"],"v7又回退到之前的内部订阅方案":["20.3"],"context更适合放类似主题这种变化不大的全局数据":["20.3"],"依赖某个atom":["20.5"],"当依赖项发生变化时更新触发atom的第一个参数修改变量":["20.5","20.6"],"deriveatom":["20.5","20.6"],"async":["20.6"],"setvalue":["20.7"],"useatom":["20.7"],"text":["20.8"],"fc":["20.8"],"await":["20.9"],"url":["20.9"],"setcount":["20.10"],"组件a渲染":["20.10"],"button":["20.10"],"onclick":["20.10"],"如果仅更新操作":["20.11"],"而无需渲染状态的组件":["20.11"],"状态是独立的":["20.12"],"不受外部影响":["20.12"],"同时也不影响外部":["20.12"],"任何组件都可以使用":["20.13"],"但是":["20.13"],"createroot":["20.14"],"document":["20.14"],"getelementbyid":["20.14"],"root":["20.14"],"render":["20.14"],"strictmode":["20.14"],"state的根对象":["21.1"],"dispatch":["21.1"],"使":["21.2"],"action":["21.2","25.4"],"可以为":["21.2"],"程序了解到事件名以后去reducer中找到对应的函数执行操作":["25.1"],"当前state":["25.2"],"和触发的事件action":["25.2"],"tasks":["25.4"],"previous":["25.4"],"state":["25.4"],"current":["25.4"],"使用usereducer可以使状态变化变得可预测":["25.6"],"因为它通过一个reducer函数来处理状态变化":["25.6"],"可以更好地理解状态变化的来源":["25.6"],"中间件和副作用":["25.6"],"不再强依赖一些属性和方法":["31.2"],"具体的实现方式是di依赖注入":["31.2"],"容器需要拥有register方法用来管理容器的注册":["31.4"],"throw":["31.5"],"split":["36.0"],"这样可得到一个数组":["36.0"],"如果我想把他拆分成一个对象该如何实现":["36.0"],"reg":["36.0"],"w":["36.0"],"s":["36.0"],"replace":["36.0"],"iframe":["36.0"],"height":["36.0"],"style":["36.0"],"team":["37.0"]},{"1":["14.3","14.4","20.10"],"2":["14.2"],"3":["19.3","21.1"],"5":["12.3"],"6":["6.1","12.5"],"8":["12.5"],"15":["5.2"],"16":["5.2"],"18":["3.0"],"28":["15.6"],"100":["36.0"],"使用":["1.0"],"添加到模块或者控制器中":["1.0"],"module":["1.0","1.2"],"在canactivate":["1.1"],"方法中":["1.1"],"通过参数context获取到请求对象":["1.1"],"调用validaterequest":["1.1"],"函数验证请求是否合法":["1.1"],"如果请求合法就返回true":["1.1"],"要在控制器中使用守卫":["1.1"],"需要将守卫添加到路由上":["1.1"],"useguard":["1.1"],"controller":["1.1"],"ms":["1.2"],"写入模块中作为提供者":["1.2"],"imports":["1.2"],"安全性":["1.3"],"appcontroller":["2.0"],"appmodule":["2.0"],"不使用dotenv扩展包的话需要手动readfile然后根据":["2.0"],"n拆分":["2.0"],"循环放入process":["2.0"],"key":["2.0"],"太麻烦":["2.0"],"工厂函数":["2.0"],"对于复杂要求的provider":["2.0"],"我们就可以使用":["2.0"],"usefactory":["2.0"],"工厂函数进行提供者注册":["2.0"],"name":["3.0","15.6","15.7"],"process":["3.0"],"env":["3.0"],"app":["3.0","5.4"],"age":["3.0","15.6"],"最终统一导入到config":["3.0"],"index":["3.0","12.5","15.7"],"再统一导出":["3.0"],"总之控制权不在类中":["4.0"],"而是由外部决定":["4.0"],"play":["4.1"],"student":["4.1"],"动态模块":["5.0"],"全局模块":["5.0"],"pipe":["5.1"],"dto和请求参数等":["5.1"],"service提供一种实现业务逻辑的方式":["5.1"],"他可以访问操作数据":["5.1"],"控制器":["5.2"],"方法处理器":["5.2"],"请求之后":["5.2"],"可以使用":["5.3"],"exports":["5.3"],"导出给其他模块使用":["5.3"],"提供者是单例的4":["5.3"],"提供者可以是任何值":["5.3"],"token":["5.4"],"expiresin":["5.4"],"100d":["5.4"],"模块提供者":["5.4"],"filters":["6.1"],"处理请求时的错误":["6.1"],"守卫":["6.1"],"这个对象包含了当前请求的上下文信息":["7.0"],"包括请求头":["7.0"],"请求体":["7.0"],"根据头信息":["9.0"],"usedeferredvalue":["12.1"],"解决更新状态滞后问题":["12.1"],"const":["12.3","16.4","31.5"],"indexref":["12.3"],"function":["12.3","12.5","16.3","21.2"],"线程2":["12.5"],"微任务setnumber触发重新渲染":["12.5"],"这就是为什么handleclick函数内打印不到最新的值":["12.5"],"而handleclick函数外可以大打印到最新的值的原因":["12.5"],"js":["12.5","36.0"],"number":["12.5"],"setnumber":["12.5","14.4"],"decrement":["12.6"],"default":["12.6","14.4","15.9","16.3","36.0"],"throw":["12.6"],"new":["12.6","31.5"],"error":["12.6","31.5"],"return":["12.8","20.6","20.8"],"form":["12.8"],"button":["12.8","14.4","20.7"],"onclick":["12.8","14.4"],"myform":["12.8"],"useeffect":["14.0","16.3"],"会向":["14.1"],"settimeout回调函数一样":["14.1"],"放入任务队列":["14.1"],"等到主线程任务完成":["14.1"],"dom":["14.1"],"视图上可能会造成闪现突兀的效果":["14.2"],"callback":["14.2"],"中代码执行会阻塞浏览器绘制":["14.2"],"h1":["14.3"],"font":["14.3"],"size":["14.3"],"5em":["14.3"],"text":["14.3","20.6","20.9"],"align":["14.3"],"center":["14.3"],"color":["14.3"],"bf4f74":["14.3"],"wrapper":["14.3"],"section":["14.3"],"padding":["14.3"],"states":["14.4"],"state":["14.4","19.1","20.1"],"改变state":["14.4"],"export":["14.4","15.9","16.3"],"isrender":["14.4"],"setrender":["14.4"],"log":["15.1","16.3"],"props改变":["15.1"],"是否渲染":["15.2"],"可以用":["15.2"],"属性访问到是函数":["15.3"],"并不是":["15.3"],"react":["15.3","16.2"],"element":["15.3"],"对象":["15.3"],"针对这种情况":["15.3"],"像下面这种情况下":["15.3"],"else":["15.4"],"typeof":["15.4"],"中某个属性":["15.5"],"而是将":["15.5"],"indexprops":["15.6","15.7"],"alien":["15.6"],"children":["15.8"],"mes":["15.8"],"push":["15.9"],"div":["15.9","20.7"],"123s":["15.9"],"json":["15.9"],"stringify":["15.9"],"ref是一个对象":["16.1"],"forwardref":["16.2"],"props":["16.2","16.4"],"father":["16.2"],"grandref":["16.2"],"父组件":["16.2"],"class":["16.2"],"extends":["16.2"],"home":["16.3"],"useref":["16.3"],"console":["16.3"],"render":["16.4"],"forwardedref":["16.4"],"otherprops":["16.4"],"this":["16.4"],"对于需要与服务器状态同步的情况":["17.1"],"可以通过提供的无缝数据同步功能来处理":["17.1"],"确保客户端数据的一致性":["17.1"],"更少的重复代码":["17.1"],"无数据失效处理":["17.2"],"inputowner":["17.9"],"setinputowner":["17.9"],"facebook":["17.9"],"inputrepo":["17.9"],"setinputrepo":["17.9"],"setquerykey":["17.9"],"issuccess":["17.10"],"表示查询是否成功完成":["17.10"],"如果查询成功完成":["17.10"],"页面松耦合":["18.0"],"lazyload":["18.0"],"want":["18.3"],"leave":["18.3"],"redirect":["18.3"],"重定向":["18.3"],"atomic":["19.1","20.1"],"原子状态":["19.1","20.1"],"当应用程序发生错误或状态异常时":["19.3"],"很难定位问题的根源并进行调试和修复":["19.3"],"嵌套回调和依赖关系":["19.3"],"调度器":["19.4"],"负责接收来自":["19.4"],"的动作":["19.4"],"并将它们分发给注册的":["19.4"],"而并不适合存放频繁更新的复杂状态集合":["20.3"],"原子化":["20.3"],"组件内状态":["20.3"],"但是api较多":["20.3"],"get":["20.5","31.1"],"使用atom":["20.5"],"await":["20.6"],"useatom":["20.8","20.9","20.14"],"addnumber":["20.8"],"fc":["20.9"],"value":["20.9"],"prev":["20.10"],"add":["20.10"],"b":["20.10"],"count":["20.10"],"请使用":["20.11"],"即使大家共用同一个atom状态":["20.12"],"如果不想让这个组件受外部更新影响":["20.12"],"如果某个组件使用了provider包裹":["20.13"],"那么该组件的状态是独立的":["20.13"],"getdefaultstore":["20.14"],"useatomvalue":["20.14"],"num":["20.14"],"num2":["20.14"],"navstore":["20.14"],"更新store中的state":["21.1"],"subscribe":["21.1"],"enhancer":["21.2"],"这样的优点就是把操作整合到一起":["25.1"],"只需要知道用户执行了什么操作去reducer中寻找响应的程序而不是直接触发这些程序":["25.1"],"然后返回新的state":["25.2"],"done":["25.4"],"false":["25.4"],"changed":["25.4"],"tasksk":["25.4"],"map":["25.4"],"t":["25.4"],"initstate":["25.5"],"接收接受个初始值":["25.5"],"和状态计算函数":["25.5"],"返回的dispatch来调用状态计算函数":["25.5"],"通过usestate保存状态":["25.5"],"usereducer可以配合副作用和中间件来处理状态变化时的特定逻辑":["25.6"],"使得状态管理更加灵活":["25.6"],"复杂动态表单":["25.6"],"在处理复杂的动态表单或用户输入场景时":["25.6"],"实际使用":["31.1"],"abstract":["31.1"],"authservice":["31.1"],"xxx":["31.1"],"控制反转需要一个容器":["31.2"],"配置集中管理":["31.3"],"容器需要有一个解析的方法":["31.4"],"依赖":["31.5"],"未被注册到容器":["31.5"],"请先注册到容器再去使用":["31.5"],"width":["36.0"],"scrolling":["36.0"],"no":["36.0"],"title":["36.0"],"untitled":["36.0"],"src":["36.0"],"https":["36.0"],"codepen":["36.0"],"io":["36.0"],"woskvxzd":["36.0"],"the":["36.0"],"animator":["36.0"],"embed":["36.0"],"qwymdbq":["36.0"],"tab":["36.0"],"2cresult":["36.0"],"frameborder":["36.0"],"loading":["36.0"]},{"0":["12.5","12.8"],"1":["12.3","16.3"],"2":["12.1"],"4":["12.3","19.3"],"5":["21.1"],"7":["6.1"],"17":["5.2"],"18":["5.2"],"28":["15.7"],"appcontroller":["1.1","1.2"],"constructor":["1.1","4.1","14.4","16.2"],"private":["1.1"],"readonly":["1.1"],"appservice":["1.1","1.2"],"get":["1.1"],"useguards":["1.1"],"eagonguard":["1.1"],"controllers":["1.2","5.4"],"providers":["1.2","5.4"],"provide":["1.2"],"app":["1.2"],"interceptor":["1.2"],"可维护性":["1.3"],"xjclass":["2.0"],"make":["2.0"],"return":["2.0","16.4","20.9","20.14"],"this":["2.0"],"is":["2.0"],"method":["2.0"],"hd":["2.0"],"依赖注入其他提供者":["2.0"],"注册到全局module":["3.0"],"module":["3.0"],"imports":["3.0"],"configmodule":["3.0"],"forroot":["3.0"],"isglobal":["3.0"],"true":["3.0","14.4","36.0"],"load":["3.0"],"controller":["3.0"],"内部仅仅调用一个抽象的方法":["4.0"],"具体的方法实现由第三方决定":["4.0"],"protected":["4.1"],"env配置相关":["5.0"],"同事还可以与其他服务交互以完成复杂的业务逻辑":["5.1"],"service是处理应用程序逻辑的类":["5.1"],"将业务逻辑从controller中分离出来":["5.1"],"使得controller只需处理http请求和响应":["5.1"],"控制器拦截器":["5.2"],"异常过滤器":["5.2"],"而不仅仅是服务类":["5.3"],"提供者是":["5.3"],"nestjs":["5.3"],"应用程序中的核心概念之一":["5.3"],"它们将代码块标记为可注入的":["5.3"],"authservice":["5.4","31.5"],"jwtstrategy":["5.4"],"控制器":["5.4"],"authcontroller":["5.4"],"向外提供接口":["5.4"],"guards":["6.1"],"鉴权认证相关":["6.1"],"拦截器":["6.1"],"查询参数":["7.0"],"响应对象等":["7.0"],"载荷":["9.0"],"签名规则":["9.0"],"执行副作用":["12.1"],"b1":["12.1"],"这是分类b下的项目b1":["12.1"],"current":["12.3"],"每个回调函数捕获正确的值":["12.3"],"造成此结果的原因是当循环时":["12.3"],"每次循环执行的settimeout都会在一秒钟后执行":["12.3"],"当一秒钟后执行时当前的i已经是10了":["12.3"],"console":["12.5","12.8"],"log":["12.5"],"重新渲染":["12.5"],"reducertest":["12.6"],"number":["12.6","15.1"],"dispatchnumber":["12.6"],"initialstate":["12.6"],"count":["12.8","20.14"],"setcount":["12.8","20.14"],"usestate":["12.8","25.5"],"和":["14.0"],"uselayouteffect":["14.0"],"更新":["14.1"],"js":["14.1"],"执行完成":["14.1"],"视图绘制完毕":["14.1"],"才执行":["14.1"],"一句话概括如何选择":["14.2"],"修改":["14.2"],"4em":["14.3"],"background":["14.3","20.14"],"papayawhip":["14.3"],"render":["14.3","16.2","18.3"],"hello":["14.3"],"world":["14.3"],"这个是时候":["14.3"],"的作用就出现了":["14.3"],"的执行在":["14.3"],"改变props":["14.4"],"br":["14.4"],"false":["14.4"],"卸载组件":["14.4"],"做数据初始化":["14.4"],"将滑动处理函数":["14.4"],"cloneelement":["15.2"],"强化":["15.2"],"混入新的":["15.2"],"是不能直接渲染的":["15.3"],"直接渲染会报错":["15.3"],"details":["15.3"],"view":["15.3"],"the":["15.3"],"code":["15.3"],"null":["15.4"],"index":["15.4"],"直接传入或者是抽离到子组件中":["15.5"],"组件一方面直接将":["15.6"],"组件":["15.6"],"alien":["15.7"],"mes":["15.7"],"let":["15.7"],"us":["15.7"],"区别":["15.8"],"显示注入在dom":["15.8"],"view内可以直接看到":["15.8"],"隐式注入再函数内使用cloneelemnt":["15.8"],"item":["15.9"],"createref":["16.1"],"component":["16.2"],"super":["16.2"],"div":["16.2","20.6","20.8","20.9","20.14"],"son":["16.2"],"如上代码所示":["16.3"],"流程主要分为几个方面":["16.3"],"通过":["16.3"],"创建一个":["16.3"],"对象":["16.3"],"将当前":["16.3"],"对象传递给子组件":["16.3"],"你可以通过一些简单的":["17.1"],"hooks":["17.1"],"和配置来处理数据获取和管理":["17.1"],"减少了编写重复代码的工作量":["17.1"],"总之":["17.1","25.6"],"尽管可以使用普通的数据获取库来处理数据请求":["17.1"],"但":["17.1"],"无服务器状态更新等问题":["17.2"],"issuequery":["17.9"],"span":["17.9"],"仓库":["17.9"],"input":["17.9"],"name":["17.9"],"value":["17.9","20.5","20.6"],"onchange":["17.9"],"e":["17.9"],"target":["17.9"],"isfetching":["17.10"],"表示是否正在获取数据":["17.10"],"无论是从远程服务器还是从缓存中":["17.10"],"如果正在获取数据":["17.10"],"之类的可以基于路由实现":["18.0"],"重构":["18.0"],"维护":["18.0"],"例如登录判断":["18.3"],"router":["18.3"],"path":["18.3"],"logged":["18.3"],"与创建对象形式的存储不同":["19.1","20.1"],"针对每一个变量可以是响应式的":["19.1","20.1"],"通过原子派生的方式来适应复杂的开发场景":["19.1","20.1"],"在复杂的应用程序中":["19.3"],"数据流动可能涉及多个嵌套的回调函数和依赖关系":["19.3"],"这会导致代码的可读性和可维护性下降":["19.3"],"数据存储":["19.4"],"负责管理应用程序的状态和逻辑":["19.4"],"接收来自":["19.4"],"的动作并更新自身的状态":["19.4"],"它通过将原子状态进行派生":["20.3"],"组合成新的状态":["20.3"],"类似vue的computed":["20.3"],"所谓组件内状态":["20.3"],"其实就是内部使用了usestate":["20.3"],"text":["20.5"],"export":["20.6"],"onclick":["20.7","20.8","20.9"],"button":["20.8","20.9"],"addnumber":["20.9"],"组件b渲染":["20.10"],"p":["20.10"],"组件b":["20.10"],"这么做的目的":["20.11"],"防止无意义的渲染":["20.11"],"这样就不会触发更新了":["20.12"],"不受外部影响":["20.13"],"同时也不影响外部":["20.13"],"status":["20.14"],"style":["20.14"],"pink":["20.14"],"black":["20.14"],"订阅":["21.1"],"监听store中的state变化":["21.1"],"增强器":["21.2"],"动作":["21.2"],"更加符合常理":["25.1"],"这样action行为会随着时间的推移积累到状态中":["25.2"],"if":["25.4"],"task":["25.4"],"else":["25.4"],"setstate":["25.5"],"function":["25.5"],"usereducer可以帮助更好地处理不同字段的状态变化":["25.6"],"usereducer适用于需要更精细控制状态逻辑":["25.6"],"处理复杂状态变化":["25.6"],"instance":["31.1"],"constroller":["31.1"],"这个容器接手类的控制权":["31.2"],"从容器中解析已注册的依赖项并注入":["31.4"],"让所有的依赖项统一管理注册解耦了对象之间的强依赖关系":["31.4"],"lazy":["36.0"],"allowtransparency":["36.0"],"allowfullscreen":["36.0"],"see":["36.0"],"pen":["36.0"],"a":["36.0"],"href":["36.0"],"by":["36.0"],"耿延":["36.0"]},{"0":["17.9"],"1":["12.8","17.9","20.14"],"2":["12.3","16.3"],"3":["15.9"],"19":["5.2"],"123":["20.14"],"在上面的代码中":["1.0"],"我们将loggermiddleware中间件添加到了appmodule模块中":["1.0"],"并使用forroutes":["1.0"],"方法指定了该中间件适用于所有路由":["1.0"],"这样":["1.0"],"每次请求到达控制器之前":["1.0"],"都会先执行loggermiddleware中间件中的代码":["1.0"],"gethello":["1.1"],"string":["1.1"],"将authguard守卫添加到路由上":["1.1"],"并使用":["1.1"],"装饰器指定守卫":["1.1"],"这样每次请求到达控制器之前都会先执行authguard守卫中的代码":["1.1"],"以确保请求的合法性":["1.1"],"useclass":["1.2"],"appmodule":["1.2"],"管道的应用场景":["1.3"],"将做为参数传递给":["2.0"],"方法":["2.0"],"authcontroller":["2.0"],"authmodule":["2.0","5.4"],"constroctor":["3.0"],"直接注入":["3.0"],"传递泛型类型":["3.0"],"configtype会提供类型":["3.0"],"而不需要处理业务逻辑":["5.1"],"在service中":["5.1"],"可以编写业务逻辑和调用其他服务":["5.1"],"路由":["5.2"],"之后是控制器":["5.2"],"之后是全局":["5.2"],"服务器响应":["5.2"],"并提供与其它代码块之间的依赖关系":["5.3"],"当需要在组件或控制器中使用一个实例时":["5.3"],"会自动处理依赖关系并将实例提供给需要的组件或控制器":["5.3"],"exports":["5.4"],"export":["5.4","12.5","12.8","20.10","25.5"],"class":["5.4"],"interceptors":["6.1"],"处理http请求前后所执行的逻辑":["6.1"],"executioncontext只在当前请求有效":["7.0"],"不可以和其他请求共享":["7.0"],"返回token":["9.0"],"项目b2":["12.1"],"这是分类b下的项目b2":["12.1"],"alt":["12.1"],"text":["12.1","15.9"],"let会在每次循环的时候保存当前作用域的变量":["12.3"],"所以每次循环的时候都会保存当前的i":["12.3"],"所以打印出来的结果是0":["12.3"],"tip":["12.3"],"不会产生新的作用域":["12.3"],"所以每次循环的时候都是共享一个作用域":["12.3"],"所以每次循环的时候都会覆盖上一次的i":["12.3"],"所以最后打印出来的结果都是10":["12.3"],"return":["12.5","15.3","20.5"],"button":["12.5","12.6","20.14"],"onclick":["12.5","12.6","20.14"],"点击":["12.5"],"default":["12.5","12.8","20.6","20.10"],"div":["12.6","12.8","20.5"],"add":["12.6","20.7","20.8","20.9","20.14"],"log":["12.8"],"所以":["14.1"],"回调函数不会阻塞浏览器绘制视图":["14.1"],"改变布局就用":["14.2"],"其他情况就用":["14.2"],"dom":["14.3"],"更新前":["14.3"],"所以此时使用":["14.3"],"避免了浏览器出现再次重回和重排的可能":["14.3"],"解决了性能上的问题":["14.3"],"如果使用uselayouteffect的话":["14.3"],"它的执行时机在dom更新完成":["14.3"],"浏览器只需绘制即可":["14.3"],"此时插入style便可引起浏览器的重绘":["14.3"],"因为样式发生了变化":["14.3"],"做防抖处理":["14.4"],"getderivedstatefromprops":["14.4"],"props获取后":["14.4"],"得到两个参数":["14.4"],"上一个props":["14.4"],"更新或的props":["14.4"],"组件挂载后":["14.4"],"shouldcomponentupdate":["14.4"],"性能优化":["14.4"],"只有":["14.4"],"list":["14.4"],"改变":["14.4"],"渲染视图":["14.4"],"render":["14.4"],"渲染":["14.4"],"item":["14.4"],"getsnapshotbeforeupdate":["14.4"],"保存更新前的快照数据":["14.4"],"组件即将更新":["14.4"],"组件即将卸载":["14.4"],"或者修改":["15.2"],"的子元素":["15.2"],"这种情况需要先遍历":["15.4"],"判断":["15.4"],"元素类型":["15.4"],"针对":["15.4"],"element":["15.4"],"节点":["15.4"],"通过":["15.4"],"针对函数":["15.4"],"直接传递参数":["15.4"],"执行函数":["15.4"],"抽象传递给":["15.6"],"一方面混入":["15.6"],"learn":["15.7"],"react":["15.7"],"api":["15.8"],"注入":["15.8"],"myinput":["15.9"],"e":["15.9"],"target":["15.9"],"ref对象模式获取元素或组件":["16.1"],"向":["16.3"],"组件传递的":["16.3"],"对象上":["16.3"],"绑定":["16.3"],"孙组件实例":["16.3"],"子组件实例":["16.3"],"和":["16.3"],"提供了一整套功能":["17.1"],"可以更好地管理数据获取":["17.1"],"缓存":["17.1"],"状态以及用户体验等方面的问题":["17.1"],"从而减少了开发工作量并提供了更好的性能和用户体验":["17.1"],"查看最新issue信息":["17.9"],"最新一条issue信息":["17.9"],"stringify":["17.9"],"data":["17.9"],"dataupdatedat":["17.10"],"表示数据上次更新的时间戳":["17.10"],"refetch":["17.10"],"用于手动重新获取数据的函数":["17.10"],"扩展更容易":["18.0"],"dashboard":["18.3"],"publichome":["18.3"],"atom":["19.1","20.1"],"组件通信困难":["19.3"],"当应用程序中的组件需要共享和同步状态时":["19.3"],"传统的mvc模式无法提供一个清晰的机制来处理组件之间的通信和状态共享":["19.3"],"action":["19.4"],"动作":["19.4"],"定义用户在":["19.4"],"中执行的操作":["19.4"],"它们会被发送给":["19.4"],"state变化":["20.3"],"触发更新渲染罢了":["20.3"],"有兴趣可以阅读手动实现recoil原理":["20.3"],"danger":["20.6"],"这样会阻塞渲染线程":["20.6"],"不建议这样做":["20.6"],"异步请求应该放在组件内部":["20.6"],"或者使用异步更新atom":["20.6"],"www":["20.9"],"abc":["20.9"],"com":["20.9"],"asynctest":["20.10"],"不会触发订阅事件":["20.12"],"即使大家共用同一个atom状态":["20.13"],"p":["20.14"],"x":["20.14"],"combinereducer":["21.1"],"将多个reducers合并成一个rootreducer":["21.1"],"reducer":["21.2"],"纯函数":["21.2"],"filter":["25.4"],"throw":["25.4"],"error":["25.4"],"未知":["25.4"],"使用中间件或副作用等情况下":["25.6"],"可以优于简单使用usestate来管理组件状态":["25.6"],"此时我们的constroller与service解耦":["31.1"],"具体调用的方法完全取决于外部依赖注入进来的方法":["31.1"],"可扩展性":["31.1"],"解耦":["31.1"],"可测试性":["31.1"],"controller":["31.5"],"on":["36.0"]}]'},t={"0.0":{t:"<resume/>",p:"",l:"Resume/index.html",a:"resume"},"1.0":{t:"中间件",p:`::: info 存在意义
处理HTTP请求的函数，他可以在请求到达控制器之前/之后执行一些操作 他可以是全局的也可以是局部的
场景：身份验证，日志记录，错误处理
:::
::: details
中间 ...`,l:"articles/BackEnd/NestJs/Basic/Code/Concept.html",a:"中间件"},"1.1":{t:"守卫",p:`Guard 是一种用于保护路由的机制，他可以在请求到达控制器之前或者之后执行一些操作。守卫可以用于实现身份验证，权限控制，缓存等功能。在NestJs中收尾可以是全局的也可以是局部的。守卫路由
[[Ex ...`,l:"articles/BackEnd/NestJs/Basic/Code/Concept.html#守卫",a:"守卫"},"1.2":{t:"拦截器",p:`处理HTTP请求和响应的函数，在请求到达控制器之前之后执行一些操作。拦截器可以实现日志记录，错误处理，数据转换。在Nestjs中拦截器可以是全局的也可局部
@Injectable()
export c ...`,l:"articles/BackEnd/NestJs/Basic/Code/Concept.html#拦截器",a:"拦截器"},"1.3":{t:"管道",p:`管道是数据流入controller前进行的一波数据处理
其中数据处理包含了对数据的转换,验证。他可以在控制器之前或之后对数据进行预处理。然后将数据传递给控制器或下一个管道。
$$管道的主要目的是增强应 ...`,l:"articles/BackEnd/NestJs/Basic/Code/Concept.html#管道",a:"管道"},"2.0":{t:">注入基本数据",p:`因为普通数据服务不是Class，所以要使用@Inject来注入

@Module({
	providers:[
		{
			provide:'APP_NAME',
			useValue:'使用普通 ...`,l:"articles/BackEnd/NestJs/Basic/Code/Provider.html",a:"注入基本数据"},"3.0":{t:"> 案例，第三方发送短信服务。 根据不同配置使用不同的第三方运营商",p:`sms.serivce.ts
@Injectable()
export class AppController(){
	constructor(){
		private ali:aliService, ...`,l:"articles/BackEnd/NestJs/Basic/Code/env配置相关.html",a:"案例-第三方发送短信服务。-根据不同配置使用不同的第三方运营商"},"4.0":{t:"控制反转 IOC",p:`面向对象中的设计原则，用来减少计算机代码之前的耦合度。其根本思想是：”借助于第三方“ 实现具有依赖关系的对象之间的解耦

$$ 第三方举例：TS注解，或直接传递参数。总之控制权不在类中，而是由外部决定 ...`,l:"articles/BackEnd/NestJs/Basic/Code/设计模式模式.html",a:"控制反转-ioc"},"4.1":{t:"依赖注入 DI",p:`IOC 的具体实现，在类以外的地方提供服务。类内部调用的是该具体服务的抽象

	abstrct class Phone {
		playGame(name:string):string
	}
	cla ...`,l:"articles/BackEnd/NestJs/Basic/Code/设计模式模式.html#依赖注入-di",a:"依赖注入-di"},"5.0":{t:"- Nest 请求声明周期",p:`

[[Provider]]

动态Provider
asynProvider



Module

静态模块
动态模块
全局模块



[[env配置相关]]


`,l:"articles/BackEnd/NestJs/Basic/Module Contorller Service.html",a:"nest-请求声明周期"},"5.1":{t:"Module Controller Service的关系",p:`
Module 提供了一个模块化的方式来组织和管理您的应用程序的代码，同时还允许您使用依赖注入和模块之间的依赖关系来构建更加可扩展的应用程序。
$$ Module是Nestjs应用程序的基本构建块，每 ...`,l:"articles/BackEnd/NestJs/Basic/Module Contorller Service.html#module-controller-service的关系",a:"module-controller-service的关系"},"5.2":{t:"Nest 请求生命周期",p:`!img

1.  收到请求
2.  全局绑定的中间件
3.  模块绑定的中间件
4.  全局守卫
5.  控制层守卫
6.  路由守卫
7.  全局拦截器（控制器之前）
8.  控制器层拦截器 （控 ...`,l:"articles/BackEnd/NestJs/Basic/Module Contorller Service.html#nest-请求生命周期",a:"nest-请求生命周期"},"5.3":{t:"[[Provider]]",p:`提供服务,用于表示应用程序中可注入的任何东西。除了服务，Provider 还可以提供其他类型的对象，例如 Factory 工厂、配置对象、连接对象等。


提供者使用 @Injectable() 装饰 ...`,l:"articles/BackEnd/NestJs/Basic/Module Contorller Service.html#provider",a:"provider"},"5.4":{t:"Module",p:`模块是一个子程序，用于定义控制器，提供者或向其他模块开放提供者（开放模块的API）


默认情况下控制器，提供者在当前模块可用，即模块作用域
若果向其他模块提供服务可以将提供者定义在export属性中 ...`,l:"articles/BackEnd/NestJs/Basic/Module Contorller Service.html#module",a:"module"},"5.5":{t:"	",p:"",l:"articles/BackEnd/NestJs/Basic/Module Contorller Service.html#",a:""},"5.6":{t:"动态Module",p:"",l:"articles/BackEnd/NestJs/Basic/Module Contorller Service.html#动态module",a:"动态module"},"6.0":{t:"hi  我是Eagon,今天给大家分享Nest基础系列-Nestjs核心基础概念。 愿我们共同进步",p:"",l:"articles/BackEnd/NestJs/Basic/NestJs核心概念.html",a:"hi-我是eagon-今天给大家分享nest基础系列-nestjs核心基础概念。-愿我们共同进步"},"6.1":{t:"核心概念概览",p:`
模块 Modules 组合所有逻辑的地方,我理解为DI的Container
控制器 Controller处理请求
服务 Service 操作数据库以及处理所有逻辑的地方
管道 Pipes 核验请求的 ...`,l:"articles/BackEnd/NestJs/Basic/NestJs核心概念.html#核心概念概览",a:"核心概念概览"},"6.2":{t:" 重点1: NestJs 处理Https时的生命周期",p:"",l:"articles/BackEnd/NestJs/Basic/NestJs核心概念.html#重点1-nestjs-处理https时的生命周期",a:"重点1-nestjs-处理https时的生命周期"},"7.0":{t:">他代表了一个HTTP请求的执行上下文，提供了许多属性和方法，可用于在请求的生命周期内访问",p:`
ExecutionContext是在每个请求到达控制器之前被Nestjs封装产生的，他的请求是将请求的上下文，传递给控制器，拦截器，管道，守卫等各个部分。以便他们可以对请求进行处理和转换
当一个请求 ...`,l:"articles/BackEnd/NestJs/Basic/link/Execution Context 执行上下文.html",a:"他代表了一个http请求的执行上下文-提供了许多属性和方法-可用于在请求的生命周期内访问"},"8.0":{t:"# NestJs",p:"",l:"articles/BackEnd/NestJs/index.html",a:"nestjs"},"9.0":{t:"- register 接收账号密码argon2 hash 加密插入数据库",p:`
login   登录接收账号密码，argon2 verify对密码进行解密
解密符合，根据头信息，载荷, 签名规则 返回token

`,l:"articles/BackEnd/NestJs/jwt/流程.html",a:"register-接收账号密码argon2-hash-加密插入数据库"},"11.0":{t:"js",p:"",l:"articles/FontEnd/js/index.html",a:"js"},"12.0":{t:"# React",p:"",l:"articles/FontEnd/react/Basic/Hooks.html",a:"react"},"12.1":{t:"API分类",p:`
关键词： concurrent
&lt;table&gt;
&lt;tr&gt;
&lt;th&gt;使用范围&lt;/th&gt;
&lt;th&gt;Hooks&lt;/th&gt;
&lt;t ...`,l:"articles/FontEnd/react/Basic/Hooks.html#api分类",a:"api分类"},"12.2":{t:"Hooks",p:"",l:"articles/FontEnd/react/Basic/Hooks.html#hooks",a:"hooks"},"12.3":{t:"useRef",p:`&lt;details&gt;
场景：稳定引用，获取dom节点，获取上一次的值

闭包 异步访问到旧变量的问题

::: code-group
 // 典型的闭包循环案例，每次循环调用setTimeo ...`,l:"articles/FontEnd/react/Basic/Hooks.html#useref",a:"useref"},"12.4":{t:"数据更新驱动类",p:"",l:"articles/FontEnd/react/Basic/Hooks.html#数据更新驱动类",a:"数据更新驱动类"},"12.5":{t:"useState",p:`&lt;details&gt;
const [state, setState] = useState(initialState);
参数接收一个初始值，返回一个数组，数组的第一个元素是当前的state ...`,l:"articles/FontEnd/react/Basic/Hooks.html#usestate",a:"usestate"},"12.6":{t:"useReducer",p:`对于拥有许多状态更新逻辑的组件来说，过于分散的事件处理程序可能会令人不知所措。对于这种情况，你可以将组件的所有状态更新(增删改查)逻辑整合到一个外部函数中，这个函数叫作 reducer。
reduce ...`,l:"articles/FontEnd/react/Basic/Hooks.html#usereducer",a:"usereducer"},"12.7":{t:"useContext",p:`作用: 传递数据，避免props层层传递，导致代码冗余
`,l:"articles/FontEnd/react/Basic/Hooks.html#usecontext",a:"usecontext"},"12.8":{t:"useImperativeHandle",p:`::: info 解决了什么问题?
子组件通过ref抛出方法供父组件调用
React函数 组件，父组件需要直接访问子组件的实例方法或属性的问题。
在 React 中，父组件通常通过 props 向子组 ...`,l:"articles/FontEnd/react/Basic/Hooks.html#useimperativehandle",a:"useimperativehandle"},"13.0":{t:"# 项目列表",p:"",l:"articles/FontEnd/react/Basic/index.html",a:"项目列表"},"13.1":{t:"高阶组件HOC",p:"",l:"articles/FontEnd/react/Basic/index.html#高阶组件hoc",a:"高阶组件hoc"},"14.0":{t:"# 生命周期",p:`React hooks也提供了 api ，用于弥补函数组件没有生命周期的缺陷。其原理主要是运用了 hooks 里面的 useEffect 和 useLayoutEffect
`,l:"articles/FontEnd/react/Basic/lifeCycle.html",a:"生命周期"},"14.1":{t:"useEffect",p:`useEffect(()=&gt;{
    return destory
},dep)


第一个参数callback 返回销毁函数 下次执行useEffect会首先执行这个销毁函数。 销毁定时器, ...`,l:"articles/FontEnd/react/Basic/lifeCycle.html#useeffect",a:"useeffect"},"14.2":{t:"useLayoutEffect",p:`useLayoutEffect 和 useEffect 不同的地方是采用了同步执行


首先 useLayoutEffect 是在 DOM 更新之后，浏览器绘制之前，这样可以方便修改 DOM，获取 D ...`,l:"articles/FontEnd/react/Basic/lifeCycle.html#uselayouteffect",a:"uselayouteffect"},"14.3":{t:"useInsertionEffect",p:`在介绍 useInsertionEffect 用途之前，先看一下 useInsertionEffect 的执行时机。
React.useEffect(()=&gt;{
    console.log( ...`,l:"articles/FontEnd/react/Basic/lifeCycle.html#useinsertioneffect",a:"useinsertioneffect"},"14.4":{t:"类组件生命周期在函数组件内使用Effect替代方案",p:`::: code-group
// componentDidMount
React.useEffect(()=&gt;{
    /* 请求数据 ， 事件监听 ， 操纵dom */
},[])  /* ...`,l:"articles/FontEnd/react/Basic/lifeCycle.html#类组件生命周期在函数组件内使用effect替代方案",a:"类组件生命周期在函数组件内使用effect替代方案"},"15.0":{t:"# props",p:"",l:"articles/FontEnd/react/Basic/props.html",a:"props"},"15.1":{t:"监听props改变",p:`函数组件中可以用 useEffect 来作为 props 改变后的监听函数。(不过有一点值得注意, useEffect 初始化会默认执行一次)
  React.useEffect(()=&gt;{
  ...`,l:"articles/FontEnd/react/Basic/props.html#监听props改变",a:"监听props改变"},"15.2":{t:"Render Children 模式",p:`① props 插槽组件

&lt;Container&gt;
    &lt;Children&gt;
&lt;/Container&gt;


上述可以在 Container 组件中，通过 pro ...`,l:"articles/FontEnd/react/Basic/props.html#render-children-模式",a:"render-children-模式"},"15.3":{t:"Render Props 模式",p:`&lt;Container&gt;
   { (ContainerProps)=&gt; &lt;Children {...ContainerProps}  /&gt; }
&lt;/Containe ...`,l:"articles/FontEnd/react/Basic/props.html#render-props-模式",a:"render-props-模式"},"15.4":{t:"组合模式",p:`如果 Container 的 Children 既有函数也有组件，这种情况应该怎么处理呢？
&lt;Container&gt;
    &lt;Children /&gt;
    { (Contai ...`,l:"articles/FontEnd/react/Basic/props.html#组合模式",a:"组合模式"},"15.5":{t:"操作Props 抽象Props",p:`::: tip
抽象 props 一般用于跨层级传递 props ，一般不需要具体指出 props 中某个属性，而是将 props 直接传入或者是抽离到子组件中。
:::
`,l:"articles/FontEnd/react/Basic/props.html#操作props-抽象props",a:"操作props-抽象props"},"15.6":{t:"混入 props",p:`::: details View The Code
function Son(props){
    console.log(props)
    return &lt;div&gt; hello,w ...`,l:"articles/FontEnd/react/Basic/props.html#混入-props",a:"混入-props"},"15.7":{t:"抽离Props",p:`::: details View The Code
function Son(props){
    console.log(props)
    return &lt;div&gt; hello,w ...`,l:"articles/FontEnd/react/Basic/props.html#抽离props",a:"抽离props"},"15.8":{t:"props 的显式注入和隐式注入",p:`显式注入
&lt;Father&gt;
    &lt;Son data='{data}' name='123'&gt;
&lt;/Father&gt;

隐式注入
function Father(p ...`,l:"articles/FontEnd/react/Basic/props.html#props-的显式注入和隐式注入",a:"props-的显式注入和隐式注入"},"15.9":{t:"demo",p:`::: code-group

用于表单状态管理的&lt;Form&gt; 和 &lt;FormItem&gt; 组件

&lt;Form&gt;用于管理表单状态；
&lt;FormItem&gt;用 ...`,l:"articles/FontEnd/react/Basic/props.html#demo",a:"demo"},"16.0":{t:"# Ref",p:"",l:"articles/FontEnd/react/Basic/ref.html",a:"ref"},"16.1":{t:"获取Ref的三种方式",p:`
ref是一个字符串
::: details View The Code

/* 类组件 */
class Children extends Component{  
    render=()=&g ...`,l:"articles/FontEnd/react/Basic/ref.html#获取ref的三种方式",a:"获取ref的三种方式"},"16.2":{t:"转发Ref(跨层级获取Ref)",p:`如果我想在父组件 获取 孙/子 组件的实例

通过回调函数将子组件的Ref作为参数
::: details View The Code

function ParentComponent(){
  c ...`,l:"articles/FontEnd/react/Basic/ref.html#转发ref-跨层级获取ref",a:"转发ref-跨层级获取ref"},"16.3":{t:"组合转发Ref",p:`::: details View The Code
// 表单组件
class Form extends React.Component{
    render(){
       return &l ...`,l:"articles/FontEnd/react/Basic/ref.html#组合转发ref",a:"组合转发ref"},"16.4":{t:"高阶组件转发",p:"如果通过高阶组件包裹一个原始类组件，就会产生一个问题，如果高阶组件 HOC 没有处理 ref ，那么由于高阶组件本身会返回一个新组件，所以当使用 HOC 包装后组件的时候，标记的 ref 会指向 HO ...",l:"articles/FontEnd/react/Basic/ref.html#高阶组件转发",a:"高阶组件转发"},"17.0":{t:"# React Query",p:"",l:"articles/FontEnd/react/ReactQuery/index.html",a:"react-query"},"17.1":{t:"出现背景/解决问题",p:"**灵魂拷问Q： 为什么用axios不可以 为什么需要出现React QueryA:尽管可以使用普通的 Axios 或其他数据获取库来处理数据请求，但在某些情况下，使用 React Query 可以带 ...",l:"articles/FontEnd/react/ReactQuery/index.html#出现背景-解决问题",a:"出现背景-解决问题"},"17.2":{t:"核心概念",p:`解决普通请求代码重复，后期维护困难。无数据缓存，无数据同步，无数据预取，无数据失效处理，无服务器状态更新等问题。
`,l:"articles/FontEnd/react/ReactQuery/index.html#核心概念",a:"核心概念"},"17.3":{t:"使用教程",p:"",l:"articles/FontEnd/react/ReactQuery/index.html#使用教程",a:"使用教程"},"17.4":{t:"自动缓存和数据同步",p:"",l:"articles/FontEnd/react/ReactQuery/index.html#自动缓存和数据同步",a:"自动缓存和数据同步"},"17.5":{t:"加载状态管理",p:"",l:"articles/FontEnd/react/ReactQuery/index.html#加载状态管理",a:"加载状态管理"},"17.6":{t:"数据同步和预取",p:"",l:"articles/FontEnd/react/ReactQuery/index.html#数据同步和预取",a:"数据同步和预取"},"17.7":{t:"自动缓存失效处理",p:"",l:"articles/FontEnd/react/ReactQuery/index.html#自动缓存失效处理",a:"自动缓存失效处理"},"17.8":{t:"服务器状态更新",p:"",l:"articles/FontEnd/react/ReactQuery/index.html#服务器状态更新",a:"服务器状态更新"},"17.9":{t:"更少的重复代码",p:`::: code-group
import as React from 'react';
​
export default function App() {
  // 存储 后端返回数据
  cons ...`,l:"articles/FontEnd/react/ReactQuery/index.html#更少的重复代码",a:"更少的重复代码"},"17.10":{t:"API",p:`


APIname
Are




data：
查询返回的数据


isLoading：
表示查询是否正在加载中。如果数据正在加载，该属性为 true；否则为 false。


isError：
表 ...`,l:"articles/FontEnd/react/ReactQuery/index.html#api",a:"api"},"17.11":{t:"总结",p:"",l:"articles/FontEnd/react/ReactQuery/index.html#总结",a:"总结"},"18.0":{t:"# React Router",p:`后端概念：发送url请求到服务器端，server会通过不同的地址返回不同的页面
为什么需要路由：

单页应用需要路由切换
通过url可以定位到页面
更有语义的组织资源

三种路由的实现方式：

Bro ...`,l:"articles/FontEnd/react/ReactRouter/index.html",a:"react-router"},"18.1":{t:"快速上手",p:"",l:"articles/FontEnd/react/ReactRouter/index.html#快速上手",a:"快速上手"},"18.2":{t:"原理分析",p:"",l:"articles/FontEnd/react/ReactRouter/index.html#原理分析",a:"原理分析"},"18.3":{t:"核心API",p:`


name
effect
demo




Link
普通链接，不会触发刷新
&lt;Link to=&quot;&quot;/&gt;


NavLink
类似Link
但是会添加当前选中状态& ...`,l:"articles/FontEnd/react/ReactRouter/index.html#核心api",a:"核心api"},"19.0":{t:"# React 全局存储/状态管理",p:"",l:"articles/FontEnd/react/Storage/index.html",a:"react-全局存储-状态管理"},"19.1":{t:"常见的状态管理模式",p:`
global：  全局式，也被称作单一数据源，将所有的数据放到一个大对象中，关键词：combineReducers();
multiple stores：  多数据源模式，将状态存放到多个数据源中， ...`,l:"articles/FontEnd/react/Storage/index.html#常见的状态管理模式",a:"常见的状态管理模式"},"19.2":{t:"Flex 架构",p:"",l:"articles/FontEnd/react/Storage/index.html#flex-架构",a:"flex-架构"},"19.3":{t:"出现背景 & 解决痛点",p:"Flux架构解决前端应用程序中状态管理和数据流动的复杂性问题。在传统的MVC（Model-View-Controller）模式中，应用程序的状态分散在多个视图和控制器之间，导致数据流动难以追踪和管理。 ...",l:"articles/FontEnd/react/Storage/index.html#出现背景-解决痛点",a:"出现背景-解决痛点"},"19.4":{t:"架构特点 & 详细介绍",p:`Flux架构通过引入单向数据流的概念，将数据的流动变得可控和可预测。它明确了数据流动的路径，并将状态的修改限制在特定的流程中。这样做的好处包括：


易于追踪和调试：由于数据流是单向的，数据的变化路径 ...`,l:"articles/FontEnd/react/Storage/index.html#架构特点-详细介绍",a:"架构特点-详细介绍"},"20.0":{t:"# Jotai",p:`引用来源：Ryun
`,l:"articles/FontEnd/react/Storage/jotai/index.html",a:"jotai"},"20.1":{t:"常见的状态管理模式",p:`
global：  全局式，也被称作单一数据源，将所有的数据放到一个大对象中，关键词：combineReducers();
multiple stores：  多数据源模式，将状态存放到多个数据源中， ...`,l:"articles/FontEnd/react/Storage/jotai/index.html#常见的状态管理模式",a:"常见的状态管理模式"},"20.2":{t:"Jotai  原子状态管理",p:"",l:"articles/FontEnd/react/Storage/jotai/index.html#jotai-原子状态管理",a:"jotai-原子状态管理"},"20.3":{t:"原子式解决了什么问题",p:`reactHook 使State的拆分和逻辑共享变得更容易
但useState 和 useContext对于多个store仍需要维护多个Context Provider 因为当Context改变，所有 ...`,l:"articles/FontEnd/react/Storage/jotai/index.html#原子式解决了什么问题",a:"原子式解决了什么问题"},"20.4":{t:"使用教程",p:"",l:"articles/FontEnd/react/Storage/jotai/index.html#使用教程",a:"使用教程"},"20.5":{t:"1. 创建 atom  派生atom  使用 useAtom",p:`::: details View The Code
import { atom, useAtom } from &quot;jotai&quot;;
import { FC } from &quot; ...`,l:"articles/FontEnd/react/Storage/jotai/index.html#_1-创建-atom-派生atom-使用-useatom",a:"_1-创建-atom-派生atom-使用-useatom"},"20.6":{t:"2. 异步派生",p:`::: details View The Code
import { atom, useAtom } from &quot;jotai&quot;;
import { FC } from &quot; ...`,l:"articles/FontEnd/react/Storage/jotai/index.html#_2-异步派生",a:"_2-异步派生"},"20.7":{t:"3. 函数组件内更新方式",p:`::: details View The Code
  const ValueAtom = atom(1)
  const Text = ()=&gt;{
    const [value,setVa ...`,l:"articles/FontEnd/react/Storage/jotai/index.html#_3-函数组件内更新方式",a:"_3-函数组件内更新方式"},"20.8":{t:"4. atom内更新方式",p:`::: details View The Code
  const ValueAtom = atom(1)
  const AddNumberAtom = atom(ge=&gt;ge(ValueAt ...`,l:"articles/FontEnd/react/Storage/jotai/index.html#_4-atom内更新方式",a:"_4-atom内更新方式"},"20.9":{t:"5. 异步更新atom 区别于第二条异步获取，异步更新不会阻塞线程",p:`::: details View The Code
  const MockData = new Promise&lt;string&gt;((r) =&gt; {
    setTimeout(() ...`,l:"articles/FontEnd/react/Storage/jotai/index.html#_5-异步更新atom-区别于第二条异步获取-异步更新不会阻塞线程",a:"_5-异步更新atom-区别于第二条异步获取-异步更新不会阻塞线程"},"20.10":{t:"6. 渲染问题",p:`:::   details View The Code

当我们点击add时，发现A和B都重新渲染了，但是问题来了，A为什么要重新渲染呀，A只是触发了更新操作，并不需要重新渲染呀？？？


这是因为， ...`,l:"articles/FontEnd/react/Storage/jotai/index.html#_6-渲染问题",a:"_6-渲染问题"},"20.11":{t:"7. 解决渲染问题 useAtomValue、useSetAtom",p:`
如果有的组件只需要监听状态的变化值，而没有更新操作 请使用useAtomValue
如果仅更新操作，而无需渲染状态的组件，请使用 useSetAtom
这么做的目的：防止无意义的渲染

`,l:"articles/FontEnd/react/Storage/jotai/index.html#_7-解决渲染问题-useatomvalue、usesetatom",a:"_7-解决渲染问题-useatomvalue、usesetatom"},"20.12":{t:"8. Provider",p:`
正常情况下，无需用Provider包裹组件
但如果需要控制某些组件的状态不发生更新，可以用Provider包裹
或者说，用Provider包裹的组件，状态是独立的，不受外部影响，同时也不影响外部，即 ...`,l:"articles/FontEnd/react/Storage/jotai/index.html#_8-provider",a:"_8-provider"},"20.13":{t:"9.store",p:`
createStore,export出去,使用Jotai的Provider提供给App


其中，store中的状态，是全局的，任何组件都可以使用，但是，如果某个组件使用了Provider包裹，那么 ...`,l:"articles/FontEnd/react/Storage/jotai/index.html#_9-store",a:"_9-store"},"20.14":{t:"实际使用",p:`::: code-group
import { createStore, atom } from &quot;jotai&quot;;

const myStore = createStore();
 ...`,l:"articles/FontEnd/react/Storage/jotai/index.html#实际使用",a:"实际使用"},"21.0":{t:"# Redux",p:"",l:"articles/FontEnd/react/Storage/redux/index.html",a:"redux"},"21.1":{t:"API介绍",p:`
reducer 纯函数，接收两个参数，一个是state，一个是action，返回一个新的state
createStore 创建一个 root 存放 state的根对象
dispatch 更新sto ...`,l:"articles/FontEnd/react/Storage/redux/index.html#api介绍",a:"api介绍"},"21.2":{t:"摘要",p:`
middleware 中间件,中间件用于增强 dispatch 功能，返回一个增强后的 dispatch（比如 redux-thunk 使 action 可以为 function）
enhancer ...`,l:"articles/FontEnd/react/Storage/redux/index.html#摘要",a:"摘要"},"22.0":{t:"!react",p:"",l:"articles/FontEnd/react/index.html",a:"react"},"24.0":{t:"context",p:"",l:"articles/FontEnd/relevance/context.html",a:"context"},"25.0":{t:"# reducer",p:`
action + state  = new state

`,l:"articles/FontEnd/relevance/reducer.html",a:"reducer"},"25.1":{t:"与state的区别",p:`state是用户触发函数来执行具体的一步一步操作，reducer是把操作整合到一起，用户触发事件名进而执行相应的处理函数
例如：用户触发添加程序, 程序了解到事件名以后去reducer中找到对应的函数 ...`,l:"articles/FontEnd/relevance/reducer.html#与state的区别",a:"与state的区别"},"25.2":{t:"命名原因",p:`reducer是根据reduce命名 ,它接收目前的结果和当前的值，然后返回下一个结果.
React中的reducer也是这样的他们都接受 当前state 和触发的事件action ,然后返回新的st ...`,l:"articles/FontEnd/relevance/reducer.html#命名原因",a:"命名原因"},"25.3":{t:" ",p:"",l:"articles/FontEnd/relevance/reducer.html#",a:""},"25.4":{t:"reduce实现reducer",p:`::: code-group
import tasksReducer from './tasksReducer.js';

let actions = [
  {type: 'added', id:  ...`,l:"articles/FontEnd/relevance/reducer.html#reduce实现reducer",a:"reduce实现reducer"},"25.5":{t:"实现useReducer",p:`通过useState保存当前状态＋action = new state
::: code-group
const App = ()=&gt;{
  const [state,dispatch] = u ...`,l:"articles/FontEnd/relevance/reducer.html#实现usereducer",a:"实现usereducer"},"25.6":{t:"实际用途",p:`useReducer是React提供的一个Hook，用于管理组件的状态（state）。它的实际用途包括：


状态复杂逻辑：当组件的状态逻辑较为复杂，涉及多个状态变化时，可以使用useReducer来 ...`,l:"articles/FontEnd/relevance/reducer.html#实际用途",a:"实际用途"},"26.0":{t:"useRef",p:"",l:"articles/FontEnd/relevance/useRef.html",a:"useref"},"27.0":{t:"# vue",p:"",l:"articles/FontEnd/vue/index.html",a:"vue"},"29.0":{t:"前置",p:"",l:"articles/algorithm/base/index.html",a:"前置"},"30.0":{t:"时间复杂度",p:"",l:"articles/algorithm/base/time.html",a:"时间复杂度"},"31.0":{t:"# Nest主要设计模式",p:"",l:"articles/designModel/IOCDI/index.html",a:"nest主要设计模式"},"31.1":{t:"Dependency Injection 依赖注入",p:`class UserService {
  getList(id) {
    // 获取用户的逻辑 
  }
}

class Controller {
  constructor() {
     ...`,l:"articles/designModel/IOCDI/index.html#dependency-injection-依赖注入",a:"dependency-injection-依赖注入"},"31.2":{t:"Inversion of Control  控制反转",p:`控制反转的本质就是降低耦合度，不再强依赖一些属性和方法。具体的实现方式是DI依赖注入
控制反转需要一个容器，这个容器接手类的控制权
`,l:"articles/designModel/IOCDI/index.html#inversion-of-control-控制反转",a:"inversion-of-control-控制反转"},"31.3":{t:"好处",p:`
解耦和模块化
更方便的依赖注入
配置集中管理

`,l:"articles/designModel/IOCDI/index.html#好处",a:"好处"},"31.4":{t:"如何控制反转",p:`控制反转需要的条件如下

需要一个管理容器  Container
容器需要拥有register方法用来管理容器的注册
容器需要有一个解析的方法 （从容器中解析已注册的依赖项并注入)
让所有的依赖项统一 ...`,l:"articles/designModel/IOCDI/index.html#如何控制反转",a:"如何控制反转"},"31.5":{t:"案例",p:`  abstract class Service {
    getList: () =&gt; void;
    putList: () =&gt; void;
  }

  class Cont ...`,l:"articles/designModel/IOCDI/index.html#案例",a:"案例"},"32.0":{t:"设计模式",p:"",l:"articles/designModel/index.html",a:"设计模式"},"33.0":{t:"<myIndex/>",p:"",l:"index.html",a:"myindex"},"34.0":{t:"# 记录和楠楠的日常生活",p:"",l:"nannan/index.html",a:"记录和楠楠的日常生活"},"35.0":{t:"# 我们的故事",p:"",l:"nannan/story/index.html",a:"我们的故事"},"36.0":{t:"# 根据空格拆分字符串",p:` const str = \`remote_addr：192.168.3.69:48512
status_code：200
content_type：
method：GET
proto：HTTP/1.1 ...`,l:"otherArticles/index.html",a:"根据空格拆分字符串"},"37.0":{t:"<!-- ---",p:`layout :  false
layout: page
&lt;team/&gt; --&gt;
`,l:"team/index.html",a:""}},r={previewLength:100,buttonLabel:"搜索",placeholder:"情输入关键词",allow:[],ignore:[]},n={INDEX_DATA:e,PREVIEW_LOOKUP:t,Options:r};export{n as default};
