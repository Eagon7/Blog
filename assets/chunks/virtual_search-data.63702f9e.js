const e={map:'[{"resume":["0.0"],"中间件":["1.0"],"守卫":["1.1"],"拦截器":["1.2"],"管道":["1.3"],"注入基本数据":["2.0"],"案例":["3.0","22.5"],"控制反转":["4.0"],"依赖注入":["4.1"],"nest":["5.0","5.2"],"module":["5.1","5.4"],"provider":["5.3"],"动态module":["5.6"],"hi":["6.0"],"核心概念概览":["6.1"],"重点1":["6.2"],"他代表了一个http请求的执行上下文":["7.0"],"nestjs":["8.0"],"register":["9.0"],"js":["10.0"],"react":["11.0","12.0","13.0","14.0"],"快速上手":["11.1"],"原理分析":["11.2"],"hooks":["12.1"],"api分类":["12.2"],"数据更新驱动类":["12.3"],"usestate":["12.4"],"usereducer":["12.5"],"常见的状态管理模式":["14.1","15.1"],"jotai":["15.0","15.2"],"原子式解决了什么问题":["15.3"],"使用教程":["15.4"],"实际使用":["15.14"],"redux":["16.0"],"api介绍":["16.1"],"摘要":["16.2"],"reducer":["17.0"],"与state的区别":["17.1"],"命名原因":["17.2"],"reduce实现reducer":["17.4"],"实现usereducer":["17.5"],"实际用途":["17.6"],"vue":["18.0"],"前置":["20.0"],"时间复杂度":["21.0"],"nest主要设计模式":["22.0"],"dependency":["22.1"],"inversion":["22.2"],"好处":["22.3"],"如何控制反转":["22.4"],"设计模式":["23.0"],"myindex":["24.0"],"记录和楠楠的日常生活":["25.0"],"我们的故事":["26.0"]},{"0":["15.14","16.1"],"1":["5.2","6.1","12.4","14.1","15.1","15.5","22.3"],"2":["5.2","15.6"],"3":["15.7"],"4":["15.8"],"5":["15.9"],"6":["15.10"],"7":["15.11"],"8":["15.12"],"9":["15.13"],"info":["1.0"],"存在意义":["1.0"],"处理http请求的函数":["1.0"],"他可以在请求到达控制器之前":["1.0"],"之后执行一些操作":["1.0"],"他可以是全局的也可以是局部的":["1.0"],"场景":["1.0"],"身份验证":["1.0"],"日志记录":["1.0"],"guard":["1.1"],"是一种用于保护路由的机制":["1.1"],"他可以在请求到达控制器之前或者之后执行一些操作":["1.1"],"守卫可以用于实现身份验证":["1.1"],"权限控制":["1.1"],"缓存等功能":["1.1"],"在nestjs中收尾可以是全局的也可以是局部的":["1.1"],"守卫路由":["1.1"],"execution":["1.1"],"context":["1.1"],"处理http请求和响应的函数":["1.2"],"在请求到达控制器之前之后执行一些操作":["1.2"],"拦截器可以实现日志记录":["1.2"],"错误处理":["1.2"],"数据转换":["1.2"],"在nestjs中拦截器可以是全局的也可局部":["1.2"],"管道是数据流入controller前进行的一波数据处理":["1.3"],"因为普通数据服务不是class":["2.0"],"所以要使用":["2.0"],"inject来注入":["2.0"],"typescript":["2.0","3.0","15.6","22.1","22.5"],"module":["2.0"],"providers":["2.0"],"provide":["2.0"],"app":["2.0","17.5"],"name":["2.0"],"usevalue":["2.0"],"使用普通值":["2.0"],"injectable":["2.0","3.0"],"export":["2.0","3.0","15.14"],"class":["2.0","3.0","22.1","22.5"],"authservice":["2.0"],"第三方发送短信服务":["3.0"],"根据不同配置使用不同的第三方运营商":["3.0"],"sms":["3.0"],"serivce":["3.0"],"ts":["3.0","12.4","15.14","17.4"],"appcontroller":["3.0"],"constructor":["3.0","22.1"],"private":["3.0"],"ali":["3.0"],"aliservice":["3.0"],"tencent":["3.0"],"ioc":["4.0","4.1"],"di":["4.1"],"的具体实现":["4.1"],"请求声明周期":["5.0"],"controller":["5.1","22.1"],"service的关系":["5.1"],"提供了一个模块化的方式来组织和管理您的应用程序的代码":["5.1"],"请求生命周期":["5.2"],"img":["5.2"],"java":["5.2"],"收到请求":["5.2"],"提供服务":["5.3"],"用于表示应用程序中可注入的任何东西":["5.3"],"除了服务":["5.3"],"还可以提供其他类型的对象":["5.3"],"模块是一个子程序":["5.4"],"用于定义控制器":["5.4"],"提供者或向其他模块开放提供者":["5.4"],"开放模块的api":["5.4"],"默认情况下控制器":["5.4"],"提供者在当前模块可用":["5.4"],"我是eagon":["6.0"],"模块":["6.1"],"modules":["6.1"],"nestjs":["6.2"],"提供了许多属性和方法":["7.0"],"可用于在请求的生命周期内访问":["7.0"],"接收账号密码argon2":["9.0"],"router":["11.0"],"速通":["12.0"],"关键词":["12.2"],"concurrent":["12.2"],"table":["12.2"],"tr":["12.2"],"th":["12.2"],"使用范围":["12.2"],"hooks":["12.2"],"const":["12.4","15.14","17.5"],"state":["12.4","17.5","17.6"],"setstate":["12.4"],"initialstate":["12.4"],"参数接收一个初始值":["12.4"],"返回一个数组":["12.4"],"数组的第一个元素是当前的state":["12.4"],"第二个元素是更新state的函数":["12.4"],"注意事项":["12.4"],"在函数组件":["12.4"],"对于拥有许多状态更新逻辑的组件来说":["12.5"],"过于分散的事件处理程序可能会令人不知所措":["12.5"],"对于这种情况":["12.5"],"你可以将组件的所有状态更新":["12.5"],"增删改查":["12.5"],"逻辑整合到一个外部函数中":["12.5"],"这个函数叫作":["12.5"],"reducer":["12.5","16.1"],"reducer是弥补usestate在逻辑复杂情况下的缺陷":["12.5"],"它分为三个步骤":["12.5"],"全局存储":["14.0"],"global":["14.1","15.1"],"全局式":["14.1","15.1"],"引用来源":["15.0"],"原子状态管理":["15.2"],"reacthook":["15.3"],"使state的":["15.3"],"拆分":["15.3"],"和":["15.3"],"创建":["15.5"],"atom":["15.5","15.14"],"派生atom":["15.5"],"使用":["15.5"],"useatom":["15.5"],"异步派生":["15.6"],"details":["15.6","15.7","15.8","15.9","15.10"],"view":["15.6","15.8","15.9","15.10"],"the":["15.6","15.8","15.9","15.10"],"code":["15.6","15.8","15.9","15.10","15.14","17.4","17.5"],"import":["15.6","15.14","17.4"],"函数组件内更新方式":["15.7"],"atom内更新方式":["15.8"],"异步更新atom":["15.9"],"区别于第二条异步获取":["15.9"],"异步更新不会阻塞线程":["15.9"],"渲染问题":["15.10"],"当我们点击add时":["15.10"],"发现a和b都重新渲染了":["15.10"],"但是问题来了":["15.10"],"a为什么要重新渲染呀":["15.10"],"a只是触发了更新操作":["15.10"],"provider":["15.12"],"store":["15.13","15.14"],"group":["15.14","17.4","17.5"],"createstore":["15.14"],"from":["15.14","17.4"],"jotai":["15.14"],"mystore":["15.14"],"countatom":["15.14"],"纯函数":["16.1"],"middleware":["16.2"],"中间件":["16.2"],"action":["17.0","17.5"],"state是用户触发函数来执行具体的一步一步操作":["17.1"],"reducer是根据reduce命名":["17.2"],"index":["17.4"],"js":["17.4","17.5"],"tasksreducer":["17.4"],"let":["17.4"],"actions":["17.4"],"type":["17.4"],"added":["17.4"],"通过usestate保存当前状态":["17.5"],"new":["17.5"],"usereducer是react提供的一个hook":["17.6"],"用于管理组件的状态":["17.6"],"injection":["22.1"],"依赖注入":["22.1"],"userservice":["22.1"],"getlist":["22.1","22.5"],"id":["22.1"],"获取用户的逻辑":["22.1"],"this":["22.1"],"of":["22.2"],"控制反转需要的条件如下":["22.4"],"abstract":["22.5"],"service":["22.5"],"void":["22.5"],"putlist":["22.5"],"layout":["27.0"]},{"1":["12.5","15.8","17.4","22.4"],"2":["6.1","12.4","12.5","17.4"],"3":["5.2","12.5"],"4":["5.2"],"5":["5.2","12.2"],"错误处理":["1.0"],"details":["1.0","15.5"],"中间件可以执行以下任务":["1.0"],"执行任何代码操作":["1.0"],"对请求对象进行更改":["1.0"],"结束当前请求生命周期":["1.0"],"调用下一个中间件函数":["1.0"],"如果当前中间件没有":["1.0"],"手动结束生命周期":["1.0"],"执行上下文":["1.1"],"typescript":["1.1","1.2","4.1","15.5","15.7","15.8","15.9"],"n":["1.1"],"g":["1.1"],"gu":["1.1"],"xxx":["1.1"],"no":["1.1"],"spec":["1.1"],"injectable":["1.1","1.2"],"export":["1.1","1.2"],"class":["1.2"],"logginginterceptor":["1.2"],"implements":["1.2"],"nestinterceptor":["1.2"],"其中数据处理包含了对数据的转换":["1.3"],"constractor":["2.0"],"inject":["2.0","3.0"],"private":["2.0","22.5"],"appname":["2.0"],"注册类":["2.0"],"使用类将提供者注册到服务是最常用的方式":["2.0"],"autherservice":["2.0"],"以上是简写形式":["2.0"],"完整写法应该如下":["2.0"],"tencentservices":["3.0"],"smsservice":["3.0"],"base":["3.0"],"key":["3.0","22.5"],"baseconfig":["3.0"],"configtype":["3.0"],"typeof":["3.0"],"getsmsservice":["3.0"],"type":["3.0"],"string":["3.0","15.9","22.5"],"const":["3.0","15.6","15.8","15.9","22.1"],"面向对象中的设计原则":["4.0"],"用来减少计算机代码之前的耦合度":["4.0"],"在类以外的地方提供服务":["4.1"],"类内部调用的是该具体服务的抽象":["4.1"],"provider":["5.0"],"同时还允许您使用依赖注入和模块之间的依赖关系来构建更加可扩展的应用程序":["5.1"],"module是nestjs应用程序的基本构建块":["5.1"],"每个模块都有一个独立的作用域":["5.1"],"其中包含一组相关的controller":["5.1"],"全局绑定的中间件":["5.2"],"模块绑定的中间件":["5.2"],"全局守卫":["5.2"],"控制层守卫":["5.2"],"例如":["5.3"],"factory":["5.3"],"工厂":["5.3"],"配置对象":["5.3"],"连接对象等":["5.3"],"提供者使用":["5.3"],"即模块作用域":["5.4"],"若果向其他模块提供服务可以将提供者定义在export属性中":["5.4"],"其他模块需要再imports属性中引入当前模块":["5.4"],"模块是":["5.4"],"设计模式模式":["5.4"],"的":["5.4"],"多个模块共享当前模块实例":["5.4"],"今天给大家分享nest基础系列":["6.0"],"组合所有逻辑的地方":["6.1"],"我理解为di的container":["6.1"],"控制器":["6.1"],"处理https时的生命周期":["6.2"],"executioncontext是在每个请求到达控制器之前被nestjs封装产生的":["7.0"],"他的请求是将请求的上下文":["7.0"],"hash":["9.0"],"加密插入数据库":["9.0"],"具体功能":["12.2"],"td":["12.2"],"rowspan":["12.2"],"数据更新驱动":["12.2"],"一次执行上下文中":["12.4"],"的值是":["12.4"],"固定不变的":["12.4"],"如果两次":["12.4"],"dispatchaction":["12.4"],"传入":["12.4"],"相同的":["12.4"],"值":["12.4"],"那么组件就":["12.4"],"不会更新":["12.4"],"将设置状态的逻辑":["12.5"],"修改成dispatch":["12.5"],"的一个":["12.5"],"action":["12.5"],"编写":["12.5"],"一个":["12.5"],"函数":["12.5"],"状态管理":["14.0"],"也被称作单一数据源":["14.1","15.1"],"将所有的数据放到一个大对象中":["14.1","15.1"],"关键词":["14.1","15.1"],"ryun":["15.0"],"逻辑共享":["15.3"],"变得更容易":["15.3"],"但usestate":["15.3"],"view":["15.5","15.7"],"the":["15.5","15.7"],"code":["15.5","15.7"],"import":["15.5"],"atom":["15.6","15.8"],"useatom":["15.6"],"from":["15.6"],"jotai":["15.6"],"fc":["15.6"],"react":["15.6"],"valueatom":["15.8"],"mockdata":["15.9"],"new":["15.9","22.1"],"promise":["15.9"],"r":["15.9"],"settimeout":["15.9"],"并不需要重新渲染呀":["15.10"],"这是因为":["15.10"],"如果使用useatom":["15.10"],"即使你不引入它的value值":["15.10"],"但它由useatomvalue包裹":["15.10"],"当更新时":["15.10"],"useatomvalue会触发订阅事件":["15.10"],"从而触发渲染":["15.10"],"如果不理解可以阅读":["15.10"],"recoil原理":["15.10"],"理解":["15.10"],"解决渲染问题":["15.11"],"useatomvalue":["15.11"],"正常情况下":["15.12"],"无需用provider包裹组件":["15.12"],"createstore":["15.13"],"export出去":["15.13"],"statusatom":["15.14"],"false":["15.14","27.0"],"监听发生变化":["15.14"],"sub":["15.14"],"console":["15.14"],"log":["15.14"],"value":["15.14"],"is":["15.14"],"changed":["15.14"],"to":["15.14"],"get":["15.14"],"set":["15.14"],"接收两个参数":["16.1"],"一个是state":["16.1"],"一个是action":["16.1"],"中间件用于增强":["16.2"],"dispatch":["16.2","17.5"],"功能":["16.2"],"state":["17.0"],"reducer是把操作整合到一起":["17.1"],"它接收目前的结果和当前的值":["17.2"],"id":["17.4"],"text":["17.4"],"参观卡夫卡博物馆":["17.4"],"看木偶戏":["17.4"],"deleted":["17.4"],"usereducer":["17.5"],"reducer":["17.5"],"initialstate":["17.5"],"return":["17.5"],"div":["17.5"],"button":["17.5"],"onclick":["17.5"],"它的实际用途包括":["17.6"],"状态复杂逻辑":["17.6"],"当组件的状态逻辑较为复杂":["17.6"],"涉及多个状态变化时":["17.6"],"service":["22.1"],"read":["22.1"],"处理用户数据的逻辑":["22.1"],"result":["22.1"],"control":["22.2"],"解耦和模块化":["22.3"],"container":["22.5"],"创建一个变量存贮依赖项":["22.5"],"dependencies":["22.5"]},{"1":["1.0","15.7","15.9","16.1"],"2":["14.1","15.1","15.14","22.3"],"3":["6.1","12.4","17.4"],"6":["5.2"],"7":["5.2"],"8":["5.2"],"3000":["15.9"],"必须使用next":["1.0"],"方法将控制权传递给下一个中间件函数":["1.0"],"否则请求将被挂起":["1.0"],"定义中间件":["1.0"],"code":["1.0","12.5","22.1"],"group":["1.0","12.5"],"typescript":["1.0","5.4","15.10"],"index":["1.0"],"ts":["1.0","2.0","12.5"],"class":["1.1","4.1"],"authgurad":["1.1"],"implements":["1.1"],"canactive":["1.1"],"canactivate":["1.1"],"contenxt":["1.1"],"executioncontext":["1.1","1.2"],"boolean":["1.1"],"promise":["1.1","15.6"],"observable":["1.1"],"intercept":["1.2"],"context":["1.2"],"next":["1.2"],"callhandler":["1.2"],"console":["1.2"],"log":["1.2"],"验证":["1.3"],"provider":["2.0","5.1","15.3"],"useclass":["2.0"],"动态注册":["2.0"],"下面实现根据不同的环境创建不同的服务":["2.0"],"首先安装":["2.0"],"dotenv":["2.0"],"扩展包":["2.0"],"用来读取":["2.0"],"env环境变量":["2.0"],"然后创建两个服务":["2.0"],"service":["2.0","3.0","6.1"],"与":["2.0"],"b":["2.0"],"tencnetservice":["3.0"],"if":["3.0"],"return":["3.0","22.1"],"privider":["3.0"],"curenv":["3.0"],"this":["3.0","22.5"],"config":["3.0"],"get":["3.0","15.8"],"其根本思想是":["4.0"],"借助于第三方":["4.0"],"abstrct":["4.1"],"phone":["4.1"],"playgame":["4.1"],"动态provider":["5.0"],"asynprovider":["5.0"],"service和其他提供者":["5.1"],"module的作用是将应用程序拆分为更小的可重用部分":["5.1"],"以便更好的组织代码和管理依赖关系":["5.1"],"路由守卫":["5.2"],"全局拦截器":["5.2"],"控制器之前":["5.2"],"injectable":["5.3"],"装饰器定义":["5.3"],"这样系统会分析":["5.3"],"constructor":["5.3"],"进行依赖注入":["5.3"],"模块提供者也是单例":["5.4"],"所以模块被多个其他模块使用":["5.4"],"那该模块的provider也是共享的":["5.4"],"导入其他模块":["5.4"],"nestjs核心基础概念":["6.0"],"controller处理请求":["6.1"],"服务":["6.1"],"传递给控制器":["7.0"],"拦截器":["7.0"],"管道":["7.0"],"login":["9.0"],"usestate":["12.2"],"数据驱动更新":["12.2"],"usereducer":["12.2"],"当触发":["12.4"],"在":["12.4"],"当前执行上下文中获取不到最新的state":["12.4"],"只有再下一次组件":["12.4"],"rerender":["12.4"],"中才能获取到":["12.4"],"案例":["12.4"],"此时点击按钮":["12.4"],"log打印出来的值并不是更改过后的number":["12.4"],"而是更改前的值":["12.4"],"在你的组件中":["12.5"],"使用":["12.5"],"参数":["12.5"],"const":["12.5","15.7","17.4"],"state":["12.5"],"dispatch":["12.5"],"combinereducers":["14.1","15.1"],"multiple":["14.1","15.1"],"usecontext对于多个store仍需要维护多个context":["15.3"],"因为当context改变":["15.3"],"所有消费该context的组件都会重新渲染即使是组件仅用到了":["15.3"],"context的一部分":["15.3"],"from":["15.5","15.10"],"jotai":["15.5"],"fc":["15.5","15.10"],"mockdata":["15.6"],"new":["15.6","17.0"],"string":["15.6"],"r":["15.6"],"settimeout":["15.6"],"mock":["15.6","15.9"],"data":["15.6","15.9","22.1"],"valueatom":["15.7","15.9"],"atom":["15.7","15.9","15.10"],"addnumberatom":["15.8"],"ge":["15.8"],"a组件使用即订阅":["15.10"],"atom原子更新触发订阅事件从而更新":["15.10"],"解决办法":["15.10"],"参考7":["15.10"],"import":["15.10"],"react":["15.10","15.14"],"usesetatom":["15.11"],"如果有的组件只需要监听状态的变化值":["15.11"],"但如果需要控制某些组件的状态不发生更新":["15.12"],"可以用provider包裹":["15.12"],"使用jotai的provider提供给app":["15.13"],"其中":["15.13"],"default":["15.14","22.1"],"main":["15.14"],"reactdom":["15.14"],"返回一个新的state":["16.1"],"createstore":["16.1"],"返回一个增强后的":["16.2"],"用户触发事件名进而执行相应的处理函数":["17.1"],"例如":["17.1"],"然后返回下一个结果":["17.2"],"打卡列侬墙":["17.4"],"finalstate":["17.4"],"reduce":["17.4"],"output":["17.4"],"document":["17.4"],"getelementbyid":["17.4"],"type":["17.5"],"add":["17.5"],"message":["17.5"],"添加":["17.5"],"可以使用usereducer来更好地组织和管理状态的变化逻辑":["17.6"],"替代usestate":["17.6"],"在一些情况下":["17.6"],"使用usereducer可以替代多个独立的usestate":["17.6"],"js":["22.1"],"export":["22.1"],"msg":["22.1"],"focused":["22.1"],"focus":["22.1"],"此时controller":["22.1"],"和":["22.1"],"存在了强耦合的关联":["22.1"],"控制反转":["22.2"],"需要一个管理容器":["22.4"],"container":["22.4"],"any":["22.5"],"注册方法":["22.5"],"register":["22.5"],"dependency":["22.5"]},{"0":["15.10"],"1":["15.6"],"2":["22.4"],"4":["6.1"],"9":["5.2"],"10":["5.2"],"3000":["15.6"],"中间件实例代码":["1.0"],"injectable":["1.0"],"export":["1.0","17.4"],"class":["1.0"],"loggermiddleware":["1.0"],"implements":["1.0"],"nestmiddleware":["1.0"],"use":["1.0"],"req":["1.0"],"const":["1.1","1.2","15.5","15.10"],"request":["1.1"],"switchtohttp":["1.1"],"getrequest":["1.1"],"return":["1.1","1.2"],"validaterequest":["1.1"],"function":["1.1","17.4"],"before":["1.2"],"now":["1.2"],"date":["1.2"],"他可以在控制器之前或之后对数据进行预处理":["1.3"],"import":["2.0"],"config":["2.0"],"from":["2.0"],"读取":["2.0"],"env":["2.0"],"到":["2.0"],"process":["2.0"],"环境变量中":["2.0"],"path":["2.0"],"join":["2.0"],"system":["3.0"],"provider":["3.0","15.14"],"send":["3.0"],"getsmsprovider":["3.0"],"使用":["3.0"],"nest":["3.0"],"实现具有依赖关系的对象之间的解耦":["4.0"],"第三方举例":["4.0"],"name":["4.1"],"string":["4.1"],"module":["5.0"],"controller提供一个路由处理器":["5.1"],"他可以将http请求映射到响应的处理器方法上":["5.1"],"并将处理器方法的结果作为http响应返回给client":["5.1"],"controller是处理":["5.1"],"控制器层拦截器":["5.2"],"路由拦截器":["5.2"],"全局管道":["5.2"],"提供者在模块的":["5.3"],"providers":["5.3"],"属性中定义":["5.3"],"用于注册到服务容器中":["5.3"],"用于被其他类依赖注入":["5.3"],"提供者可以在自身的constructor构造函数中依赖注入其他服务提供者":["5.3"],"imports":["5.4"],"jwtmodule":["5.4"],"registerasync":["5.4"],"configmodule":["5.4"],"inject":["5.4"],"configservice":["5.4"],"愿我们共同进步":["6.0"],"操作数据库以及处理所有逻辑的地方":["6.1"],"管道":["6.1"],"守卫等各个部分":["7.0"],"以便他们可以对请求进行处理和转换":["7.0"],"登录接收账号密码":["9.0"],"argon2":["9.0"],"订阅状态":["12.2"],"创建reducer":["12.2"],"更新试图":["12.2"],"usesyncexternalstore":["12.2"],"订阅外部数据源触发更新":["12.2"],"这意味着log时更改未发生":["12.4"],"br":["12.4"],"原因":["12.4"],"setnumber是异步的":["12.4"],"触发handleclick时":["12.4"],"任务线程会先执行同步再执行异步":["12.4"],"所以log打印的是更改前的值":["12.4"],"外部log可以获取到最新的值的原因是":["12.4"],"在执行完同步的log后执行异步setnumber":["12.4"],"异步setnumber触发重新渲染":["12.4"],"重新执行index函数":["12.4"],"usestate获取到最新的number":["12.4"],"initstate":["12.5"],"实际使用":["12.5"],"type":["12.5"],"stores":["14.1","15.1"],"多数据源模式":["14.1","15.1"],"将状态存放到多个数据源中":["14.1","15.1"],"容易导致不必要的":["15.3"],"无用渲染":["15.3"],"造成性能损失":["15.3"],"比如react":["15.3"],"react":["15.5"],"创建atom":["15.5","15.6"],"valueatom":["15.5","15.6"],"派生atom":["15.6"],"依赖某个atom":["15.6"],"text":["15.7"],"value":["15.7"],"set":["15.8","15.9"],"arg":["15.8","15.9"],"addnumberatom":["15.9"],"null":["15.9","17.4"],"async":["15.9"],"get":["15.9"],"result":["15.9"],"useatom":["15.10"],"useatomvalue":["15.10"],"usesetatom":["15.10"],"jotai":["15.10"],"countatom":["15.10"],"a":["15.10"],"而没有更新操作":["15.11"],"请使用useatomvalue":["15.11"],"或者说":["15.12"],"用provider包裹的组件":["15.12"],"store中的状态":["15.13"],"是全局的":["15.13"],"dom":["15.14"],"client":["15.14"],"app":["15.14"],"tsx":["15.14"],"index":["15.14"],"css":["15.14"],"创建一个":["16.1"],"root":["16.1"],"存放":["16.1"],"比如":["16.2"],"redux":["16.2"],"thunk":["16.2"],"用户触发添加程序":["17.1"],"react中的reducer也是这样的他们都接受":["17.2"],"textcontent":["17.4"],"json":["17.4"],"stringify":["17.4"],"reducer":["17.4"],"default":["17.4"],"newstate":["17.5"],"接收状态事件":["17.5"],"计算新的状态":["17.5"],"switch":["17.5"],"从而将相关状态集中管理":["17.6"],"减少状态逻辑的分散":["17.6"],"可预测性":["17.6"],"无法复用":["22.1"],"若我们想用authservice时必须新注册一个类来实现":["22.1"],"并且需要改动getuser里面的代码":["22.1"],"那我们此时就需要解决这个问题":["22.1"],"使用di":["22.1"],"依赖是service":["22.1"],"依赖的标准需要拥有一个getlist方法":["22.1"],"并且接收一个id":["22.1"],"控制反转的本质就是降低耦合度":["22.2"],"更方便的依赖注入":["22.3"],"解析方法":["22.5"],"resolve":["22.5"],"if":["22.5"],"page":["27.0"]},{"2":["16.1"],"3":["14.1","15.1","22.3","22.4"],"5":["6.1"],"11":["5.2"],"12":["5.2"],"13":["5.2"],"14":["5.2"],"request":["1.0"],"res":["1.0"],"response":["1.0"],"next":["1.0"],"function":["1.0"],"console":["1.0","15.10"],"log":["1.0","15.10"],"中间件触发":["1.0"],"if":["1.1"],"true":["1.1"],"details":["1.1"],"定义一个authguard守卫类":["1.1"],"实现canactivate接口":["1.1"],"handle":["1.2"],"pipe":["1.2"],"tap":["1.2"],"after":["1.2"],"然后将数据传递给控制器或下一个管道":["1.3"],"管道的主要目的是增强应用的可靠性":["1.3"],"dirname":["2.0"],"const":["2.0"],"appservice":["2.0"],"node":["2.0"],"development":["2.0"],"bservice":["2.0"],"imports":["2.0"],"controllers":["2.0"],"快速配置env配置":["3.0"],"配置环境文件":["3.0"],"a":["3.0"],"import":["3.0"],"registeras":["3.0"],"from":["3.0"],"nestjs":["3.0"],"default":["3.0","17.5"],"ts注解":["4.0"],"或直接传递参数":["4.0"],"iphone":["4.1"],"extends":["4.1"],"静态模块":["5.0"],"http请求并返回http响应的类":["5.1"],"controller的作用是将路由映射到处理请求方法上":["5.1"],"在controller中可以使用nestjs提供的装饰器来定义":["5.1"],"路由":["5.1"],"中间件":["5.1"],"控制器管道":["5.2"],"路由管道":["5.2"],"路由参数管道":["5.2"],"需要使用":["5.3"],"装饰器声明该提供者":["5.3"],"注册到容器的提供者":["5.3"],"默认只对当前模块有效":["5.3"],"即作用域为模块":["5.3"],"usefactory":["5.4"],"return":["5.4","12.5","15.7","15.10","17.4","22.5"],"secret":["5.4"],"get":["5.4","15.6"],"pipes":["6.1"],"核验请求的数据":["6.1"],"过滤器":["6.1"],"当一个请求到达应用程序时":["7.0"],"nestjs框架会将他封装成一个executioncontext对象":["7.0"],"verify对密码进行解密":["9.0"],"解密符合":["9.0"],"usetransition":["12.2"],"concurrent模式下":["12.2"],"过渡更新任务":["12.2"],"所以打印的值是最新的number":["12.4"],"人话":["12.4"],"点击button时触发的log和setnumber在第一任务线程":["12.4"],"第一线程执行完毕后执行第一线程引起的一系列任务":["12.4"],"外部在第二任务线程中执行的":["12.4"],"此时setnumber已执行完毕":["12.4"],"点击按钮后执行过程":["12.4"],"线程1":["12.4"],"handleclick":["12.4"],"宏任务log":["12.4"],"微任务setnumber":["12.4"],"触发线程2":["12.4"],"线程2":["12.4"],"name":["12.5"],"switch":["12.5","17.4"],"case":["12.5","17.4","17.5"],"increment":["12.5"],"count":["12.5"],"可在多个地方使用消费":["14.1","15.1"],"usestore":["14.1","15.1"],"redux":["15.3"],"v6完全基于context":["15.3"],"api而导致性能大幅下降":["15.3"],"v7又回退到之前的内部订阅方案":["15.3"],"context更适合放类似主题这种变化不大的全局数据":["15.3"],"依赖某个atom":["15.5"],"当依赖项发生变化时更新触发atom的第一个参数修改变量":["15.5","15.6"],"deriveatom":["15.5","15.6"],"async":["15.6"],"setvalue":["15.7"],"useatom":["15.7"],"text":["15.8"],"fc":["15.8"],"value":["15.8"],"await":["15.9"],"url":["15.9"],"setcount":["15.10"],"组件a渲染":["15.10"],"div":["15.10"],"button":["15.10"],"onclick":["15.10"],"如果仅更新操作":["15.11"],"而无需渲染状态的组件":["15.11"],"状态是独立的":["15.12"],"不受外部影响":["15.12"],"同时也不影响外部":["15.12"],"任何组件都可以使用":["15.13"],"但是":["15.13"],"createroot":["15.14"],"document":["15.14"],"getelementbyid":["15.14"],"root":["15.14"],"render":["15.14"],"strictmode":["15.14"],"state的根对象":["16.1"],"dispatch":["16.1"],"使":["16.2"],"action":["16.2","17.4"],"可以为":["16.2"],"程序了解到事件名以后去reducer中找到对应的函数执行操作":["17.1"],"当前state":["17.2"],"和触发的事件action":["17.2"],"tasks":["17.4"],"previous":["17.4"],"state":["17.4"],"current":["17.4"],"使用usereducer可以使状态变化变得可预测":["17.6"],"因为它通过一个reducer函数来处理状态变化":["17.6"],"可以更好地理解状态变化的来源":["17.6"],"中间件和副作用":["17.6"],"不再强依赖一些属性和方法":["22.2"],"具体的实现方式是di依赖注入":["22.2"],"容器需要拥有register方法用来管理容器的注册":["22.4"],"throw":["22.5"],"team":["27.0"]},{"1":["15.10"],"3":["16.1"],"6":["6.1","12.4"],"8":["12.4"],"15":["5.2"],"16":["5.2"],"18":["3.0"],"使用":["1.0"],"添加到模块或者控制器中":["1.0"],"module":["1.0","1.2"],"在canactivate":["1.1"],"方法中":["1.1"],"通过参数context获取到请求对象":["1.1"],"调用validaterequest":["1.1"],"函数验证请求是否合法":["1.1"],"如果请求合法就返回true":["1.1"],"要在控制器中使用守卫":["1.1"],"需要将守卫添加到路由上":["1.1"],"useguard":["1.1"],"controller":["1.1"],"ms":["1.2"],"写入模块中作为提供者":["1.2"],"imports":["1.2"],"安全性":["1.3"],"appcontroller":["2.0"],"appmodule":["2.0"],"不使用dotenv扩展包的话需要手动readfile然后根据":["2.0"],"n拆分":["2.0"],"循环放入process":["2.0"],"key":["2.0"],"太麻烦":["2.0"],"工厂函数":["2.0"],"对于复杂要求的provider":["2.0"],"我们就可以使用":["2.0"],"usefactory":["2.0"],"工厂函数进行提供者注册":["2.0"],"name":["3.0"],"process":["3.0"],"env":["3.0"],"app":["3.0","5.4"],"age":["3.0"],"最终统一导入到config":["3.0"],"index":["3.0","12.4"],"再统一导出":["3.0"],"总之控制权不在类中":["4.0"],"而是由外部决定":["4.0"],"play":["4.1"],"student":["4.1"],"动态模块":["5.0"],"全局模块":["5.0"],"pipe":["5.1"],"dto和请求参数等":["5.1"],"service提供一种实现业务逻辑的方式":["5.1"],"他可以访问操作数据":["5.1"],"控制器":["5.2"],"方法处理器":["5.2"],"请求之后":["5.2"],"可以使用":["5.3"],"exports":["5.3"],"导出给其他模块使用":["5.3"],"提供者是单例的4":["5.3"],"提供者可以是任何值":["5.3"],"token":["5.4"],"expiresin":["5.4"],"100d":["5.4"],"模块提供者":["5.4"],"filters":["6.1"],"处理请求时的错误":["6.1"],"守卫":["6.1"],"这个对象包含了当前请求的上下文信息":["7.0"],"包括请求头":["7.0"],"请求体":["7.0"],"根据头信息":["9.0"],"usedeferredvalue":["12.2"],"解决更新状态滞后问题":["12.2"],"微任务setnumber触发重新渲染":["12.4"],"这就是为什么handleclick函数内打印不到最新的值":["12.4"],"而handleclick函数外可以大打印到最新的值的原因":["12.4"],"js":["12.4"],"function":["12.4","16.2"],"number":["12.4"],"setnumber":["12.4"],"decrement":["12.5"],"default":["12.5"],"throw":["12.5"],"new":["12.5","22.5"],"error":["12.5","22.5"],"atomic":["14.1","15.1"],"state":["14.1","15.1"],"原子状态":["14.1","15.1"],"而并不适合存放频繁更新的复杂状态集合":["15.3"],"原子化":["15.3"],"组件内状态":["15.3"],"但是api较多":["15.3"],"get":["15.5","22.1"],"使用atom":["15.5"],"return":["15.6","15.8"],"await":["15.6"],"text":["15.6","15.9"],"div":["15.7"],"button":["15.7"],"useatom":["15.8","15.9","15.14"],"addnumber":["15.8"],"fc":["15.9"],"value":["15.9"],"prev":["15.10"],"add":["15.10"],"b":["15.10"],"count":["15.10"],"请使用":["15.11"],"即使大家共用同一个atom状态":["15.12"],"如果不想让这个组件受外部更新影响":["15.12"],"如果某个组件使用了provider包裹":["15.13"],"那么该组件的状态是独立的":["15.13"],"getdefaultstore":["15.14"],"useatomvalue":["15.14"],"num":["15.14"],"num2":["15.14"],"navstore":["15.14"],"更新store中的state":["16.1"],"subscribe":["16.1"],"enhancer":["16.2"],"这样的优点就是把操作整合到一起":["17.1"],"只需要知道用户执行了什么操作去reducer中寻找响应的程序而不是直接触发这些程序":["17.1"],"然后返回新的state":["17.2"],"done":["17.4"],"false":["17.4"],"changed":["17.4"],"tasksk":["17.4"],"map":["17.4"],"t":["17.4"],"initstate":["17.5"],"接收接受个初始值":["17.5"],"和状态计算函数":["17.5"],"返回的dispatch来调用状态计算函数":["17.5"],"通过usestate保存状态":["17.5"],"usereducer可以配合副作用和中间件来处理状态变化时的特定逻辑":["17.6"],"使得状态管理更加灵活":["17.6"],"复杂动态表单":["17.6"],"在处理复杂的动态表单或用户输入场景时":["17.6"],"实际使用":["22.1"],"abstract":["22.1"],"authservice":["22.1"],"xxx":["22.1"],"控制反转需要一个容器":["22.2"],"配置集中管理":["22.3"],"容器需要有一个解析的方法":["22.4"],"依赖":["22.5"],"未被注册到容器":["22.5"],"请先注册到容器再去使用":["22.5"],"const":["22.5"]},{"0":["12.4"],"2":["12.2"],"5":["16.1"],"7":["6.1"],"17":["5.2"],"18":["5.2"],"appcontroller":["1.1","1.2"],"constructor":["1.1","4.1"],"private":["1.1"],"readonly":["1.1"],"appservice":["1.1","1.2"],"get":["1.1"],"useguards":["1.1"],"eagonguard":["1.1"],"controllers":["1.2","5.4"],"providers":["1.2","5.4"],"provide":["1.2"],"app":["1.2"],"interceptor":["1.2"],"可维护性":["1.3"],"xjclass":["2.0"],"make":["2.0"],"return":["2.0","15.9","15.14"],"this":["2.0"],"is":["2.0"],"method":["2.0"],"hd":["2.0"],"依赖注入其他提供者":["2.0"],"注册到全局module":["3.0"],"module":["3.0"],"imports":["3.0"],"configmodule":["3.0"],"forroot":["3.0"],"isglobal":["3.0"],"true":["3.0"],"load":["3.0"],"controller":["3.0"],"内部仅仅调用一个抽象的方法":["4.0"],"具体的方法实现由第三方决定":["4.0"],"protected":["4.1"],"env配置相关":["5.0"],"同事还可以与其他服务交互以完成复杂的业务逻辑":["5.1"],"service是处理应用程序逻辑的类":["5.1"],"将业务逻辑从controller中分离出来":["5.1"],"使得controller只需处理http请求和响应":["5.1"],"控制器拦截器":["5.2"],"异常过滤器":["5.2"],"而不仅仅是服务类":["5.3"],"提供者是":["5.3"],"nestjs":["5.3"],"应用程序中的核心概念之一":["5.3"],"它们将代码块标记为可注入的":["5.3"],"authservice":["5.4","22.5"],"jwtstrategy":["5.4"],"控制器":["5.4"],"authcontroller":["5.4"],"向外提供接口":["5.4"],"guards":["6.1"],"鉴权认证相关":["6.1"],"拦截器":["6.1"],"查询参数":["7.0"],"响应对象等":["7.0"],"载荷":["9.0"],"签名规则":["9.0"],"执行副作用":["12.2"],"b1":["12.2"],"这是分类b下的项目b1":["12.2"],"console":["12.4"],"log":["12.4"],"重新渲染":["12.4"],"reducertest":["12.5"],"number":["12.5"],"dispatchnumber":["12.5"],"initialstate":["12.5"],"与创建对象形式的存储不同":["14.1","15.1"],"针对每一个变量可以是响应式的":["14.1","15.1"],"通过原子派生的方式来适应复杂的开发场景":["14.1","15.1"],"它通过将原子状态进行派生":["15.3"],"组合成新的状态":["15.3"],"类似vue的computed":["15.3"],"所谓组件内状态":["15.3"],"其实就是内部使用了usestate":["15.3"],"text":["15.5"],"value":["15.5","15.6"],"div":["15.6","15.8","15.9","15.14"],"export":["15.6"],"onclick":["15.7","15.8","15.9"],"button":["15.8","15.9"],"addnumber":["15.9"],"组件b渲染":["15.10"],"p":["15.10"],"组件b":["15.10"],"这么做的目的":["15.11"],"防止无意义的渲染":["15.11"],"这样就不会触发更新了":["15.12"],"不受外部影响":["15.13"],"同时也不影响外部":["15.13"],"count":["15.14"],"setcount":["15.14"],"status":["15.14"],"style":["15.14"],"background":["15.14"],"pink":["15.14"],"black":["15.14"],"订阅":["16.1"],"监听store中的state变化":["16.1"],"增强器":["16.2"],"动作":["16.2"],"更加符合常理":["17.1"],"这样action行为会随着时间的推移积累到状态中":["17.2"],"if":["17.4"],"task":["17.4"],"else":["17.4"],"setstate":["17.5"],"usestate":["17.5"],"function":["17.5"],"usereducer可以帮助更好地处理不同字段的状态变化":["17.6"],"总之":["17.6"],"usereducer适用于需要更精细控制状态逻辑":["17.6"],"处理复杂状态变化":["17.6"],"instance":["22.1"],"constroller":["22.1"],"这个容器接手类的控制权":["22.2"],"从容器中解析已注册的依赖项并注入":["22.4"],"让所有的依赖项统一管理注册解耦了对象之间的强依赖关系":["22.4"]},{"1":["15.14"],"19":["5.2"],"123":["15.14"],"在上面的代码中":["1.0"],"我们将loggermiddleware中间件添加到了appmodule模块中":["1.0"],"并使用forroutes":["1.0"],"方法指定了该中间件适用于所有路由":["1.0"],"这样":["1.0"],"每次请求到达控制器之前":["1.0"],"都会先执行loggermiddleware中间件中的代码":["1.0"],"gethello":["1.1"],"string":["1.1"],"将authguard守卫添加到路由上":["1.1"],"并使用":["1.1"],"装饰器指定守卫":["1.1"],"这样每次请求到达控制器之前都会先执行authguard守卫中的代码":["1.1"],"以确保请求的合法性":["1.1"],"useclass":["1.2"],"appmodule":["1.2"],"管道的应用场景":["1.3"],"将做为参数传递给":["2.0"],"方法":["2.0"],"authcontroller":["2.0"],"authmodule":["2.0","5.4"],"constroctor":["3.0"],"直接注入":["3.0"],"传递泛型类型":["3.0"],"configtype会提供类型":["3.0"],"而不需要处理业务逻辑":["5.1"],"在service中":["5.1"],"可以编写业务逻辑和调用其他服务":["5.1"],"路由":["5.2"],"之后是控制器":["5.2"],"之后是全局":["5.2"],"服务器响应":["5.2"],"并提供与其它代码块之间的依赖关系":["5.3"],"当需要在组件或控制器中使用一个实例时":["5.3"],"会自动处理依赖关系并将实例提供给需要的组件或控制器":["5.3"],"exports":["5.4"],"export":["5.4","12.4","15.10","17.5"],"class":["5.4"],"interceptors":["6.1"],"处理http请求前后所执行的逻辑":["6.1"],"executioncontext只在当前请求有效":["7.0"],"不可以和其他请求共享":["7.0"],"返回token":["9.0"],"项目b2":["12.2"],"这是分类b下的项目b2":["12.2"],"alt":["12.2"],"text":["12.2"],"return":["12.4","15.5"],"button":["12.4","12.5","15.14"],"onclick":["12.4","12.5","15.14"],"点击":["12.4"],"default":["12.4","15.6","15.10"],"div":["12.5","15.5"],"add":["12.5","15.7","15.8","15.9","15.14"],"项目列表":["12.5"],"atom":["14.1","15.1"],"state变化":["15.3"],"触发更新渲染罢了":["15.3"],"有兴趣可以阅读手动实现recoil原理":["15.3"],"danger":["15.6"],"这样会阻塞渲染线程":["15.6"],"不建议这样做":["15.6"],"异步请求应该放在组件内部":["15.6"],"或者使用异步更新atom":["15.6"],"www":["15.9"],"abc":["15.9"],"com":["15.9"],"asynctest":["15.10"],"不会触发订阅事件":["15.12"],"即使大家共用同一个atom状态":["15.13"],"p":["15.14"],"x":["15.14"],"combinereducer":["16.1"],"将多个reducers合并成一个rootreducer":["16.1"],"reducer":["16.2"],"纯函数":["16.2"],"filter":["17.4"],"throw":["17.4"],"error":["17.4"],"未知":["17.4"],"使用中间件或副作用等情况下":["17.6"],"可以优于简单使用usestate来管理组件状态":["17.6"],"此时我们的constroller与service解耦":["22.1"],"具体调用的方法完全取决于外部依赖注入进来的方法":["22.1"],"可扩展性":["22.1"],"解耦":["22.1"],"可测试性":["22.1"],"controller":["22.5"]}]'},t={"0.0":{t:"<resume/>",p:"",l:"Resume/index.html",a:"resume"},"1.0":{t:"中间件",p:`::: info 存在意义
处理HTTP请求的函数，他可以在请求到达控制器之前/之后执行一些操作 他可以是全局的也可以是局部的
场景：身份验证，日志记录，错误处理
:::
::: details
中间 ...`,l:"articles/BackEnd/NestJs/Basic/Code/Concept.html",a:"中间件"},"1.1":{t:"守卫",p:`Guard 是一种用于保护路由的机制，他可以在请求到达控制器之前或者之后执行一些操作。守卫可以用于实现身份验证，权限控制，缓存等功能。在NestJs中收尾可以是全局的也可以是局部的。守卫路由
[[Ex ...`,l:"articles/BackEnd/NestJs/Basic/Code/Concept.html#守卫",a:"守卫"},"1.2":{t:"拦截器",p:`处理HTTP请求和响应的函数，在请求到达控制器之前之后执行一些操作。拦截器可以实现日志记录，错误处理，数据转换。在Nestjs中拦截器可以是全局的也可局部
@Injectable()
export c ...`,l:"articles/BackEnd/NestJs/Basic/Code/Concept.html#拦截器",a:"拦截器"},"1.3":{t:"管道",p:`管道是数据流入controller前进行的一波数据处理
其中数据处理包含了对数据的转换,验证。他可以在控制器之前或之后对数据进行预处理。然后将数据传递给控制器或下一个管道。
$$管道的主要目的是增强应 ...`,l:"articles/BackEnd/NestJs/Basic/Code/Concept.html#管道",a:"管道"},"2.0":{t:">注入基本数据",p:`因为普通数据服务不是Class，所以要使用@Inject来注入

@Module({
	providers:[
		{
			provide:'APP_NAME',
			useValue:'使用普通 ...`,l:"articles/BackEnd/NestJs/Basic/Code/Provider.html",a:"注入基本数据"},"3.0":{t:"> 案例，第三方发送短信服务。 根据不同配置使用不同的第三方运营商",p:`sms.serivce.ts
@Injectable()
export class AppController(){
	constructor(){
		private ali:aliService, ...`,l:"articles/BackEnd/NestJs/Basic/Code/env配置相关.html",a:"案例-第三方发送短信服务。-根据不同配置使用不同的第三方运营商"},"4.0":{t:"控制反转 IOC",p:`面向对象中的设计原则，用来减少计算机代码之前的耦合度。其根本思想是：”借助于第三方“ 实现具有依赖关系的对象之间的解耦

$$ 第三方举例：TS注解，或直接传递参数。总之控制权不在类中，而是由外部决定 ...`,l:"articles/BackEnd/NestJs/Basic/Code/设计模式模式.html",a:"控制反转-ioc"},"4.1":{t:"依赖注入 DI",p:`IOC 的具体实现，在类以外的地方提供服务。类内部调用的是该具体服务的抽象

	abstrct class Phone {
		playGame(name:string):string
	}
	cla ...`,l:"articles/BackEnd/NestJs/Basic/Code/设计模式模式.html#依赖注入-di",a:"依赖注入-di"},"5.0":{t:"- Nest 请求声明周期",p:`

[[Provider]]

动态Provider
asynProvider



Module

静态模块
动态模块
全局模块



[[env配置相关]]


`,l:"articles/BackEnd/NestJs/Basic/Module Contorller Service.html",a:"nest-请求声明周期"},"5.1":{t:"Module Controller Service的关系",p:`
Module 提供了一个模块化的方式来组织和管理您的应用程序的代码，同时还允许您使用依赖注入和模块之间的依赖关系来构建更加可扩展的应用程序。
$$ Module是Nestjs应用程序的基本构建块，每 ...`,l:"articles/BackEnd/NestJs/Basic/Module Contorller Service.html#module-controller-service的关系",a:"module-controller-service的关系"},"5.2":{t:"Nest 请求生命周期",p:`!img

1.  收到请求
2.  全局绑定的中间件
3.  模块绑定的中间件
4.  全局守卫
5.  控制层守卫
6.  路由守卫
7.  全局拦截器（控制器之前）
8.  控制器层拦截器 （控 ...`,l:"articles/BackEnd/NestJs/Basic/Module Contorller Service.html#nest-请求生命周期",a:"nest-请求生命周期"},"5.3":{t:"[[Provider]]",p:`提供服务,用于表示应用程序中可注入的任何东西。除了服务，Provider 还可以提供其他类型的对象，例如 Factory 工厂、配置对象、连接对象等。


提供者使用 @Injectable() 装饰 ...`,l:"articles/BackEnd/NestJs/Basic/Module Contorller Service.html#provider",a:"provider"},"5.4":{t:"Module",p:`模块是一个子程序，用于定义控制器，提供者或向其他模块开放提供者（开放模块的API）


默认情况下控制器，提供者在当前模块可用，即模块作用域
若果向其他模块提供服务可以将提供者定义在export属性中 ...`,l:"articles/BackEnd/NestJs/Basic/Module Contorller Service.html#module",a:"module"},"5.5":{t:"	",p:"",l:"articles/BackEnd/NestJs/Basic/Module Contorller Service.html#",a:""},"5.6":{t:"动态Module",p:"",l:"articles/BackEnd/NestJs/Basic/Module Contorller Service.html#动态module",a:"动态module"},"6.0":{t:"hi  我是Eagon,今天给大家分享Nest基础系列-Nestjs核心基础概念。 愿我们共同进步",p:"",l:"articles/BackEnd/NestJs/Basic/NestJs核心概念.html",a:"hi-我是eagon-今天给大家分享nest基础系列-nestjs核心基础概念。-愿我们共同进步"},"6.1":{t:"核心概念概览",p:`
模块 Modules 组合所有逻辑的地方,我理解为DI的Container
控制器 Controller处理请求
服务 Service 操作数据库以及处理所有逻辑的地方
管道 Pipes 核验请求的 ...`,l:"articles/BackEnd/NestJs/Basic/NestJs核心概念.html#核心概念概览",a:"核心概念概览"},"6.2":{t:" 重点1: NestJs 处理Https时的生命周期",p:"",l:"articles/BackEnd/NestJs/Basic/NestJs核心概念.html#重点1-nestjs-处理https时的生命周期",a:"重点1-nestjs-处理https时的生命周期"},"7.0":{t:">他代表了一个HTTP请求的执行上下文，提供了许多属性和方法，可用于在请求的生命周期内访问",p:`
ExecutionContext是在每个请求到达控制器之前被Nestjs封装产生的，他的请求是将请求的上下文，传递给控制器，拦截器，管道，守卫等各个部分。以便他们可以对请求进行处理和转换
当一个请求 ...`,l:"articles/BackEnd/NestJs/Basic/link/Execution Context 执行上下文.html",a:"他代表了一个http请求的执行上下文-提供了许多属性和方法-可用于在请求的生命周期内访问"},"8.0":{t:"# NestJs",p:"",l:"articles/BackEnd/NestJs/index.html",a:"nestjs"},"9.0":{t:"- register 接收账号密码argon2 hash 加密插入数据库",p:`
login   登录接收账号密码，argon2 verify对密码进行解密
解密符合，根据头信息，载荷, 签名规则 返回token

`,l:"articles/BackEnd/NestJs/jwt/流程.html",a:"register-接收账号密码argon2-hash-加密插入数据库"},"10.0":{t:"js",p:"",l:"articles/FontEnd/js/index.html",a:"js"},"11.0":{t:"# React Router",p:"",l:"articles/FontEnd/react/ReactRouter/index.html",a:"react-router"},"11.1":{t:"快速上手",p:"",l:"articles/FontEnd/react/ReactRouter/index.html#快速上手",a:"快速上手"},"11.2":{t:"原理分析",p:"",l:"articles/FontEnd/react/ReactRouter/index.html#原理分析",a:"原理分析"},"12.0":{t:"# React 速通",p:"",l:"articles/FontEnd/react/basic/index.html",a:"react-速通"},"12.1":{t:"Hooks",p:`Hooks
`,l:"articles/FontEnd/react/basic/index.html#hooks",a:"hooks"},"12.2":{t:"API分类",p:`
关键词： concurrent
&lt;table&gt;
&lt;tr&gt;
&lt;th&gt;使用范围&lt;/th&gt;
&lt;th&gt;Hooks&lt;/th&gt;
&lt;t ...`,l:"articles/FontEnd/react/basic/index.html#api分类",a:"api分类"},"12.3":{t:"数据更新驱动类",p:"",l:"articles/FontEnd/react/basic/index.html#数据更新驱动类",a:"数据更新驱动类"},"12.4":{t:"useState",p:`const [state, setState] = useState(initialState);
参数接收一个初始值，返回一个数组，数组的第一个元素是当前的state，第二个元素是更新state的函 ...`,l:"articles/FontEnd/react/basic/index.html#usestate",a:"usestate"},"12.5":{t:"useReducer",p:`对于拥有许多状态更新逻辑的组件来说，过于分散的事件处理程序可能会令人不知所措。对于这种情况，你可以将组件的所有状态更新(增删改查)逻辑整合到一个外部函数中，这个函数叫作 reducer。
reduce ...`,l:"articles/FontEnd/react/basic/index.html#usereducer",a:"usereducer"},"13.0":{t:"react",p:"",l:"articles/FontEnd/react/index.html",a:"react"},"14.0":{t:"# React 全局存储/状态管理",p:"",l:"articles/FontEnd/react/storage/index.html",a:"react-全局存储-状态管理"},"14.1":{t:"常见的状态管理模式",p:`
global：  全局式，也被称作单一数据源，将所有的数据放到一个大对象中，关键词：combineReducers();
multiple stores：  多数据源模式，将状态存放到多个数据源中， ...`,l:"articles/FontEnd/react/storage/index.html#常见的状态管理模式",a:"常见的状态管理模式"},"15.0":{t:"# Jotai",p:`引用来源：Ryun
`,l:"articles/FontEnd/react/storage/jotai/index.html",a:"jotai"},"15.1":{t:"常见的状态管理模式",p:`
global：  全局式，也被称作单一数据源，将所有的数据放到一个大对象中，关键词：combineReducers();
multiple stores：  多数据源模式，将状态存放到多个数据源中， ...`,l:"articles/FontEnd/react/storage/jotai/index.html#常见的状态管理模式",a:"常见的状态管理模式"},"15.2":{t:"Jotai  原子状态管理",p:"",l:"articles/FontEnd/react/storage/jotai/index.html#jotai-原子状态管理",a:"jotai-原子状态管理"},"15.3":{t:"原子式解决了什么问题",p:`reactHook 使State的拆分和逻辑共享变得更容易
但useState 和 useContext对于多个store仍需要维护多个Context Provider 因为当Context改变，所有 ...`,l:"articles/FontEnd/react/storage/jotai/index.html#原子式解决了什么问题",a:"原子式解决了什么问题"},"15.4":{t:"使用教程",p:"",l:"articles/FontEnd/react/storage/jotai/index.html#使用教程",a:"使用教程"},"15.5":{t:"1. 创建 atom  派生atom  使用 useAtom",p:`::: details View The Code
import { atom, useAtom } from &quot;jotai&quot;;
import { FC } from &quot; ...`,l:"articles/FontEnd/react/storage/jotai/index.html#_1-创建-atom-派生atom-使用-useatom",a:"_1-创建-atom-派生atom-使用-useatom"},"15.6":{t:"2. 异步派生",p:`::: details View The Code
import { atom, useAtom } from &quot;jotai&quot;;
import { FC } from &quot; ...`,l:"articles/FontEnd/react/storage/jotai/index.html#_2-异步派生",a:"_2-异步派生"},"15.7":{t:"3. 函数组件内更新方式",p:`::: details View The Code
  const ValueAtom = atom(1)
  const Text = ()=&gt;{
    const [value,setVa ...`,l:"articles/FontEnd/react/storage/jotai/index.html#_3-函数组件内更新方式",a:"_3-函数组件内更新方式"},"15.8":{t:"4. atom内更新方式",p:`::: details View The Code
  const ValueAtom = atom(1)
  const AddNumberAtom = atom(ge=&gt;ge(ValueAt ...`,l:"articles/FontEnd/react/storage/jotai/index.html#_4-atom内更新方式",a:"_4-atom内更新方式"},"15.9":{t:"5. 异步更新atom 区别于第二条异步获取，异步更新不会阻塞线程",p:`::: details View The Code
  const MockData = new Promise&lt;string&gt;((r) =&gt; {
    setTimeout(() ...`,l:"articles/FontEnd/react/storage/jotai/index.html#_5-异步更新atom-区别于第二条异步获取-异步更新不会阻塞线程",a:"_5-异步更新atom-区别于第二条异步获取-异步更新不会阻塞线程"},"15.10":{t:"6. 渲染问题",p:`:::   details View The Code

当我们点击add时，发现A和B都重新渲染了，但是问题来了，A为什么要重新渲染呀，A只是触发了更新操作，并不需要重新渲染呀？？？


这是因为， ...`,l:"articles/FontEnd/react/storage/jotai/index.html#_6-渲染问题",a:"_6-渲染问题"},"15.11":{t:"7. 解决渲染问题 useAtomValue、useSetAtom",p:`
如果有的组件只需要监听状态的变化值，而没有更新操作 请使用useAtomValue
如果仅更新操作，而无需渲染状态的组件，请使用 useSetAtom
这么做的目的：防止无意义的渲染

`,l:"articles/FontEnd/react/storage/jotai/index.html#_7-解决渲染问题-useatomvalue、usesetatom",a:"_7-解决渲染问题-useatomvalue、usesetatom"},"15.12":{t:"8. Provider",p:`
正常情况下，无需用Provider包裹组件
但如果需要控制某些组件的状态不发生更新，可以用Provider包裹
或者说，用Provider包裹的组件，状态是独立的，不受外部影响，同时也不影响外部，即 ...`,l:"articles/FontEnd/react/storage/jotai/index.html#_8-provider",a:"_8-provider"},"15.13":{t:"9.store",p:`
createStore,export出去,使用Jotai的Provider提供给App


其中，store中的状态，是全局的，任何组件都可以使用，但是，如果某个组件使用了Provider包裹，那么 ...`,l:"articles/FontEnd/react/storage/jotai/index.html#_9-store",a:"_9-store"},"15.14":{t:"实际使用",p:`::: code-group
import { createStore, atom } from &quot;jotai&quot;;

const myStore = createStore();
 ...`,l:"articles/FontEnd/react/storage/jotai/index.html#实际使用",a:"实际使用"},"16.0":{t:"# Redux",p:"",l:"articles/FontEnd/react/storage/redux/index.html",a:"redux"},"16.1":{t:"API介绍",p:`
reducer 纯函数，接收两个参数，一个是state，一个是action，返回一个新的state
createStore 创建一个 root 存放 state的根对象
dispatch 更新sto ...`,l:"articles/FontEnd/react/storage/redux/index.html#api介绍",a:"api介绍"},"16.2":{t:"摘要",p:`
middleware 中间件,中间件用于增强 dispatch 功能，返回一个增强后的 dispatch（比如 redux-thunk 使 action 可以为 function）
enhancer ...`,l:"articles/FontEnd/react/storage/redux/index.html#摘要",a:"摘要"},"17.0":{t:"# reducer",p:`
action + state  = new state

`,l:"articles/FontEnd/relevance/reducer.html",a:"reducer"},"17.1":{t:"与state的区别",p:"state是用户触发函数来执行具体的一步一步操作，reducer是把操作整合到一起，用户触发事件名进而执行相应的处理函数，例如：用户触发添加程序, 程序了解到事件名以后去reducer中找到对应的函数 ...",l:"articles/FontEnd/relevance/reducer.html#与state的区别",a:"与state的区别"},"17.2":{t:"命名原因",p:"reducer是根据reduce命名 ,它接收目前的结果和当前的值，然后返回下一个结果. React中的reducer也是这样的他们都接受 当前state 和触发的事件action ,然后返回新的st ...",l:"articles/FontEnd/relevance/reducer.html#命名原因",a:"命名原因"},"17.3":{t:" ",p:"",l:"articles/FontEnd/relevance/reducer.html#",a:""},"17.4":{t:"reduce实现reducer",p:`::: code-group
import tasksReducer from './tasksReducer.js';

let actions = [
  {type: 'added', id:  ...`,l:"articles/FontEnd/relevance/reducer.html#reduce实现reducer",a:"reduce实现reducer"},"17.5":{t:"实现useReducer",p:`通过useState保存当前状态＋action = new state
::: code-group
const App = ()=&gt;{
  const [state,dispatch] = u ...`,l:"articles/FontEnd/relevance/reducer.html#实现usereducer",a:"实现usereducer"},"17.6":{t:"实际用途",p:`useReducer是React提供的一个Hook，用于管理组件的状态（state）。它的实际用途包括：


状态复杂逻辑：当组件的状态逻辑较为复杂，涉及多个状态变化时，可以使用useReducer来 ...`,l:"articles/FontEnd/relevance/reducer.html#实际用途",a:"实际用途"},"18.0":{t:"# vue",p:"",l:"articles/FontEnd/vue/index.html",a:"vue"},"20.0":{t:"前置",p:"",l:"articles/algorithm/base/index.html",a:"前置"},"21.0":{t:"时间复杂度",p:"",l:"articles/algorithm/base/time.html",a:"时间复杂度"},"22.0":{t:"# Nest主要设计模式",p:"",l:"articles/designModel/IOCDI/index.html",a:"nest主要设计模式"},"22.1":{t:"Dependency Injection 依赖注入",p:`class UserService {
  getList(id) {
    // 获取用户的逻辑 
  }
}

class Controller {
  constructor() {
     ...`,l:"articles/designModel/IOCDI/index.html#dependency-injection-依赖注入",a:"dependency-injection-依赖注入"},"22.2":{t:"Inversion of Control  控制反转",p:`控制反转的本质就是降低耦合度，不再强依赖一些属性和方法。具体的实现方式是DI依赖注入
控制反转需要一个容器，这个容器接手类的控制权
`,l:"articles/designModel/IOCDI/index.html#inversion-of-control-控制反转",a:"inversion-of-control-控制反转"},"22.3":{t:"好处",p:`
解耦和模块化
更方便的依赖注入
配置集中管理

`,l:"articles/designModel/IOCDI/index.html#好处",a:"好处"},"22.4":{t:"如何控制反转",p:`控制反转需要的条件如下

需要一个管理容器  Container
容器需要拥有register方法用来管理容器的注册
容器需要有一个解析的方法 （从容器中解析已注册的依赖项并注入)
让所有的依赖项统一 ...`,l:"articles/designModel/IOCDI/index.html#如何控制反转",a:"如何控制反转"},"22.5":{t:"案例",p:`  abstract class Service {
    getList: () =&gt; void;
    putList: () =&gt; void;
  }

  class Cont ...`,l:"articles/designModel/IOCDI/index.html#案例",a:"案例"},"23.0":{t:"设计模式",p:"",l:"articles/designModel/index.html",a:"设计模式"},"24.0":{t:"<myIndex/>",p:"",l:"index.html",a:"myindex"},"25.0":{t:"# 记录和楠楠的日常生活",p:"",l:"nannan/index.html",a:"记录和楠楠的日常生活"},"26.0":{t:"# 我们的故事",p:"",l:"nannan/story/index.html",a:"我们的故事"},"27.0":{t:"<!-- ---",p:`layout :  false
layout: page
&lt;team/&gt; --&gt;
`,l:"team/index.html",a:""}},r={previewLength:100,buttonLabel:"搜索",placeholder:"情输入关键词",allow:[],ignore:[]},a={INDEX_DATA:e,PREVIEW_LOOKUP:t,Options:r};export{a as default};
