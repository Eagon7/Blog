const e={map:'[{"resume":["0.0"],"aop":["1.0"],"中间件":["1.1","2.0"],"全局中间件":["1.2"],"路由中间件":["1.3"],"路由守卫":["1.4"],"拦截器":["1.5","2.2"],"pipe":["1.6"],"exceptionfilter":["1.7","11.1"],"守卫":["2.1"],"管道":["2.3"],"注入基本数据":["3.0"],"案例":["4.0","45.5"],"控制反转":["5.0"],"依赖注入":["5.1"],"nest":["6.0","6.2"],"module":["6.1","6.4"],"provider":["6.3"],"动态module":["6.6"],"hi":["7.0"],"核心概念概览":["7.1"],"重点1":["7.2"],"他代表了一个http请求的执行上下文":["8.0"],"reflect":["9.0"],"装饰器总结":["10.0"],"optional":["10.1"],"global":["10.2"],"catch":["10.3"],"post":["10.4"],"setmetadata":["10.5"],"headers":["10.6"],"ip":["10.7"],"session":["10.8"],"hostparam":["10.9"],"req":["10.10"],"next":["10.11"],"redirect":["10.12"],"exception切换不同上下文":["11.0"],"guard等切换上下文":["11.2"],"为啥要多俩方法":["11.3"],"总结":["11.4","16.3","17.4","24.11"],"http数据传输方式":["12.0"],"urlparam":["12.1"],"form":["12.2","12.3"],"json":["12.4"],"nest实现基本的http请求":["12.5"],"nestjs":["13.0"],"register":["14.0"],"合并装饰器":["15.0"],"自定义装饰器":["15.1"],"全局module和生命周期":["16.0"],"全局模块":["16.1"],"生命周期lifecycle":["16.2"],"多种provider":["17.0"],"注册value值":["17.1"],"动态注册服务":["17.2"],"异步动态注册服务":["17.3"],"文件上传":["18.0"],"语法":["19.0"],"js":["20.0"],"项目列表":["21.0"],"高阶组件hoc":["21.1","22.0"],"两种不同的高阶组件":["22.1"],"属性代理":["22.2"],"反向继承":["22.3"],"编写hoc":["22.4"],"动态加载loading":["22.5"],"事件监控":["22.6"],"权限拦截":["22.7"],"hooks":["23.0","23.2"],"api分类":["23.1"],"useref":["23.3","39.0"],"数据更新驱动类":["23.4"],"usestate":["23.5"],"usereducer":["23.6"],"usecontext":["23.7"],"useimperativehandle":["23.8"],"react":["24.0","25.0","26.0","30.0","32.4","32.5","35.1","35.8","35.9"],"出现背景":["24.1","26.3"],"核心概念":["24.2"],"使用教程":["24.3","27.4"],"自动缓存和数据同步":["24.4"],"加载状态管理":["24.5"],"数据同步和预取":["24.6"],"自动缓存失效处理":["24.7"],"服务器状态更新":["24.8"],"更少的重复代码":["24.9"],"api":["24.10"],"快速上手":["25.1"],"原理分析":["25.2"],"核心api":["25.3"],"常见的状态管理模式":["26.1","27.1"],"flex":["26.2"],"架构特点":["26.4"],"jotai":["27.0","27.2"],"原子式解决了什么问题":["27.3"],"实际使用":["27.14"],"redux":["28.0"],"api介绍":["28.1"],"摘要":["28.2"],"context":["29.0","37.0"],"提供者provider用法":["29.1"],"消费者consumer用法":["29.2"],"生命周期":["31.0"],"useeffect":["31.1"],"uselayouteffect":["31.2"],"useinsertioneffect":["31.3"],"类组件生命周期在函数组件内使用effect替代方案":["31.4"],"渲染调优":["32.0"],"懒加载和异步渲染":["32.1"],"异步渲染":["32.2"],"懒加载":["32.3"],"props":["33.0","33.8"],"监听props改变":["33.1"],"render":["33.2","33.3"],"组合模式":["33.4"],"操作props":["33.5"],"混入":["33.6"],"抽离props":["33.7"],"demo":["33.9"],"ref":["34.0"],"获取ref的三种方式":["34.1"],"转发ref":["34.2"],"组合转发ref":["34.3"],"高阶组件转发":["34.4"],"组件通信":["34.5"],"函数组件数据缓存":["34.6"],"渲染控制":["35.0"],"usememo用法":["35.2"],"usememo原理":["35.3"],"purecomponent":["35.4"],"purecomponent原理":["35.5"],"purecomponent注意事项":["35.6"],"shouldcomponentupdate":["35.7"],"打破渲染限制的方法使memo和purecomponent失效":["35.10"],"控制渲染的场景":["35.11"],"reducer":["38.0"],"与state的区别":["38.1"],"命名原因":["38.2"],"reduce实现reducer":["38.4"],"实现usereducer":["38.5"],"实际用途":["38.6"],"base":["40.0"],"vue":["41.0"],"前置":["43.0"],"时间复杂度":["44.0"],"nest主要设计模式":["45.0"],"dependency":["45.1"],"inversion":["45.2"],"好处":["45.3"],"如何控制反转":["45.4"],"设计模式":["46.0"],"myindex":["47.0"],"记录和楠楠的日常生活":["48.0"],"我们的故事":["49.0"],"根据空格拆分字符串":["50.0"]},{"0":["27.14","28.1"],"1":["1.3","1.7","6.2","7.1","12.5","22.0","22.4","23.5","26.1","26.4","27.1","27.5","31.2","35.6","35.10","35.11","45.3","50.0"],"2":["6.2","22.4","27.6"],"3":["27.7","50.0"],"4":["27.8"],"5":["27.9"],"6":["27.10","29.2"],"7":["27.11"],"8":["27.12"],"9":["27.13"],"69":["50.0"],"123":["12.5"],"168":["50.0"],"192":["50.0"],"200":["50.0"],"48512":["50.0"],"后端架构一般都是mvc架构":["1.0"],"mvc是model":["1.0"],"view":["1.0","27.6","27.8","27.9","27.10","33.6","33.7","34.1","34.2","34.3","34.5"],"controller的简写":["1.0"],"请求一般会先发送到controller":["1.0"],"中间件是express的概念":["1.1"],"middleware":["1.2","28.2"],"ts":["1.2","1.4","1.5","1.7","4.0","9.0","10.8","10.9","10.12","11.1","11.2","11.3","12.5","15.1","17.1","17.2","23.3","23.5","27.14","31.1","38.4"],"main":["1.2"],"路由中间件首先要创建一个中间件类":["1.3"],"然后在路由上使用":["1.3"],"创建中间件类":["1.3"],"nest":["1.3","1.5","1.6","12.5","16.2","17.0"],"guard":["1.4","2.1","10.5","11.4"],"guard是路由守卫的意思":["1.4"],"可以用于在调用某个controller之前判断权限":["1.4"],"返回true或false来决定是否放行":["1.4"],"n":["1.4","1.7"],"g":["1.4","1.5","1.7"],"gu":["1.4"],"auth":["1.4"],"guards":["1.4"],"role":["1.4"],"no":["1.4","1.5","1.7"],"spec":["1.4","1.5","1.7"],"image":["1.4"],"code":["1.4","1.7","10.3","10.10","12.5","17.0","22.7","23.3","24.9","27.6","27.8","27.9","27.10","27.14","29.2","31.4","33.6","33.7","33.9","34.1","34.2","34.3","34.5","35.1","38.4","38.5","50.0"],"group":["1.4","1.7","10.3","10.10","12.5","17.0","22.7","23.3","24.9","27.14","29.2","31.4","33.9","34.5","35.1","38.4","38.5"],"interceptor":["1.5","11.0"],"拦截器是在controller之前之后执行的一段代码":["1.5"],"可以用来做一些通用的逻辑":["1.5"],"比如日志":["1.5"],"异常处理等等":["1.5"],"logger":["1.5"],"import":["1.5","11.1","15.1","24.9","27.6","27.14","32.4","38.4"],"callhandler":["1.5"],"executioncontext":["1.5","11.0"],"injectable":["1.5","1.7","3.0","4.0","9.0","11.2"],"nestinterceptor":["1.5"],"from":["1.5","11.1","24.9","27.14","38.4"],"nestjs":["1.5","7.2"],"common":["1.5"],"observable":["1.5"],"tap":["1.5"],"pipe是管道的意思":["1.6"],"用来对参数做校验和转换":["1.6"],"除了路由的权限控制":["1.6"],"目标":["1.6"],"controller":["1.6","6.1","9.0","10.9","12.5","16.2"],"之前之后的处理这些都是通用逻辑外":["1.6"],"对参数的处理也是一个通用的逻辑":["1.6"],"所以":["1.6"],"也抽出了对应的切面":["1.6"],"也就是":["1.6"],"可以对抛出的异常做处理":["1.7"],"返回对应的响应":["1.7"],"创建一个filter":["1.7"],"filter":["1.7"],"test":["1.7"],"flat":["1.7"],"validate":["1.7"],"pipe":["1.7"],"export":["1.7","3.0","4.0","11.1","11.2","22.5","22.7","24.9","27.14","34.1"],"class":["1.7","3.0","4.0","10.5","11.1","11.2","22.3","22.5","34.1","34.3","35.4","35.6","35.7","45.1","45.5"],"validatepipe":["1.7"],"implements":["1.7","11.1"],"pipetransform":["1.7"],"transform":["1.7"],"value":["1.7"],"any":["1.7"],"metadata":["1.7"],"argumentmetadata":["1.7"],"if":["1.7"],"info":["2.0","23.8","32.2"],"存在意义":["2.0"],"处理http请求的函数":["2.0"],"他可以在请求到达控制器之前":["2.0"],"之后执行一些操作":["2.0"],"他可以是全局的也可以是局部的":["2.0"],"场景":["2.0","23.3"],"身份验证":["2.0"],"日志记录":["2.0"],"是一种用于保护路由的机制":["2.1"],"他可以在请求到达控制器之前或者之后执行一些操作":["2.1"],"守卫可以用于实现身份验证":["2.1"],"权限控制":["2.1"],"缓存等功能":["2.1"],"在nestjs中收尾可以是全局的也可以是局部的":["2.1"],"守卫路由":["2.1"],"execution":["2.1"],"context":["2.1","29.2"],"处理http请求和响应的函数":["2.2"],"在请求到达控制器之前之后执行一些操作":["2.2"],"拦截器可以实现日志记录":["2.2"],"错误处理":["2.2"],"数据转换":["2.2"],"在nestjs中拦截器可以是全局的也可局部":["2.2"],"管道是数据流入controller前进行的一波数据处理":["2.3"],"因为普通数据服务不是class":["3.0"],"所以要使用":["3.0"],"inject来注入":["3.0"],"typescript":["3.0","4.0","27.6","45.1","45.5"],"module":["3.0","9.0","16.2","17.2"],"providers":["3.0"],"provide":["3.0"],"app":["3.0","24.9","38.5"],"name":["3.0","12.5","25.3","33.4","35.4"],"usevalue":["3.0"],"使用普通值":["3.0"],"authservice":["3.0"],"第三方发送短信服务":["4.0"],"根据不同配置使用不同的第三方运营商":["4.0"],"sms":["4.0"],"serivce":["4.0"],"appcontroller":["4.0"],"constructor":["4.0"],"private":["4.0"],"ali":["4.0"],"aliservice":["4.0"],"tencent":["4.0"],"ioc":["5.0","5.1"],"di":["5.1"],"的具体实现":["5.1"],"请求声明周期":["6.0"],"service的关系":["6.1"],"提供了一个模块化的方式来组织和管理您的应用程序的代码":["6.1"],"请求生命周期":["6.2"],"img":["6.2"],"java":["6.2"],"收到请求":["6.2"],"提供服务":["6.3"],"用于表示应用程序中可注入的任何东西":["6.3"],"除了服务":["6.3"],"还可以提供其他类型的对象":["6.3"],"模块是一个子程序":["6.4"],"用于定义控制器":["6.4"],"提供者或向其他模块开放提供者":["6.4"],"开放模块的api":["6.4"],"默认情况下控制器":["6.4"],"提供者在当前模块可用":["6.4"],"我是eagon":["7.0"],"模块":["7.1"],"modules":["7.1"],"提供了许多属性和方法":["8.0"],"可用于在请求的生命周期内访问":["8.0"],"definemetadata":["9.0"],"tip":["9.0","16.3","17.4","18.0"],"nest中使用的是reflect":["9.0"],"definemetadata来实现":["9.0"],"get等装饰器的功能":["9.0"],"它的作用是在类上定义元数据":["9.0"],"use":["9.0"],"如果设置了propertykey":["9.0"],"还可以再具体的属性上定义元数据":["9.0"],"单独为某个属性设置元数据":["9.0"],"metadatakey":["9.0"],"使provider为可选":["10.1"],"当controller需要注入一个provider":["10.1"],"如果这个provider不存在的话":["10.1"],"使provider全局可用":["10.2"],"当一个module被设置为":["10.2"],"exceptionfilter":["10.3"],"是处理抛出的未捕获异常的":["10.3"],"通过":["10.3","10.6","10.7","10.8","12.5"],"来指定处理的异常":["10.3"],"如果是post请求":["10.4"],"可以使用":["10.4"],"body获取到请求体":["10.4"],"我们一般用":["10.4"],"dto":["10.4"],"handle":["10.5"],"和":["10.5","11.0","27.3","31.2","33.9","35.4"],"可以通过":["10.5","22.4"],"制定元信息数据":["10.5"],"提供给守卫":["10.5"],"拦截器等使用":["10.5"],"然后在":["10.5"],"todo":["10.8"],"details":["10.8","23.3","23.5","27.6","27.7","27.8","27.9","27.10","33.6","33.7","34.1","34.2","34.3","34.5","35.2","35.4"],"session拿到session":["10.8"],"get":["10.8","10.12","12.5","50.0"],"用于取域名部分的参数":["10.9"],"除了可以制定具体path生效外":["10.9"],"还可以指定host":["10.9"],"response":["10.10"],"直接注入request":["10.10"],"response属性":["10.10"],"前面取的是request属性":["10.10"],"当然也可以注入request对象":["10.10"],"除了注入":["10.11"],"res不会返回响应外":["10.11"],"注入":["10.11"],"next也不会":["10.11"],"当你有两个handler来处理同一个路由的时候":["10.11"],"重定向":["10.12"],"nestjs支持":["11.0"],"http服务":["11.0"],"websocket服务":["11.0"],"tcp通信服务":["11.0"],"不同类型的服务在guard":["11.0"],"等取到的功能不同":["11.0"],"导致无法复用":["11.0"],"argumenthost":["11.0"],"取到上下文和参数":["11.0"],"参数":["11.1"],"exceptions":["11.1"],"argumentshost":["11.1"],"切换不同上下文":["11.1"],"aaaexception":["11.1"],"aaa":["11.1"],"exception":["11.1","11.4"],"catch":["11.1"],"myexceptionfilter":["11.1"],"t":["11.1"],"getclass":["11.3"],"gethandler":["11.3"],"比如守卫验证权限使":["11.3"],"需要获取目标方法的元数据":["11.3"],"就可以通过":["11.3"],"方法获取到目标方法的元数据":["11.3"],"然后比对决定是否放行":["11.3"],"为了让filter":["11.4"],"支持http":["11.4"],"ws":["11.4"],"url":["12.0"],"query":["12.1","12.5","24.0"],"都属于get路径传参":["12.1"],"tsx":["12.1","24.9","50.0"],"params":["12.1"],"router1":["12.1","12.5"],"urlencoded":["12.2","12.4"],"直接用表单提交数据":["12.2"],"提交的就是这种":["12.2"],"他和query的区别就是把查询的query放在了body里":["12.2"],"然后指定下":["12.2"],"content":["12.2","22.5","50.0"],"type":["12.2","38.4","50.0"],"是":["12.2","32.2"],"application":["12.2"],"data":["12.3","24.10"],"不再是通过":["12.3"],"分隔数据":["12.3"],"form":["12.4","33.9","34.3"],"param":["12.5"],"http":["12.5","50.0"],"id":["12.5","45.1"],"router":["12.5","25.0"],"在":["12.5","23.8"],"里":["12.5"],"装饰器来取":["12.5"],"find":["12.5"],"findall":["12.5"],"string":["12.5"],"接收账号密码argon2":["14.0"],"装饰器太多了":["15.0"],"有时候我们需要合并装饰器":["15.0"],"这样就可以减少代码量":["15.0"],"模块导出":["16.0"],"provider":["16.0","16.2","27.12","29.0","29.1","29.2"],"注意":["16.1"],"全局模块不推荐经常使用":["16.1"],"在启动的时候":["16.2"],"会递归解析":["16.2"],"依赖":["16.2"],"扫描其中的":["16.2"],"注入它的依赖":["16.2"],"模块可以":["16.3"],"实现了ioc":["17.0"],"从main文件臊面":["17.0"],"分析module引用及依赖中的关系":["17.0"],"自动把provider注入到目标对象":["17.0"],"imports":["17.2"],"当需要异步获取provider时":["17.3"],"可以使用usefactory的async版本":["17.3"],"例如":["17.3"],"一般情况provider通过":["17.4"],"injectable声明":["17.4"],"总结":["22.0"],"强化":["22.0","22.4"],"props":["22.0","22.4","23.8","33.3","33.6","35.4","35.9"],"常用的高阶组件有":["22.1"],"就是用组件包裹一层代理组件":["22.2"],"在代理组件上":["22.2"],"可以做一些":["22.2"],"对源组件的强化操作":["22.2"],"这里注意属性代理返回的是一个新组件":["22.2"],"被包裹的原始组件":["22.2"],"将在新的组件里被挂载":["22.2"],"jsx":["22.2","22.3","22.5","22.6","22.7","29.1","29.2","31.3","31.4","33.2","33.3","33.4","33.6","33.7","33.8","33.9","34.1","34.2","34.3","34.5","35.1","35.2","35.4","35.6","35.7"],"反向继承和属性代理有一定的区别":["22.3"],"在于包装后的组件继承了原始组件本身":["22.3"],"所以此时无须再去挂载业务组件":["22.3"],"index":["22.3","22.7","34.3","35.6","35.7","38.4"],"什么时候使用hoc":["22.4"],"强化props":["22.4"],"就是在原始组件的":["22.4"],"基础上":["22.4"],"加入一些其他的":["22.4"],"强化原始组件功能":["22.4"],"控制渲染":["22.4"],"hoc":["22.4","22.6","34.4"],"反向继承模式":["22.4"],"super":["22.4"],"default":["22.5","22.7","24.9","34.1"],"function":["22.5","22.6","22.7","24.9","35.1"],"dynamichoc":["22.5"],"loadrouter":["22.5"],"return":["22.5","31.1","34.3","35.1"],"extends":["22.5","34.1","34.3","35.4","35.7"],"react":["22.5","22.7","23.8","24.9","29.2","31.0","31.3","31.4","32.2","34.3","35.4","35.7"],"component":["22.5","34.1","34.3","35.7"],"不一定非要对组件本身做些什么":["22.6"],"也可以单纯增加一些事件监听":["22.6"],"错误监控":["22.6"],"以下代码hoc":["22.6"],"只对组件内的点击事件做一个监听效果":["22.6"],"clickhoc":["22.6"],"通过context传递权限":["22.7"],"const":["22.7","23.5","24.9","27.14","29.1","35.2","38.5","50.0"],"permission":["22.7"],"createcontext":["22.7"],"关键词":["23.1"],"concurrent":["23.1"],"table":["23.1"],"tr":["23.1"],"th":["23.1"],"使用范围":["23.1"],"hooks":["23.1"],"稳定引用":["23.3"],"获取dom节点":["23.3"],"获取上一次的值":["23.3"],"闭包":["23.3"],"异步访问到旧变量的问题":["23.3"],"典型的闭包循环案例":["23.3"],"每次循环调用settimeout的时候都会保存当前的作用域":["23.3"],"state":["23.5","34.6","35.4","35.7","38.5","38.6"],"setstate":["23.5"],"initialstate":["23.5"],"参数接收一个初始值":["23.5"],"返回一个数组":["23.5"],"数组的第一个元素是当前的state":["23.5"],"第二个元素是更新state的函数":["23.5"],"注意事项":["23.5"],"对于拥有许多状态更新逻辑的组件来说":["23.6"],"过于分散的事件处理程序可能会令人不知所措":["23.6"],"对于这种情况":["23.6"],"你可以将组件的所有状态更新":["23.6"],"增删改查":["23.6"],"逻辑整合到一个外部函数中":["23.6"],"这个函数叫作":["23.6"],"reducer":["23.6","28.1"],"reducer是弥补usestate在逻辑复杂情况下的缺陷":["23.6"],"它分为三个步骤":["23.6"],"作用":["23.7"],"解决了什么问题":["23.8"],"子组件通过ref抛出方法供父组件调用":["23.8"],"react函数":["23.8"],"组件":["23.8","33.9"],"父组件需要直接访问子组件的实例方法或属性的问题":["23.8"],"中":["23.8","34.6"],"父组件通常通过":["23.8"],"向子组件传递数据和回调函数来实现组件之间的通信":["23.8"],"这种方式可以确保数据流的单向性":["23.8"],"解决问题":["24.1"],"灵魂拷问q":["24.1"],"为什么用axios不可以":["24.1"],"为什么需要出现react":["24.1"],"querya":["24.1"],"尽管可以使用普通的":["24.1"],"axios":["24.1"],"解决普通请求代码重复":["24.2"],"befor":["24.9"],"as":["24.9"],"存储":["24.9"],"后端返回数据":["24.9"],"zen":["24.9"],"setzen":["24.9"],"usestate":["24.9"],"加载状态":["24.9"],"isloading":["24.9","24.10"],"setisloading":["24.9"],"false":["24.9"],"是否请求成功":["24.9"],"iserror":["24.9"],"setiserror":["24.9"],"apiname":["24.10"],"are":["24.10"],"查询返回的数据":["24.10"],"表示查询是否正在加载中":["24.10"],"后端概念":["25.0"],"effect":["25.3","31.4"],"demo":["25.3"],"link":["25.3"],"普通链接":["25.3"],"全局存储":["26.0"],"global":["26.1","27.1"],"全局式":["26.1","27.1"],"架构":["26.2"],"解决痛点":["26.3"],"flux架构解决前端应用程序中状态管理和数据流动的复杂性问题":["26.3"],"在传统的mvc":["26.3"],"详细介绍":["26.4"],"flux架构通过引入单向数据流的概念":["26.4"],"将数据的流动变得可控和可预测":["26.4"],"它明确了数据流动的路径":["26.4"],"并将状态的修改限制在特定的流程中":["26.4"],"这样做的好处包括":["26.4"],"易于追踪和调试":["26.4"],"由于数据流是单向的":["26.4"],"引用来源":["27.0"],"原子状态管理":["27.2"],"reacthook":["27.3"],"使state的":["27.3"],"拆分":["27.3"],"创建":["27.5"],"atom":["27.5","27.14"],"派生atom":["27.5"],"使用":["27.5","35.7"],"useatom":["27.5"],"异步派生":["27.6"],"the":["27.6","27.8","27.9","27.10","33.6","33.7","34.1","34.2","34.3","34.5"],"函数组件内更新方式":["27.7"],"atom内更新方式":["27.8"],"异步更新atom":["27.9"],"区别于第二条异步获取":["27.9"],"异步更新不会阻塞线程":["27.9"],"渲染问题":["27.10"],"当我们点击add时":["27.10"],"发现a和b都重新渲染了":["27.10"],"但是问题来了":["27.10"],"a为什么要重新渲染呀":["27.10"],"a只是触发了更新操作":["27.10"],"store":["27.13","27.14"],"createstore":["27.14"],"jotai":["27.14"],"mystore":["27.14"],"countatom":["27.14"],"纯函数":["28.1"],"中间件":["28.2"],"consumer":["29.0"],"themeprovider":["29.1"],"themecontext":["29.1"],"对于新版本想要获取":["29.2"],"的消费者":["29.2"],"提供了3种形式":["29.2"],"①":["29.2","33.2"],"类组件之contexttype":["29.2"],"方式":["29.2"],"v16":["29.2"],"提供了":["29.2"],"contexttype":["29.2"],"静态属性":["29.2"],"用来获取上面":["29.2"],"destory":["31.1"],"useeffect":["31.2","31.3","31.4","33.1"],"不同的地方是采用了同步执行":["31.2"],"在介绍":["31.3"],"用途之前":["31.3"],"先看一下":["31.3"],"的执行时机":["31.3"],"console":["31.3","35.1"],"log":["31.3","35.1"],"执行":["31.3"],"模块渲染后":["31.4"],"componentdidmount":["31.4"],"请求数据":["31.4"],"事件监听":["31.4"],"操纵dom":["31.4"],"切记":["31.4"],"dep":["31.4"],"这里要记住":["31.4"],"这样当前":["31.4"],"没有任何依赖项":["31.4"],"也就只有初始化执行一次":["31.4"],"模块卸载前":["31.4"],"componentwillunmount":["31.4"],"suspense":["32.2"],"悬念":["32.2"],"提出的一种同步的代码来实现异步操作的方案":["32.2"],"suspense可以让组件":["32.2"],"动态加载":["32.3"],"lazy":["32.4"],"接受一个函数":["32.4"],"这个函数需要动态调用":["32.4"],"它必须返回一个":["32.4"],"promise":["32.4"],"该":["32.4"],"lazy和suspense实现动态加载原理":["32.5"],"函数组件中可以用":["33.1"],"children":["33.2","33.3","33.4","34.1","35.1","35.4"],"模式":["33.2","33.3"],"container":["33.3","33.4"],"containerprops":["33.3","33.4"],"如果":["33.4"],"的":["33.4"],"既有函数也有组件":["33.4"],"这种情况应该怎么处理呢":["33.4"],"haha":["33.4"],"首先在":["33.4"],"抽象props":["33.5"],"的显式注入和隐式注入":["33.8"],"显式注入":["33.8"],"功能":["33.9"],"用于表单状态管理的":["33.9"],"formitem":["33.9"],"用于管理表单状态":["33.9"],"用于管理":["33.9"],"input":["33.9"],"输入框组件":["33.9"],"编写的组件能够实现的功能是":["33.9"],"①form":["33.9"],"组件可以被":["33.9"],"ref":["33.9","34.4","34.5"],"获取实例":["33.9"],"然后可以调用实例方法":["33.9"],"submitform":["33.9"],"获取表单内容":["33.9"],"用于提交表单":["33.9"],"ref是一个字符串":["34.1"],"类组件":["34.1"],"render":["34.1","34.3","34.6","35.1"],"div":["34.1","34.3","35.1"],"hello":["34.1"],"world":["34.1"],"跨层级获取ref":["34.2"],"如果我想在父组件":["34.2"],"获取":["34.2"],"孙":["34.2"],"子":["34.2"],"组件的实例":["34.2"],"通过回调函数将子组件的ref作为参数":["34.2"],"表单组件":["34.3"],"如果通过高阶组件包裹一个原始类组件":["34.4"],"就会产生一个问题":["34.4"],"如果高阶组件":["34.4"],"没有处理":["34.4"],"那么由于高阶组件本身会返回一个新组件":["34.4"],"所以当使用":["34.4"],"包装后组件的时候":["34.4"],"标记的":["34.4"],"类组件通信":["34.5"],"因为类组件有实例":["34.5"],"所以我们可以直接获取实例然后调用实例方法来操作":["34.5"],"函数组件通信":["34.5"],"对于函数组件":["34.5"],"本身是没有实例的":["34.5"],"所以我们要借用forwardref":["34.5"],"使函数组件可以接收ref":["34.5"],"useimperativehandle":["34.5"],"一方面第一个参数接受父组件传递的":["34.5"],"对象":["34.5","35.1"],"另一方面第二个参数是一个函数":["34.5"],"函数返回值":["34.5"],"作为":["34.5"],"对象获取的内容":["34.5"],"向传下来的ref传递方法":["34.5"],"forwardref":["34.5"],"函数组件每一次":["34.6"],"函数上下文会重新执行":["34.6"],"那么有一种情况就是":["34.6"],"在执行一些事件方法改变数据或者保存新数据的时候":["34.6"],"有没有必要更新视图":["34.6"],"有没有必要把数据放到":["34.6"],"如果视图层更新不依赖想要改变的数据":["34.6"],"那么":["34.6"],"改变带来的更新效果就是多余的":["34.6"],"几种控制":["35.1"],"方法":["35.1"],"第一种就是从父组件直接隔断子组件的渲染":["35.1"],"经典的就是":["35.1"],"memo":["35.1","35.8","35.9"],"缓存":["35.1"],"element":["35.1"],"父组件":["35.1"],"子组件有没有必要跟着父组件一起":["35.1"],"如果没有必要":["35.1"],"则就需要阻断更新":["35.1"],"导致不必要更新的demo":["35.1"],"子组件":["35.1"],"number":["35.1"],"子组件渲染":["35.1"],"let":["35.1","38.4"],"us":["35.1"],"learn":["35.1"],"cachesomething":["35.2"],"usememo":["35.2","35.3"],"会记录上一次执行":["35.3"],"create":["35.3"],"的返回值":["35.3"],"并把它绑定在函数组件对应的":["35.3"],"fiber":["35.3"],"对象上":["35.3"],"只要组件不销毁":["35.3"],"缓存值就一直存在":["35.3"],"纯组件是一种发自组件本身的渲染优化策略":["35.4"],"当开发类组件选择了继承":["35.4"],"就意味这要遵循其渲染规则":["35.4"],"规则就是浅比较":["35.4"],"是否相等":["35.4"],"基本使用":["35.4"],"纯组件本身":["35.4"],"purecomponentprototype有一个prototype属性":["35.5"],"ispurereactcomponent":["35.5"],"这个属性是一个布尔值":["35.5"],"用来标识当前组件是否是纯组件":["35.5"],"如果是纯组件":["35.5"],"那么在更新时":["35.5"],"会先进行浅比较":["35.5"],"如果相等":["35.5"],"就不会进行更新":["35.5"],"如果不相等":["35.5"],"才会进行更新":["35.5"],"这个属性在更新组件":["35.5"],"updateclassinstance":["35.5"],"purecomponent可以让组件自发的做一层性能上的调优":["35.6"],"但是父组件给是purecomponent的子组件绑定事件要小心":["35.6"],"避免两种情况":["35.6"],"避免使用箭头函数":["35.6"],"不要给是purecomponent子组件绑定箭头函数":["35.6"],"因为父组件每一次render如果是箭头函数绑定的话":["35.6"],"都会重新声场一个箭头函数":["35.6"],"purecomponent的浅比较就会失效":["35.6"],"参数函数指针改变":["35.6"],"导致子组件每一次都会重新渲染":["35.6"],"有的时候把控制渲染交给react组件本身处理靠不住":["35.7"],"那么我们便可以自定义渲染方案决定组建是否更新":["35.7"],"memo的特点":["35.9"],"当二个参数":["35.9"],"compare":["35.9"],"不存在时":["35.9"],"会用浅比较原则处理":["35.9"],"相当于仅比较":["35.9"],"版本的":["35.9"],"purecomponent":["35.9"],"同样适合类组件和函数组件":["35.9"],"大屏展示组件数据量大":["35.11"],"渲染耗时长":["35.11"],"可以使用react":["35.11"],"action":["38.0","38.5"],"state是用户触发函数来执行具体的一步一步操作":["38.1"],"reducer是根据reduce命名":["38.2"],"js":["38.4","38.5"],"tasksreducer":["38.4"],"actions":["38.4"],"added":["38.4"],"通过usestate保存当前状态":["38.5"],"new":["38.5"],"usereducer是react提供的一个hook":["38.6"],"用于管理组件的状态":["38.6"],"injection":["45.1"],"依赖注入":["45.1"],"userservice":["45.1"],"getlist":["45.1","45.5"],"获取用户的逻辑":["45.1"],"adminservice":["45.1"],"of":["45.2"],"控制反转需要的条件如下":["45.4"],"abstract":["45.5"],"service":["45.5"],"void":["45.5"],"putlist":["45.5"],"str":["50.0"],"remote":["50.0"],"addr":["50.0"],"status":["50.0"],"method":["50.0"],"proto":["50.0"],"layout":["51.0"]},{"0":["10.9","10.10","23.3","35.1","35.7","50.0"],"1":["16.2","23.6","27.8","31.1","34.6","35.1","35.4","38.4","45.4"],"2":["7.1","22.0","23.5","23.6","26.4","34.6","35.6","35.11","38.4"],"3":["6.2","23.6","26.4"],"4":["6.2"],"5":["6.2","23.1","50.0"],"10":["23.3","50.0"],"11":["50.0"],"14":["50.0"],"18":["35.4"],"123":["12.1"],"200":["24.9"],"605":["50.0"],"789":["12.1"],"9226":["50.0"],"然后由它调用model层的service来完成业务逻辑":["1.0"],"最后返回view":["1.0"],"tip":["1.0","33.5","34.6"],"什么是aop":["1.0"],"aspect":["1.0"],"nest底层是express":["1.1"],"async":["1.2","24.9"],"function":["1.2","22.2","29.1","31.4","32.2","33.3","33.6","33.7","34.2","35.5","35.9"],"bootstrap":["1.2"],"const":["1.2","1.5","4.0","22.4","22.6","27.6","27.8","27.9","29.0","29.2","33.4","34.2","34.3","35.4"],"app":["1.2"],"generate":["1.3"],"middleware":["1.3"],"logger":["1.3"],"no":["1.3","1.6","2.1"],"spec":["1.3","1.6","2.1"],"flat":["1.3","1.6"],"roleguard":["1.4"],"守卫要实现canactivate接口":["1.4"],"可以从参数context中获取请求信息":["1.4"],"然后做一些权限验证":["1.4"],"返回true或false":["1.4"],"injectable":["1.4","1.6","2.1","2.2","11.3"],"export":["1.4","1.5","2.1","2.2","10.3","10.4","11.0","29.1","32.4","35.1","35.6"],"class":["1.4","1.5","2.2","10.3","10.4","11.0","22.2","29.2","34.5","35.1"],"implements":["1.4","1.5","2.2","10.3","11.2"],"canactivate":["1.4","11.2","11.3"],"context":["1.4","1.5","11.2"],"rxjs":["1.5"],"timeinterceptor":["1.5"],"intercept":["1.5"],"next":["1.5"],"any":["1.5","45.5"],"starttime":["1.5"],"date":["1.5"],"now":["1.5"],"return":["1.5","1.7","12.5","22.2","22.3","22.6","31.4","33.6","34.2","35.4","38.5"],"handle":["1.5"],"pipe":["1.5"],"console":["1.5","10.8","11.1","12.5","27.14","33.6","33.7","34.1","34.2","35.4","35.9"],"g":["1.6","2.1"],"validate":["1.6"],"ts":["1.6","10.1","10.3","10.4","10.5","10.6","10.10","10.11","11.0","15.0","17.0","17.3"],"import":["1.6","10.5","11.3","15.0","27.5","33.9","34.5","35.9"],"argumentmetadata":["1.6"],"pipetransform":["1.6"],"from":["1.6","10.5","11.3","27.6","33.9","34.5","35.9"],"nestjs":["1.6","10.5","11.3","18.0"],"common":["1.6","11.3"],"number":["1.7","12.5","35.4"],"isnan":["1.7"],"parseint":["1.7"],"此时pipe验证参数失败":["1.7"],"抛出异常错误被exceptionfilter接收":["1.7"],"参数传递给exception":["1.7"],"throw":["1.7"],"new":["1.7","27.9","45.1"],"badrequestexception":["1.7"],"我想要的是number类型":["1.7"],"pipe抛出异常进入异常过滤器":["1.7"],"catch":["1.7"],"testfilter":["1.7"],"exception":["1.7"],"错误处理":["2.0"],"details":["2.0","27.5","33.4"],"中间件可以执行以下任务":["2.0"],"执行任何代码操作":["2.0"],"对请求对象进行更改":["2.0"],"结束当前请求生命周期":["2.0"],"调用下一个中间件函数":["2.0"],"如果当前中间件没有":["2.0"],"手动结束生命周期":["2.0"],"执行上下文":["2.1"],"typescript":["2.1","2.2","5.1","27.5","27.7","27.8","27.9"],"n":["2.1"],"gu":["2.1"],"xxx":["2.1"],"logginginterceptor":["2.2"],"nestinterceptor":["2.2"],"其中数据处理包含了对数据的转换":["2.3"],"constractor":["3.0"],"inject":["3.0","4.0"],"private":["3.0","45.5"],"appname":["3.0"],"注册类":["3.0"],"使用类将提供者注册到服务是最常用的方式":["3.0"],"autherservice":["3.0"],"以上是简写形式":["3.0"],"完整写法应该如下":["3.0"],"tencentservices":["4.0"],"smsservice":["4.0"],"base":["4.0"],"key":["4.0","9.0","33.9","45.5"],"baseconfig":["4.0"],"configtype":["4.0"],"typeof":["4.0"],"getsmsservice":["4.0"],"type":["4.0"],"string":["4.0","27.9","45.5"],"面向对象中的设计原则":["5.0"],"用来减少计算机代码之前的耦合度":["5.0"],"在类以外的地方提供服务":["5.1"],"类内部调用的是该具体服务的抽象":["5.1"],"provider":["6.0"],"同时还允许您使用依赖注入和模块之间的依赖关系来构建更加可扩展的应用程序":["6.1"],"module是nestjs应用程序的基本构建块":["6.1"],"每个模块都有一个独立的作用域":["6.1"],"其中包含一组相关的controller":["6.1"],"全局绑定的中间件":["6.2"],"模块绑定的中间件":["6.2"],"全局守卫":["6.2"],"控制层守卫":["6.2"],"例如":["6.3"],"factory":["6.3"],"工厂":["6.3"],"配置对象":["6.3"],"连接对象等":["6.3"],"提供者使用":["6.3"],"即模块作用域":["6.4"],"若果向其他模块提供服务可以将提供者定义在export属性中":["6.4"],"其他模块需要再imports属性中引入当前模块":["6.4"],"模块是":["6.4"],"设计模式模式":["6.4"],"的":["6.4","9.0","10.4","32.4"],"多个模块共享当前模块实例":["6.4"],"今天给大家分享nest基础系列":["7.0"],"组合所有逻辑的地方":["7.1"],"我理解为di的container":["7.1"],"控制器":["7.1"],"处理https时的生命周期":["7.2"],"executioncontext是在每个请求到达控制器之前被nestjs封装产生的":["8.0"],"他的请求是将请求的上下文":["8.0"],"metadatavalue":["9.0"],"target":["9.0"],"propertykey":["9.0"],"getmetadata":["9.0"],"元数据存放在哪里":["9.0"],"存在类或者对象上呀":["9.0"],"如果给类或者类的静态属性添加元数据":["9.0"],"那就保存在类上":["9.0"],"如果给实例属性添加元数据":["9.0"],"那就保存在对象上":["9.0"],"用类似":["9.0"],"metadata":["9.0"],"那么会报错":["10.1"],"把它设置为可选的会避免这个问题":["10.1"],"global时":["10.2"],"export属性全局可用":["10.2"],"httpexception":["10.3"],"aaafilter":["10.3"],"来接受请求体里的参数":["10.4"],"或者":["10.5"],"interceptor":["10.5"],"里取出来":["10.5"],"code":["10.5","11.0","22.4","27.5","27.7","33.4"],"group":["10.5","11.0","22.4"],"controller":["10.5","10.10","11.0","26.3","45.1"],"装饰器取某个请求头":["10.6"],"或者全部请求头":["10.6"],"拿到请求的ip":["10.7"],"log":["10.8","11.1","12.5","27.14","33.6","33.7","34.1","34.2","35.4","35.9"],"host":["10.9","10.10","11.1","50.0"],"可以再第一个handler里注入next":["10.11"],"调用它来吧请求转发到第二个handler":["10.11"],"get":["10.11","27.14"],"eee":["10.11"],"abc":["10.12"],"http":["10.12","12.2"],"baidu":["10.12"],"获取到哪个服务":["11.0"],"然后在代码中if":["11.0"],"else进行处理":["11.0"],"执行顺序demo":["11.0"],"a":["11.1","12.2","12.5"],"错误错误":["11.1"],"b":["11.1","12.2"],"错误啦":["11.1"],"guardexceptionguard":["11.2"],"executioncontext":["11.3","11.4","15.1"],"reflector":["11.3"],"rpc等场景下复用":["11.4"],"nest":["11.4"],"设计了argumenthost":["11.4"],"和":["11.4"],"param":["12.0"],"query":["12.0","24.1"],"id":["12.1","38.4"],"x":["12.2","50.0"],"www":["12.2"],"jsx":["12.2","22.4","32.2","32.4","35.5","35.8","35.9"],"post":["12.2"],"而是用":["12.3"],"一串数字做为":["12.3"],"boundary":["12.3"],"分隔符":["12.3"],"因为不是":["12.3"],"需要对内容做":["12.4"],"url":["12.4"],"encode":["12.4"],"age":["12.5","35.4"],"this":["12.5","22.5","34.1","34.3","35.1","35.4","45.1"],"action":["12.5","23.6"],"returns":["12.5"],"all":["12.5"],"把所有的参数都放到一个对象里面":["12.5"],"findone":["12.5"],"params":["12.5"],"hash":["14.0"],"加密插入数据库":["14.0"],"提高代码可读性":["15.0"],"createparamdecorator":["15.1"],"另一个模块需要":["16.0"],"imports":["16.0","17.0","17.1","17.3"],"它才能用这些":["16.0"],"注入太多的provider不清楚来源":["16.1"],"可维护性差":["16.1"],"全部解析完后":["16.2"],"会监听网络端口":["16.2"],"开始处理请求":["16.2"],"这个过程中":["16.2"],"暴露了一些生命周期方法":["16.2"],"首先":["16.2","31.2"],"递归初始化模块":["16.2"],"global声明为全局":["16.3"],"这样它export的provider就可以在各处使用了":["16.3"],"authmodule":["17.0"],"module":["17.0","17.1","17.3","22.5"],"prismamodule":["17.0","17.2"],"providers":["17.0","17.2"],"provide":["17.2"],"providertest":["17.2"],"链接redis当redis链接成功后再注册provider":["17.3"],"然后再":["17.4"],"module的providers数组里注册的class":["17.4"],"默认provier的token就是class":["17.4"],"可以通过":["22.0"],"hoc":["22.0","22.2"],"向原始组件混入一些状态":["22.0"],"属性代理":["22.1"],"wrapcomponent":["22.2"],"advance":["22.2"],"extends":["22.2","22.3","29.2","34.5","35.1","35.6"],"react":["22.2","22.3","22.4","24.1","27.6","33.9","34.1","34.5","35.5","35.6","35.11"],"component":["22.2","22.3","22.6","29.2","34.5","35.1","35.6"],"state":["22.2","22.5","35.1","38.0"],"render":["22.3","22.4","35.4","35.6"],"div":["22.3","33.4","38.5"],"hello":["22.3"],"world":["22.3"],"得到":["22.4"],"之后的内容":["22.4"],"利用这一点":["22.4"],"可以做渲染劫持":["22.4"],"更有甚者可以修改":["22.4"],"之后的":["22.4"],"element":["22.4"],"对象":["22.4"],"null":["22.5","22.6","29.2","34.2"],"componentdidmount":["22.5","34.1","34.3"],"if":["22.5","24.9","35.7"],"then":["22.5","22.7","24.9"],"wrap":["22.6"],"props":["22.6","33.1","33.2","33.4","33.7","34.3"],"dom":["22.6","31.2"],"useref":["22.6","34.2","34.5","34.6"],"rootpermission":["22.7"],"setrootpermission":["22.7"],"usestate":["22.7","34.5"],"useeffect":["22.7","34.2","34.5"],"获取权限列表":["22.7"],"getrootpermission":["22.7"],"res":["22.7"],"data":["22.7","33.8"],"as":["22.7"],"具体功能":["23.1"],"td":["23.1"],"rowspan":["23.1"],"数据更新驱动":["23.1"],"因为var不会新建作用域":["23.3"],"所以所有的settimeout都是共享一个作用域":["23.3"],"当for循环同步任务执行完毕后开始执行settimeout此时因为循环完成i的值已经为10":["23.3"],"并且所有的settimout共享一个作用域":["23.3"],"所以打印出来的结果都是10":["23.3"],"for":["23.3"],"var":["23.3"],"i":["23.3"],"在函数组件":["23.5"],"一次执行上下文中":["23.5"],"的值是":["23.5"],"固定不变的":["23.5"],"如果两次":["23.5"],"dispatchaction":["23.5"],"传入":["23.5"],"相同的":["23.5"],"值":["23.5"],"那么组件就":["23.5"],"将设置状态的逻辑":["23.6"],"修改成dispatch":["23.6"],"的一个":["23.6"],"编写":["23.6"],"一个":["23.6","32.4"],"函数":["23.6"],"传递数据":["23.7"],"但有时候父组件需要直接访问子组件的方法":["23.8"],"例如触发子组件的某个功能或获取子组件的状态":["23.8"],"传统的解决方案是使用":["23.8"],"ref":["23.8","34.1"],"来引用子组件的实例":["23.8"],"然后通过":["23.8"],"current":["23.8","34.3"],"来访问子组件的方法或属性":["23.8"],"但是":["23.8","31.4","35.3"],"这种方式需要手动编写一些额外的代码":["23.8"],"不够直观和方便":["23.8"],"的出现解决了这个问题":["23.8"],"或其他数据获取库来处理数据请求":["24.1"],"但在某些情况下":["24.1"],"使用":["24.1"],"可以带来更多的好处和便利性":["24.1"],"自动缓存和数据同步":["24.1"],"后期维护困难":["24.2"],"后端返回的错误数据":["24.9"],"errormessage":["24.9"],"seterrormessage":["24.9"],"fetchdata":["24.9"],"开始获取数据":["24.9"],"将isloading置为true":["24.9"],"true":["24.9","24.10"],"fetch":["24.9"],"https":["24.9"],"api":["24.9"],"github":["24.9"],"com":["24.9"],"response":["24.9"],"如果请求返回status不为200":["24.9"],"则抛出后端错误":["24.9"],"status":["24.9"],"message":["24.9"],"await":["24.9"],"如果数据正在加载":["24.10"],"该属性为":["24.10"],"否则为":["24.10"],"false":["24.10","27.14","51.0"],"iserror":["24.10"],"表示查询是否遇到了错误":["24.10"],"发送url请求到服务器端":["25.0"],"server会通过不同的地址返回不同的页面":["25.0"],"为什么需要路由":["25.0"],"不会触发刷新":["25.3"],"to":["25.3","27.14"],"navlink":["25.3"],"类似link":["25.3"],"状态管理":["26.0"],"也被称作单一数据源":["26.1","27.1"],"将所有的数据放到一个大对象中":["26.1","27.1"],"关键词":["26.1","27.1"],"model":["26.3"],"view":["26.3","27.5","27.7","33.4"],"模式中":["26.3"],"数据的变化路径清晰可见":["26.4"],"可以更轻松地追踪数据的流动和变化过程":["26.4"],"更好的组件通信":["26.4"],"flux架构提供了明确的机制来处理组件之间的通信和状态共享":["26.4"],"使得组件间的交互更加可控和灵活":["26.4"],"状态的集中管理":["26.4"],"flux将应用程序的状态集中存储在存储器":["26.4"],"store":["26.4"],"ryun":["27.0"],"逻辑共享":["27.3"],"变得更容易":["27.3"],"但usestate":["27.3"],"the":["27.5","27.7","33.4"],"atom":["27.6","27.8"],"useatom":["27.6"],"jotai":["27.6"],"fc":["27.6"],"valueatom":["27.8"],"mockdata":["27.9"],"promise":["27.9"],"r":["27.9"],"settimeout":["27.9"],"并不需要重新渲染呀":["27.10"],"这是因为":["27.10"],"如果使用useatom":["27.10"],"即使你不引入它的value值":["27.10"],"但它由useatomvalue包裹":["27.10"],"当更新时":["27.10"],"useatomvalue会触发订阅事件":["27.10"],"从而触发渲染":["27.10"],"如果不理解可以阅读":["27.10"],"recoil原理":["27.10"],"理解":["27.10"],"解决渲染问题":["27.11"],"useatomvalue":["27.11"],"正常情况下":["27.12"],"无需用provider包裹组件":["27.12"],"createstore":["27.13"],"export出去":["27.13"],"statusatom":["27.14"],"监听发生变化":["27.14"],"sub":["27.14"],"value":["27.14","29.2"],"is":["27.14"],"changed":["27.14"],"set":["27.14"],"接收两个参数":["28.1"],"一个是state":["28.1"],"一个是action":["28.1"],"中间件用于增强":["28.2"],"dispatch":["28.2","38.5"],"功能":["28.2"],"themecontext":["29.0","29.2"],"提供者":["29.1"],"default":["29.1","32.4","35.1","35.6"],"providerdemo":["29.1"],"提供的":["29.2"],"属性":["29.2"],"这里注意的是":["29.2"],"不是上述老版的contexttypes":["29.2"],"createcontext":["29.2"],"类组件":["29.2"],"consumerdemo":["29.2"],"static":["29.2"],"hooks也提供了":["31.0"],"dep":["31.1"],"第一个参数callback":["31.1"],"返回销毁函数":["31.1"],"下次执行useeffect会首先执行这个销毁函数":["31.1"],"是在":["31.2"],"更新之后":["31.2"],"浏览器绘制之前":["31.2"],"uselayouteffect":["31.3"],"打印":["31.3"],"增加定时器":["31.4"],"延时器":["31.4"],"解除事件监听器":["31.4"],"清除定时器":["31.4"],"模块组件props更新":["31.4"],"代替":["31.4"],"componentwillreceiveprops":["31.4"],"着实有点牵强":["31.4"],"首先因为二者的执行阶段根本不同":["31.4"],"一个是在render阶段":["31.4"],"一个是在commit阶段":["31.4"],"其次":["31.4"],"会初始化执行一次":["31.4"],"只有组件更新":["31.4"],"await等待异步操作":["32.2"],"直到异步操作完成":["32.2"],"才会渲染组件":["32.2"],"用法":["32.2"],"子组件":["32.2"],"userinfo":["32.2"],"需要":["32.4"],"resolve":["32.4"],"组件":["32.4","34.3"],"来作为":["33.1"],"插槽组件":["33.2"],"container":["33.2","45.5"],"是container":["33.3"],"提供的本质是":["33.3"],"里打印":["33.4"],"看看是什么":["33.4"],"im":["33.4"],"此时需要用到一个api":["33.4"],"isvalidelement":["33.4"],"来判断当前children的值是elementdom还是函数":["33.4"],"抽象":["33.5"],"son":["33.6","33.7","33.8"],"father":["33.8","35.6"],"resetform":["33.9"],"方法用于重置表单":["33.9"],"②form组件自动过滤掉除了formitem之外的其他react元素":["33.9"],"③formitem":["33.9"],"中":["33.9"],"name":["33.9"],"属性作为表单提交时候的":["33.9"],"还有展示的":["33.9"],"label":["33.9"],"④":["33.9"],"可以自动收集":["33.9"],"表单的值":["33.9"],"useimperativehandle":["33.9"],"index":["34.1","35.1"],"refs":["34.1"],"currentdom":["34.1"],"字符串模式获取元素或组件":["34.1"],"parentcomponent":["34.2"],"childref":["34.2"],"childrencomponent":["34.2"],"setref":["34.2"],"forwardref":["34.3","34.4"],"会指向":["34.4"],"返回的组件":["34.4"],"而并不是":["34.4"],"包裹的原始类组件":["34.4"],"为了解决这个问题":["34.4"],"可以对":["34.4"],"做一层处理":["34.4"],"父通信子":["34.5"],"直接传递pros":["34.5"],"子通信父":["34.5"],"直接让父ref获取实例":["34.5"],"得到实例方法":["34.5"],"父调用子实例方法用来修改子组件状态":["34.5"],"yuqingcomp":["34.5"],"这时候更新无疑是一种性能上的浪费":["34.6"],"会创建出一个原始的ref对象":["34.6"],"只要组件不销毁则这个对象一直存在":["34.6"],"不影响视图变化的不要放到state中":["34.6"],"因为每次更新state都会重新渲染组件":["34.6"],"可以通过useref来缓存":["34.6"],"因为useref不会引起组件重新渲染":["34.6"],"第一个能够直接修改数据":["34.6"],"不会造成函数组件冗余的更新作用":["34.6"],"第二个":["34.6"],"numbera":["35.1"],"numberb":["35.1"],"button":["35.1","38.5"],"onclick":["35.1","38.5"],"setstate":["35.1","35.4"],"create":["35.2"],"deps":["35.2","35.3"],"第一个参数为一个函数":["35.2"],"函数的返回值作为缓存值":["35.2"],"如上":["35.2"],"中如果有一项改变":["35.3"],"就会重新执行":["35.3"],"返回值作为新的值记录到":["35.3"],"usememo应用场景":["35.3"],"alien":["35.4"],"obj":["35.4"],"changeobjnumber":["35.4"],"组件渲染":["35.4"],"方法中使用的":["35.5"],"这个函数在更新组件的时候被调用":["35.5"],"在这个函数内部":["35.5"],"有一个专门负责检查是否更新的函数":["35.5"],"checkshouldcomponentupdate":["35.5"],"reconciler":["35.5"],"reactfiberclasscomponent":["35.5"],"js":["35.5"],"purecomponent":["35.6"],"callback":["35.6"],"purecomponent的父组件是函数组件的情况":["35.6"],"statenuma":["35.7"],"statenumb":["35.7"],"newprops":["35.7"],"newstate":["35.7"],"newcontext":["35.7"],"demo":["35.9"],"当父组件传递的number更改且大于5时":["35.9"],"更新组件":["35.9"],"children":["35.9"],"forceupdate":["35.10"],"如果更新状态使用的forceupdate":["35.10"],"memo局部更新":["35.11"],"表单":["35.11"],"reducer是把操作整合到一起":["38.1"],"它接收目前的结果和当前的值":["38.2"],"text":["38.4"],"参观卡夫卡博物馆":["38.4"],"看木偶戏":["38.4"],"deleted":["38.4"],"usereducer":["38.5"],"reducer":["38.5"],"initialstate":["38.5"],"它的实际用途包括":["38.6"],"状态复杂逻辑":["38.6"],"当组件的状态逻辑较为复杂":["38.6"],"涉及多个状态变化时":["38.6"],"获取管理员的逻辑":["45.1"],"constructor":["45.1"],"service":["45.1"],"当前service只能获取用户的逻辑":["45.1"],"但是我想再获取管理员的逻辑时就需要新注册一个类":["45.1"],"read":["45.1"],"处理用户数据的逻辑":["45.1"],"control":["45.2"],"解耦和模块化":["45.3"],"需要一个管理容器":["45.4"],"创建一个变量存贮依赖项":["45.5"],"dependencies":["45.5"],"header":["50.0"],"user":["50.0"],"agent":["50.0"],"mozilla":["50.0"],"macintosh":["50.0"],"intel":["50.0"],"mac":["50.0"],"os":["50.0"],"applewebkit":["50.0"]},{"1":["2.0","10.9","10.10","12.2","26.3","27.7","27.9","28.1","33.3","33.9"],"2":["1.3","16.2","26.1","27.1","27.14","31.1","45.3","45.4"],"3":["7.1","23.5","38.4"],"4":["26.4"],"6":["6.2"],"7":["6.2","12.2"],"8":["6.2"],"12":["50.0"],"15":["50.0"],"22":["12.5"],"23":["12.2"],"85":["12.5"],"89":["12.5"],"123":["33.8"],"200":["22.7"],"400":["1.7"],"1000":["23.3"],"3000":["27.9"],"oriented":["1.0"],"programming":["1.0"],"面向切面编程":["1.0"],"是一种编程范式":["1.0"],"一个请求过来会经过":["1.0"],"controller":["1.0","1.4","16.3"],"fastify":["1.1"],"await":["1.2"],"nestfactory":["1.2"],"create":["1.2"],"appmodule":["1.2"],"不生成测试文件":["1.3"],"不生成文件夹":["1.3"],"executioncontext":["1.4","2.1","2.2","11.2"],"boolean":["1.4","2.1","11.2"],"promise":["1.4","2.1","27.6"],"observable":["1.4","2.1","11.3"],"console":["1.4","2.2","10.11","22.6","23.3","31.4"],"log":["1.4","1.5","2.2","10.11","22.6","23.3","31.4"],"return":["1.4","4.0","9.0","10.11","22.4","22.7","24.9","32.2","33.7","34.5","35.5","35.7","35.9"],"true":["1.4","35.7"],"x":["1.4","12.5"],"time":["1.5"],"ms":["1.5"],"interceptor要实现nestinterceptor接口":["1.5"],"实现intercept方法":["1.5"],"调用next":["1.5"],"就会调用目标controller":["1.5"],"time是用来计算controller执行时间的":["1.5"],"tap是rxjs的操作符":["1.5"],"用来在observable的生命周期中的某个点执行副作用":["1.5"],"但不会改变observable的数据流":["1.5"],"details":["1.5","34.4"],"rxjs是一个响应式编程的库":["1.5"],"在rxjs中":["1.5"],"tap是一个操作符":["1.5"],"它用于在observable的生命周期中的某个点执行副作用":["1.5"],"在你的代码中":["1.5"],"export":["1.6","10.1","10.9","10.10"],"class":["1.6","2.1","5.1","10.1","10.9","10.10","22.4"],"validatepipe":["1.6"],"implements":["1.6","2.1"],"transform":["1.6"],"value":["1.6","22.7"],"any":["1.6","9.0","22.7"],"metadata":["1.6"],"if":["1.6","4.0","22.4","35.5"],"number":["1.6","10.4","35.9"],"isnan":["1.6"],"host":["1.7","10.3","12.2"],"argumentshost":["1.7"],"const":["1.7","10.3","10.5","22.5","23.6","27.7","32.2","32.4","33.9","35.9","38.4","45.1"],"response":["1.7","10.3","11.1"],"switchtohttp":["1.7"],"getresponse":["1.7"],"status":["1.7"],"json":["1.7","24.9"],"statuscode":["1.7"],"message":["1.7","38.5"],"aaa":["1.7","10.9","10.10"],"controllet":["1.7"],"get":["1.7","4.0","10.6","10.7","10.10","11.0","15.0","27.8"],"usefilters":["1.7","11.0"],"findall":["1.7"],"query":["1.7"],"num":["1.7"],"必须使用next":["2.0"],"方法将控制权传递给下一个中间件函数":["2.0"],"否则请求将被挂起":["2.0"],"定义中间件":["2.0"],"code":["2.0","11.2","23.6","34.4"],"group":["2.0","23.6"],"typescript":["2.0","6.4","27.10"],"index":["2.0","22.4"],"ts":["2.0","3.0","10.2","10.7","16.1","23.6"],"authgurad":["2.1"],"canactive":["2.1"],"canactivate":["2.1"],"contenxt":["2.1"],"intercept":["2.2"],"context":["2.2"],"next":["2.2"],"callhandler":["2.2"],"验证":["2.3"],"provider":["3.0","6.1","16.3","22.7","27.3"],"useclass":["3.0"],"动态注册":["3.0"],"下面实现根据不同的环境创建不同的服务":["3.0"],"首先安装":["3.0"],"dotenv":["3.0"],"扩展包":["3.0"],"用来读取":["3.0"],"env环境变量":["3.0"],"然后创建两个服务":["3.0"],"service":["3.0","4.0","7.1"],"与":["3.0"],"b":["3.0","10.4"],"tencnetservice":["4.0"],"privider":["4.0"],"curenv":["4.0"],"this":["4.0","22.2","22.4","29.2","34.2","34.5","35.7","45.5"],"config":["4.0"],"其根本思想是":["5.0"],"借助于第三方":["5.0"],"abstrct":["5.1"],"phone":["5.1"],"playgame":["5.1"],"动态provider":["6.0"],"asynprovider":["6.0"],"service和其他提供者":["6.1"],"module的作用是将应用程序拆分为更小的可重用部分":["6.1"],"以便更好的组织代码和管理依赖关系":["6.1"],"路由守卫":["6.2"],"全局拦截器":["6.2"],"控制器之前":["6.2"],"injectable":["6.3"],"装饰器定义":["6.3"],"这样系统会分析":["6.3"],"constructor":["6.3"],"进行依赖注入":["6.3"],"模块提供者也是单例":["6.4"],"所以模块被多个其他模块使用":["6.4"],"那该模块的provider也是共享的":["6.4"],"导入其他模块":["6.4"],"nestjs核心基础概念":["7.0"],"controller处理请求":["7.1"],"服务":["7.1"],"传递给控制器":["8.0"],"拦截器":["8.0"],"管道":["8.0"],"来存的":["9.0"],"定义一个装饰器函数":["9.0"],"用于添加元数据到类或属性上":["9.0"],"function":["9.0","22.3","33.4","33.9","34.4","35.6"],"mymetadata":["9.0"],"mymetadatakey":["9.0"],"使用装饰器给类添加元数据":["9.0"],"for":["9.0"],"appcontroller":["10.1","11.0"],"exception":["10.3"],"argumenthost":["10.3","11.4"],"aaadto":["10.4"],"a":["10.4","33.9"],"common":["10.5","11.1","15.1"],"roles":["10.5"],"string":["10.5","24.9","27.6"],"user":["10.5","12.2","32.2"],"abc":["10.6"],"header":["10.6"],"但要使用":["10.8"],"需要安装一个":["10.8"],"express":["10.8","11.1"],"中间件":["10.8"],"npm":["10.8"],"path":["10.9","10.10"],"aaacontroller":["10.10"],"bbb":["10.10"],"nextfunction":["10.11"],"handler1":["10.11"],"com":["10.12"],"redirectbaidu":["10.12"],"private":["11.0"],"readonly":["11.0"],"appservice":["11.0","17.2"],"myexceptionfilter":["11.0"],"gethello":["11.0"],"myexceptionfilter只能捕获aaaexception异常":["11.0"],"不能捕获httpexception异常":["11.0"],"因为exceptionfilter的":["11.0"],"catch":["11.0","24.9"],"nestjs":["11.1","15.1"],"aaafilter":["11.1"],"focus":["11.2","17.0","23.3"],"core":["11.3"],"rxjs":["11.3"],"role":["11.3"],"类":["11.4"],"可以通过":["11.4"],"getargs":["11.4"],"或者":["11.4"],"form":["12.0","12.5"],"这里的id叫做params":["12.1"],"agent":["12.2"],"postmanruntime":["12.2"],"accept":["12.2"],"localhost":["12.2"],"url":["12.3","50.0"],"的方式了":["12.3"],"自然也不用再做":["12.3"],"encode":["12.3","12.5"],"而":["12.4"],"data":["12.4","27.6","27.9"],"urlencoded":["12.5"],"是通过body传输数据":["12.5"],"其实是把query字符串放在了body里":["12.5"],"这里需要做url":["12.5"],"axios默认自动编译":["12.5"],"content":["12.5"],"type":["12.5","38.5"],"application":["12.5"],"www":["12.5"],"body":["12.5"],"e5":["12.5"],"用nest接收的话就是使用":["12.5"],"body装饰器":["12.5"],"login":["14.0"],"applydecorators":["15.0"],"useguards":["15.0"],"from":["15.0","15.1","27.5","27.10","35.1"],"多个模块需要用到同一个":["16.0"],"global":["16.1"],"module":["16.1"],"依次次调用模块内":["16.2"],"的onmoduleinit方法":["16.2"],"然后在调用module的onmoduleinit方法":["16.2"],"全部初始化完之后":["16.2"],"再依次调用模块内的":["16.2"],"不需要imports":["16.3"],"authservice":["17.0"],"简写":["17.0"],"jwtservice":["17.0"],"prismamodule":["17.1","17.3"],"inject":["17.2"],"person":["17.2"],"providers":["17.3"],"provide":["17.3"],"这样不用使用":["17.4"],"inject来指定注入的token":["17.4"],"但也可以用字符串类型的token":["17.4"],"实现文件上传是基于express":["18.0"],"渲染劫持":["22.0"],"可以利用":["22.0","35.3"],"动态挂载原始组件":["22.0"],"和":["22.1","45.1"],"name":["22.2","33.8"],"alien":["22.2"],"render":["22.2","22.5","29.2","34.5","35.3"],"props":["22.2","31.4","33.5","34.5","35.7","35.11"],"优点":["22.2"],"hoc":["22.3"],"wrapcomponent":["22.3","22.4"],"extends":["22.4"],"visible":["22.4"],"else":["22.4"],"div":["22.4","33.6","33.7","34.5","35.4","35.9"],"暂无数据":["22.4"],"动态加载":["22.5"],"组件":["22.5"],"setstate":["22.5","34.5","35.10"],"useeffect":["22.6","34.6"],"handerclick":["22.6"],"发生点击事件":["22.6"],"current":["22.6"],"addeventlistener":["22.6"],"doclist":["22.7"],"taglist":["22.7"],"rootrouter":["22.7"],"usestate":["23.1","29.1","33.9"],"数据驱动更新":["23.1"],"usereducer":["23.1"],"settimeout":["23.3","27.6"],"结果都是10":["23.3"],"let":["23.3"],"在每次循环的时候都会新建一个作用域":["23.3"],"所以当每次循环的时候settimout被分配到异步队列时都会保存当前的作用域i的值":["23.3"],"而不是所有的settimeout共享一个作用域":["23.3"],"不会更新":["23.5"],"当触发":["23.5"],"在":["23.5"],"当前执行上下文中获取不到最新的state":["23.5"],"只有再下一次组件":["23.5"],"rerender":["23.5"],"中才能获取到":["23.5"],"案例":["23.5"],"此时点击按钮":["23.5"],"log打印出来的值并不是更改过后的number":["23.5"],"在你的组件中":["23.6"],"使用":["23.6","23.8"],"参数":["23.6"],"state":["23.6","34.5"],"dispatch":["23.6"],"避免props层层传递":["23.7"],"它允许子组件通过自定义的方式向父组件暴露自己的实例方法或属性":["23.8"],"父组件可以通过":["23.8"],"直接访问子组件的这些方法或属性":["23.8"],"而无需手动编写额外的代码":["23.8"],"父组件可以更直接地与子组件进行交互":["23.8"],"提供了更灵活的组件通信方式":["23.8"],"它使得父组件能够以更直观的方式调用子组件的方法":["23.8"],"从而简化了组件之间的通信逻辑":["23.8"],"需要注意的是":["23.8"],"自带数据缓存和自动刷新功能":["24.1"],"它会自动缓存数据并定期刷新以保持数据的最新状态":["24.1"],"这减少了手动管理缓存的复杂性":["24.1"],"加载状态管理":["24.1"],"query内置状态管理":["24.1"],"你可以不用再写isloading":["24.1"],"无数据缓存":["24.2"],"throw":["24.9"],"new":["24.9","27.6","38.0"],"error":["24.9","24.10"],"text":["24.9"],"请求完成将isloading置为false":["24.9"],"接口请求成功":["24.9"],"将iserror置为false":["24.9"],"存储后端返回的数据":["24.9"],"接口请求错误":["24.9"],"将iserror置为true":["24.9"],"存储后端返回的错误数据":["24.9"],"如果查询出现错误":["24.10"],"单页应用需要路由切换":["25.0"],"通过url可以定位到页面":["25.0"],"但是会添加当前选中状态":["25.3"],"home":["25.3"],"activeclassname":["25.3"],"combinereducers":["26.1","27.1"],"multiple":["26.1","27.1"],"应用程序的状态分散在多个视图和控制器之间":["26.3"],"导致数据流动难以追踪和管理":["26.3"],"这样的架构往往会导致以下问题":["26.3"],"中":["26.4"],"使得状态的修改和管理更加一致和可控":["26.4"],"提升应用程序的可维护性和可扩展性":["26.4"],"flux架构的职责分离和分层结构使得应用程序的各个模块解耦":["26.4"],"提高了代码的可复用性和可测试性":["26.4"],"便于应用程序的扩展和维护":["26.4"],"人话":["26.4"],"数据单向易于追踪更改来源":["26.4"],"usecontext对于多个store仍需要维护多个context":["27.3"],"因为当context改变":["27.3"],"所有消费该context的组件都会重新渲染即使是组件仅用到了":["27.3"],"context的一部分":["27.3"],"jotai":["27.5"],"fc":["27.5","27.10"],"mockdata":["27.6"],"r":["27.6"],"mock":["27.6","27.9"],"valueatom":["27.7","27.9"],"atom":["27.7","27.9","27.10"],"addnumberatom":["27.8"],"ge":["27.8"],"a组件使用即订阅":["27.10"],"atom原子更新触发订阅事件从而更新":["27.10"],"解决办法":["27.10"],"参考7":["27.10"],"import":["27.10","35.1"],"react":["27.10","27.14","29.0","29.1"],"usesetatom":["27.11"],"如果有的组件只需要监听状态的变化值":["27.11"],"但如果需要控制某些组件的状态不发生更新":["27.12"],"可以用provider包裹":["27.12"],"使用jotai的provider提供给app":["27.13"],"其中":["27.13"],"default":["27.14"],"main":["27.14"],"reactdom":["27.14"],"返回一个新的state":["28.1"],"createstore":["28.1"],"返回一个增强后的":["28.2"],"createcontext":["29.0"],"null":["29.0"],"contextvalue":["29.1"],"setcontextvalue":["29.1"],"color":["29.1","29.2"],"border":["29.2"],"settheme":["29.2"],"background":["29.2"],"函数组件usecontext方式":["29.2"],"既然类组件都可以快捷获取":["29.2"],"了":["29.2"],"那么函数组件也应该研究一下如何快速获取":["29.2"],"吧":["29.2"],"于是乎":["29.2"],"api":["31.0"],"用于弥补函数组件没有生命周期的缺陷":["31.0"],"销毁定时器":["31.1"],"订阅等以防资源泄露":["31.1"],"第二个参数为依赖项":["31.1"],"依赖项发生变化则执行callback":["31.1"],"这样可以方便修改":["31.2"],"获取":["31.2"],"信息":["31.2"],"本质上是解决":["31.3"],"css":["31.3"],"in":["31.3"],"js":["31.3","32.4"],"产生的重绘问题":["31.3"],"style":["31.3"],"components库为例":["31.3"],"tip":["31.3"],"component":["31.3","35.8"],"你可以使用es6的标签模板字符串语法":["31.3"],"tagged":["31.3"],"变化的时候才会执行":["31.4"],"props变化":["31.4"],"模块更新后":["31.4"],"componentdidupdate":["31.4"],"组件更新完成":["31.4"],"没有":["31.4"],"依赖项":["31.4","34.6"],"注意此时useeffect没有第二个参数":["31.4"],"没有第二个参数":["31.4"],"那么每一次执行函数组件":["31.4"],"都会执行该":["31.4"],"获取用户数据信息":["32.2"],"然后再渲染组件":["32.2"],"getuserinfo":["32.2"],"h1":["32.2"],"lazycomponent":["32.4"],"test":["32.4"],"改变后的监听函数":["33.1"],"不过有一点值得注意":["33.1"],"上述可以在":["33.2"],"组件中":["33.2"],"通过":["33.2"],"reutrn":["33.3"],"这种方式作用是":["33.3"],"根据需要控制":["33.3"],"hello":["33.4","33.6","33.7"],"my":["33.4"],"is":["33.4"],"mes":["33.4"],"一般用于跨层级传递":["33.5"],"world":["33.6","33.7"],"father":["33.6"],"隐式注入":["33.8"],"cloneelement":["33.9"],"children":["33.9","35.2"],"forwardref":["33.9"],"可接收父组件传递过来的ref确定具体渲染的dom":["33.9"],"myform":["33.9"],"可使父组件直接访问抛出方法":["33.9"],"currentcominstance":["34.1"],"ref是一个函数":["34.1"],"node":["34.2"],"span":["34.2"],"ref":["34.2","34.3","34.6"],"通过forwardref转发":["34.2"],"newfahter组件是为了转发ref的中间组件":["34.2"],"给form组件实例":["34.3"],"绑定给":["34.3"],"form属性":["34.3"],"给index组件实例":["34.3"],"index属性":["34.3"],"button":["34.3","35.4"],"给button":["34.3"],"dom":["34.3"],"元素":["34.3"],"高阶组件把组件作为参数":["34.4"],"我们想获取的ref其实是这个参数的实例":["34.4"],"如果不使用forwardref转发一下那么最终获取到的组件就是hoc返回的wrap组件":["34.4"],"但是我们需要的事传递进hoc被包裹的组件":["34.4"],"forwardref的意义是可以让开发着手动控制ref的指向":["34.4"],"view":["34.4"],"the":["34.4"],"jsx":["34.4"],"togjsmsg":["34.5"],"togyqmsg":["34.5"],"调用父组件传递过来的修改函数":["34.5"],"togjs":["34.5"],"提供实例方法供父组件调用":["34.5"],"toyq":["34.5"],"msg":["34.5"],"gjs":["34.5"],"say":["34.5"],"保存数据":["34.6"],"如果有":["34.6"],"usememo":["34.6"],"引用":["34.6"],"对象中的数据":["34.6"],"无须将":["34.6"],"对象添加成":["34.6"],"dep":["34.6"],"因为":["34.6"],"改变numbera":["35.1"],"改变numberb":["35.1"],"children只依赖a":["35.1"],"当b更新后会触发组件整体更新":["35.1"],"此时就需要单独判断children是否需要更新":["35.1"],"根据修改的值是不是a判断":["35.1"],"优化":["35.1"],"demo":["35.2"],"中把":["35.2"],"对应的":["35.2"],"element":["35.2","35.3"],"可以缓存":["35.3"],"对象":["35.3"],"从而达到按条件渲染组件":["35.3"],"优化性能的作用":["35.3"],"如果组件中不期望每次":["35.3"],"都重新计算一些值":["35.3"],"组件本身改变state":["35.4"],"onclick":["35.4"],"state相同情况":["35.4"],"typeof":["35.5"],"instance":["35.5"],"shouldcomponentupdate":["35.5"],"newprops":["35.5"],"newstate":["35.5"],"nextcontext":["35.5"],"逻辑":["35.5"],"绑定函数要用usecallback或者usememo处理":["35.6"],"就是再用class":["35.6"],"组件开发项目的时候":["35.6"],"如果父组件是函数":["35.6"],"子组件是purecomponent":["35.6"],"那么绑定函数要小心":["35.6"],"因为函数组件每一次执行":["35.6"],"如果不处理":["35.6"],"还会声明一个新的函数":["35.6"],"所以purecomponent对比同样会失效":["35.6"],"propsnuma":["35.7"],"只有当":["35.7"],"子组件渲染":["35.9"],"child":["35.9"],"prevprops":["35.9"],"nextprops":["35.9"],"而不是":["35.10"],"一般会采用受控组件的模式去管理表单数据层":["35.11"],"表单数据层完全托管于":["35.11"],"或是":["35.11"],"用户触发事件名进而执行相应的处理函数":["38.1"],"例如":["38.1"],"然后返回下一个结果":["38.2"],"打卡列侬墙":["38.4"],"finalstate":["38.4"],"reduce":["38.4"],"output":["38.4"],"document":["38.4"],"getelementbyid":["38.4"],"add":["38.5"],"添加":["38.5"],"可以使用usereducer来更好地组织和管理状态的变化逻辑":["38.6"],"替代usestate":["38.6"],"在一些情况下":["38.6"],"使用usereducer可以替代多个独立的usestate":["38.6"],"result":["45.1"],"此时controller":["45.1"],"存在了强耦合的关联":["45.1"],"无法复用":["45.1"],"若我们想用authservice时必须新注册一个类来实现":["45.1"],"控制反转":["45.2"],"container":["45.4"],"注册方法":["45.5"],"register":["45.5"],"dependency":["45.5"],"khtml":["50.0"],"like":["50.0"],"gecko":["50.0"],"version":["50.0"],"safari":["50.0"],"15accept":["50.0"],"encoding":["50.0"],"gzipbody":["50.0"]},{"0":["27.10","31.4"],"1":["22.2","27.6"],"2":["12.5","33.3"],"3":["16.2","22.0","45.4"],"4":["7.1"],"5":["35.9"],"8":["29.2"],"9":["6.2"],"10":["6.2"],"111":["10.11"],"456":["12.1"],"3000":["12.2","27.6"],"service":["1.0"],"repository":["1.0"],"db":["1.0"],"这样的一条链路":["1.0"],"aop就是在这条链路上加上一些额外的逻辑":["1.0"],"比如日志":["1.0"],"可选":["1.1"],"use":["1.2","2.0"],"req":["1.2","2.0"],"res":["1.2"],"next":["1.2"],"包含中间件的模块必须实现nestmodule接口":["1.3"],"让我们在appmodule级别设置中间件":["1.3"],"ts":["1.3"],"module":["1.3","6.0","10.2"],"export":["1.3","2.0","10.5","11.3","12.5","15.0","15.1","22.3","34.5","35.9","38.4"],"class":["1.3","2.0","9.0","11.3","12.5","34.4","35.9"],"xcontroller":["1.4"],"get":["1.4","10.5","10.9","27.9"],"useguards":["1.4"],"index":["1.4","22.5","27.14","32.4"],"全局启用守卫":["1.4"],"main":["1.4"],"第一种":["1.4"],"app":["1.4","27.14"],"useglobalguards":["1.4"],"new":["1.4","1.6","11.0"],"tap用于在observable完成时打印出执行时间":["1.5"],"这里的tap操作符接收一个函数":["1.5"],"这个函数会在每次observable发出值时被调用":["1.5"],"但不会改变或使用这个值":["1.5"],"这个函数是一个箭头函数":["1.5"],"它打印出从开始到现在的时间差":["1.5"],"这是一个很好的用例":["1.5"],"因为你可能想要在不改变observable流的情况下":["1.5"],"记录或打印出一些信息":["1.5"],"和":["1.5"],"middleware很相似":["1.5"],"仔细研究他们的区别":["1.5"],"middleware":["1.5"],"定义":["1.5"],"是一种位于请求和响应处理流程中间的函数":["1.5"],"主要用于请求的前置处理":["1.5"],"用途":["1.5"],"它们通常用于执行一些关于请求的通用操作":["1.5"],"如日志记录":["1.5"],"请求验证":["1.5"],"parseint":["1.6"],"throw":["1.6","11.0"],"badrequestexception":["1.6"],"validation":["1.6"],"failed":["1.6"],"return":["1.6","2.1","2.2","29.1","32.4","33.4","35.6"],"pipe可以拿到req的参数value":["1.6"],"可以对参数进行验证":["1.6"],"格式化等操作":["1.6"],"验证正确就返回":["1.6"],"不正确就抛出异常":["1.6"],"this":["1.7","34.4"],"aaaservice":["1.7"],"details":["1.7"],"nest":["1.7","4.0"],"内置了很多":["1.7"],"http":["1.7","11.1"],"相关的异常":["1.7"],"都是":["1.7"],"httpexception":["1.7","11.0"],"的子类":["1.7"],"unauthorizedexception":["1.7"],"notfoundexception":["1.7"],"forbiddenexception":["1.7"],"notacceptableexception":["1.7"],"requesttimeoutexception":["1.7"],"conflictexception":["1.7"],"goneexception":["1.7"],"payloadtoolargeexception":["1.7"],"unsupportedmediatypeexception":["1.7"],"unprocessableexception":["1.7"],"internalservererrorexception":["1.7"],"notimplementedexception":["1.7"],"badgatewayexception":["1.7"],"serviceunavailableexception":["1.7"],"gatewaytimeoutexception":["1.7"],"中间件实例代码":["2.0"],"injectable":["2.0"],"loggermiddleware":["2.0"],"implements":["2.0","11.3"],"nestmiddleware":["2.0"],"const":["2.1","2.2","9.0","11.1","15.1","27.5","27.10","31.4","33.6","33.7","34.4","34.5","34.6","35.6"],"request":["2.1","10.10","11.4"],"switchtohttp":["2.1","10.3","11.1"],"getrequest":["2.1"],"validaterequest":["2.1"],"function":["2.1","32.4","33.8","34.5","38.4"],"before":["2.2"],"now":["2.2"],"date":["2.2"],"他可以在控制器之前或之后对数据进行预处理":["2.3"],"import":["3.0","22.5"],"config":["3.0"],"from":["3.0"],"读取":["3.0"],"env":["3.0"],"到":["3.0"],"process":["3.0"],"环境变量中":["3.0"],"path":["3.0"],"join":["3.0"],"system":["4.0"],"provider":["4.0","27.14"],"send":["4.0"],"getsmsprovider":["4.0"],"使用":["4.0","29.2"],"实现具有依赖关系的对象之间的解耦":["5.0"],"第三方举例":["5.0"],"name":["5.1","17.2","32.2"],"string":["5.1","9.0","17.2"],"controller提供一个路由处理器":["6.1"],"他可以将http请求映射到响应的处理器方法上":["6.1"],"并将处理器方法的结果作为http响应返回给client":["6.1"],"controller是处理":["6.1"],"控制器层拦截器":["6.2"],"路由拦截器":["6.2"],"全局管道":["6.2"],"提供者在模块的":["6.3"],"providers":["6.3","17.1"],"属性中定义":["6.3"],"用于注册到服务容器中":["6.3"],"用于被其他类依赖注入":["6.3"],"提供者可以在自身的constructor构造函数中依赖注入其他服务提供者":["6.3"],"imports":["6.4","16.1"],"jwtmodule":["6.4"],"registerasync":["6.4"],"configmodule":["6.4"],"inject":["6.4"],"configservice":["6.4"],"愿我们共同进步":["7.0"],"操作数据库以及处理所有逻辑的地方":["7.1"],"管道":["7.1"],"守卫等各个部分":["8.0"],"以便他们可以对请求进行处理和转换":["8.0"],"the":["9.0"],"entire":["9.0"],"example":["9.0"],"使用装饰器给属性添加元数据":["9.0"],"property":["9.0"],"propertywithmetadata":["9.0"],"获取类的元数据":["9.0"],"classmetadata":["9.0"],"code":["10.1","10.2","23.8"],"private":["10.1","11.3"],"getresponse":["10.3"],"status":["10.3","24.10"],"getstatus":["10.3"],"controller":["10.4"],"bbb":["10.4","10.9"],"gethello":["10.4"],"body":["10.4"],"aa":["10.5"],"appservice":["10.5"],"useguard":["10.5"],"aaaguard":["10.5","11.3"],"admin":["10.5"],"getpassword":["10.5"],"accept":["10.6"],"install":["10.8"],"在main":["10.8"],"ts引入并启用":["10.8"],"aaacontroller":["10.9"],"hello":["10.9","10.10","35.4"],"console":["10.10","35.7"],"log":["10.10","35.7"],"eee2":["10.11"],"aaaexception":["11.0"],"中指定了aaaexception异常处理":["11.0"],"错误错误":["11.0"],"错误啦":["11.0"],"不会处理http异常":["11.0"],"因为catch没有指定httpexception异常":["11.0"],"if":["11.1","33.4","45.5"],"gettype":["11.1"],"ctx":["11.1"],"切换至http上下文":["11.1"],"promise":["11.2"],"observable":["11.2"],"constructor":["11.3","35.1"],"getargbyindex":["11.4"],"拿到上下文参数":["11.4"],"比如":["11.4","28.2"],"response":["11.4"],"urlencoded":["12.0"],"这里的id叫做query":["12.1"],"其中非英文的字符和一些特殊字符要经过编码":["12.1"],"encoding":["12.2"],"gzip":["12.2"],"deflate":["12.2"],"br":["12.2","23.5"],"引入图片":["12.3"],"alt":["12.3"],"text":["12.3","27.7","34.5"],"则需要加很长的":["12.4"],"boundary":["12.4"],"两种方式都有一些缺点":["12.4"],"nest会解析请求体然后注入到dto中":["12.5"],"dto":["12.5"],"data":["12.5"],"transfer":["12.5"],"object":["12.5"],"封装数据传输对象":["12.5"],"创建dto":["12.5"],"在controller中使用":["12.5"],"createcatdto":["12.5"],"isstring":["12.5"],"readonly":["12.5"],"isint":["12.5"],"breed":["12.5"],"登录接收账号密码":["14.0"],"argon2":["14.0"],"nestjs":["15.0"],"common":["15.0"],"时":["16.0"],"可以把这个":["16.0"],"prismamodule":["16.1"],"的":["16.2","31.3","33.3"],"onapplicationbootstrap":["16.2"],"方法":["16.2"],"然后调用":["16.2"],"module都支持启动和销毁函数":["16.3"],"这些生命周期函数都支持async的方式":["16.3"],"provide":["17.0","17.1"],"jwt":["17.0"],"useclass":["17.0"],"usefactory":["17.2","17.3"],"redis":["17.3"],"client":["17.3","27.14"],"async":["17.3","27.9"],"不过注入的时候要用":["17.4"],"inject单独指定":["17.4"],"除了useclass":["17.4"],"multer实现的":["18.0"],"还可以先获取原始组件的渲染树":["22.0"],"进行可控性修改":["22.0"],"可以配合":["22.0"],"反向继承":["22.1"],"属性代理可以和业务组件低耦合":["22.2"],"零耦合":["22.2"],"对于条件渲染和":["22.2"],"属性增强":["22.2"],"只负责控制子组件渲染和传递额外的":["22.2"],"就可以了":["22.2"],"所以无须知道":["22.2"],"直接继承需要包装的组件":["22.3"],"default":["22.3","34.5","35.9","38.4"],"优点":["22.3"],"①":["22.3"],"控制渲染树":["22.4"],"component":["22.4","34.4"],"ul":["22.4"],"li":["22.4"],"vue":["22.4"],"props":["22.5","35.1"],"loading":["22.5","32.4"],"asyncrouter":["22.5"],"pages":["22.5"],"click":["22.6"],"removeeventlistener":["22.6"],"编写hoc":["22.7"],"没有权限":["22.7"],"nopermission":["22.7"],"div":["22.7","24.9","29.1","32.4"],"您暂时没有权限":["22.7"],"请联系管理员开通权限":["22.7"],"permissionhoc":["22.7"],"订阅状态":["23.1"],"创建reducer":["23.1"],"更新试图":["23.1"],"usesyncexternalstore":["23.1"],"订阅外部数据源触发更新":["23.1"],"而是更改前的值":["23.5"],"这意味着log时更改未发生":["23.5"],"原因":["23.5"],"setnumber是异步的":["23.5"],"触发handleclick时":["23.5"],"任务线程会先执行同步再执行异步":["23.5"],"所以log打印的是更改前的值":["23.5"],"外部log可以获取到最新的值的原因是":["23.5"],"在执行完同步的log后执行异步setnumber":["23.5"],"异步setnumber触发重新渲染":["23.5"],"重新执行index函数":["23.5"],"initstate":["23.6"],"实际使用":["23.6"],"type":["23.6","34.5","34.6"],"导致代码冗余":["23.7"],"应该与":["23.8"],"forwardref":["23.8"],"一起使用":["23.8"],"以便将子组件的引用传递给父组件":["23.8"],"总结来说":["23.8"],"解决了在":["23.8"],"组件中":["23.8"],"父组件需要直接访问子组件的实例方法或属性时":["23.8"],"通过更简洁":["23.8"],"直观的方式实现组件之间的通信的问题":["23.8"],"group":["23.8"],"isfetching等状态了":["24.1"],"它会自动管理数据加载状态":["24.1"],"数据同步和预取":["24.1"],"支持数据预取和自动同步":["24.1"],"提前获取数据并在后台刷新":["24.1"],"以保持数据最新":["24.1"],"无数据同步":["24.2"],"useeffect":["24.9"],"初始化请求数据":["24.9"],"h1":["24.9"],"p":["24.9"],"加载中":["24.9"],"button":["24.9","34.5"],"onclick":["24.9","34.5"],"重试":["24.9"],"刷新":["24.9"],"after":["24.9"],"该属性将包含错误信息":["24.10"],"通常是一个错误对象":["24.10"],"包含有关查询错误的详细信息":["24.10"],"表示查询的状态":["24.10"],"用于指示加载中":["24.10"],"更有语义的组织资源":["25.0"],"三种路由的实现方式":["25.0"],"browserrouter":["25.0"],"selected":["25.3"],"prompt":["25.3"],"满足条件时提示用户是否离开页面":["25.3"],"when":["25.3"],"stores":["26.1","27.1"],"多数据源模式":["26.1","27.1"],"将状态存放到多个数据源中":["26.1","27.1"],"数据流动不可控":["26.3"],"在mvc模式中":["26.3"],"视图可以直接修改模型的状态":["26.3"],"模型可以直接更新视图":["26.3"],"统一状态管理":["26.4"],"数据可预测性":["26.4"],"新状态":["26.4"],"旧状态":["26.4"],"事件":["26.4"],"tip":["26.4"],"flux":["26.4"],"的核心思想是单向数据流":["26.4"],"容易导致不必要的":["27.3"],"无用渲染":["27.3"],"造成性能损失":["27.3"],"比如react":["27.3"],"react":["27.5","31.1","33.4","34.4","34.6"],"创建atom":["27.5","27.6"],"valueatom":["27.5","27.6"],"派生atom":["27.6"],"依赖某个atom":["27.6"],"value":["27.7","34.5"],"set":["27.8","27.9"],"arg":["27.8","27.9"],"addnumberatom":["27.9"],"null":["27.9","34.1","34.3","38.4"],"result":["27.9"],"useatom":["27.10"],"useatomvalue":["27.10"],"usesetatom":["27.10"],"jotai":["27.10"],"countatom":["27.10"],"a":["27.10"],"而没有更新操作":["27.11"],"请使用useatomvalue":["27.11"],"或者说":["27.12"],"用provider包裹的组件":["27.12"],"store中的状态":["27.13"],"是全局的":["27.13"],"dom":["27.14"],"tsx":["27.14"],"css":["27.14"],"创建一个":["28.1"],"root":["28.1"],"存放":["28.1"],"redux":["28.2"],"thunk":["28.2"],"themeprovider":["29.0"],"ccc":["29.1"],"background":["29.1"],"pink":["29.1"],"hooks":["29.2"],"usecontext":["29.2"],"下面看一下":["29.2"],"接受一个参数":["29.2"],"就是想要获取的":["29.2"],"返回一个":["29.2"],"值":["29.2"],"就是最近的":["29.2"],"提供":["29.2"],"contextvalue":["29.2"],"其原理主要是运用了":["31.0"],"对于":["31.1"],"执行":["31.1"],"处理逻辑是采用异步调用":["31.1"],"这样浏览器只会绘制一次":["31.2"],"如果修改":["31.2"],"布局放在":["31.2"],"那":["31.2"],"templates":["31.3"],"为需要":["31.3"],"styled":["31.3"],"定义一系列css属性":["31.3"],"当该组件的js代码被解析执行的时候":["31.3"],"components":["31.3"],"会动态生成一个":["31.3"],"选择器":["31.3"],"并把对应的":["31.3"],"alldemo":["31.4"],"functionlifecycle":["31.4"],"num":["31.4"],"setnum":["31.4"],"usestate":["31.4"],"组件挂载完成":["31.4"],"清除":["31.4"],"父组件":["32.2"],"fallback":["32.2","32.4"],"加载过程中的占位符":["32.2"],"需要等待异步加载完成后渲染的组件":["32.2"],"确保组件拿到的数据是异步请求后最新的数据":["32.2"],"suspense":["32.4"],"初始化会默认执行一次":["33.1"],"jsx":["33.1","34.6"],"属性访问到":["33.2"],"组件":["33.2"],"为":["33.2"],"渲染与否":["33.3"],"可以将需要传给":["33.3"],"直接通过函数参数的方式传递给执行函数":["33.3"],"alien":["33.4"],"let":["33.4","33.6","34.6","35.4"],"us":["33.4","33.6","34.6","35.4"],"learn":["33.4","33.6","34.6","35.4"],"map":["33.4"],"item":["33.4"],"focus":["33.4"],"fatherprops":["33.6","33.7"],"mes":["33.6","34.6"],"father":["33.7"],"age":["33.7"],"formvalue":["33.9"],"setformvalue":["33.9"],"setvalue":["33.9"],"inputvalue":["33.9"],"callback":["33.9"],"renderelements":["33.9"],"这里是react":["33.9"],"children用来循环react":["33.9"],"element的方法":["33.9"],"foreach":["33.9"],"el":["33.9"],"currentcomponentinstance":["34.1"],"forwardref的第二个参数是ref":["34.2"],"这个ref是grandfahter组件传递过来的":["34.2"],"至此一层一层从prop传递":["34.2"],"最终通过ref赋值":["34.2"],"grandfather":["34.2"],"button属性":["34.3"],"点击":["34.3"],"wrap":["34.4"],"extends":["34.4"],"render":["34.4","35.7"],"forwardedref":["34.4"],"otherprops":["34.4"],"对":["34.5"],"gjs说":["34.5"],"input":["34.5"],"onchange":["34.5"],"e":["34.5"],"target":["34.5"],"to":["34.5"],"耿嘉帅":["34.5"],"gjscomp":["34.5"],"始终指向一个内存空间":["34.6"],"所以这样一点好处是可以随时访问到变化后的值":["34.6"],"tolearn":["34.6"],"super":["35.1"],"对象":["35.2"],"缓存起来":["35.2"],"第二个参数为一个数组":["35.2"],"存放当前":["35.2"],"把它缓存起来":["35.3"],"可以把函数和属性缓存起来":["35.3"],"作为":["35.3"],"purecomponent":["35.3"],"的绑定方法":["35.3"],"或者配合其他hooks一起使用":["35.3"],"原理其实很简单":["35.3"],"每次执行":["35.3"],"state不同情况":["35.4"],"state为引用数据类型时候":["35.4"],"my":["35.4"],"is":["35.4"],"ctor":["35.5"],"prototype":["35.5"],"shallowequal":["35.5"],"oldprops":["35.5"],"oldstate":["35.5"],"综上可以用":["35.6"],"usecallback":["35.6"],"或者":["35.6"],"或":["35.7"],"发生变化时才会更新":["35.7"],"false":["35.7"],"compare":["35.8"],"如果返回true":["35.9"],"需要memo备忘":["35.9"],"会跳过shouldcomponentupdate的判断":["35.10"],"直接更新组件":["35.10"],"state":["35.11"],"而用户操作表单往往是频繁的":["35.11"],"需要频繁改变数据层":["35.11"],"所以很有可能让整个页面组件高频率":["35.11"],"用户触发添加程序":["38.1"],"react中的reducer也是这样的他们都接受":["38.2"],"textcontent":["38.4"],"json":["38.4"],"stringify":["38.4"],"reducer":["38.4"],"newstate":["38.5"],"接收状态事件":["38.5"],"计算新的状态":["38.5"],"switch":["38.5"],"从而将相关状态集中管理":["38.6"],"减少状态逻辑的分散":["38.6"],"可预测性":["38.6"],"并且需要改动getuser里面的代码":["45.1"],"那我们此时就需要解决这个问题":["45.1"],"使用di":["45.1"],"依赖是service":["45.1"],"依赖的标准需要拥有一个getlist方法":["45.1"],"并且接收一个id":["45.1"],"控制反转的本质就是降低耦合度":["45.2"],"更方便的依赖注入":["45.3"],"容器需要拥有register方法用来管理容器的注册":["45.4"],"解析方法":["45.5"],"resolve":["45.5"],"page":["51.0"]},{"0":["1.7","34.6","35.4","35.9"],"1":["32.4","35.5"],"2":["1.7","22.2","26.3","28.1","32.4","35.5","35.10"],"3":["1.7","22.2","26.1","27.1","35.11","45.3"],"4":["1.7","16.2"],"5":["7.1"],"9":["23.3"],"11":["6.2"],"12":["6.2"],"13":["6.2"],"14":["6.2"],"21":["12.2"],"102":["50.0"],"127":["10.9"],"300":["50.0"],"400":["11.0"],"500":["11.1"],"权限校验":["1.0"],"异常处理等等":["1.0"],"如果直接在controller中去写这些逻辑":["1.0"],"会与业务代码混淆":["1.0"],"不利于维护":["1.0"],"aop就是为了解决这个问题":["1.0"],"所以nest也有中间件的概念":["1.1"],"是一个对象":["1.2"],"包含了请求的所有信息":["1.2"],"appmodule":["1.3"],"implements":["1.3","10.5"],"nestmodule":["1.3"],"configure":["1.3"],"consumer":["1.3"],"middlewareconsumer":["1.3"],"module":["1.4"],"第二种":["1.4"],"imports":["1.4","3.0","10.2"],"controllers":["1.4","3.0","16.1","17.0"],"providers":["1.4","10.2","16.1"],"appservice":["1.4","3.0","10.2"],"provide":["1.4"],"useclass":["1.4"],"设置请求头等":["1.5"],"作用域":["1.5"],"可以访问请求和响应对象":["1.5"],"但不能访问处理请求的路由处理程序的细节":["1.5"],"控制流":["1.5"],"不能改变控制流":["1.5"],"即它们不能决定是否继续处理请求":["1.5"],"只能对请求进行一些处理或添加一些额外的信息":["1.5"],"是基于":["1.5"],"aop":["1.5"],"面向切面编程":["1.5"],"概念实现的":["1.5"],"它可以拦截和修改从一个函数流向另一个函数的数据":["1.5"],"它们通常用于在方法执行之前或之后添加额外的逻辑":["1.5"],"如修改返回值":["1.5"],"异常映射":["1.5"],"扩展基本方法行为":["1.5"],"事务管理等":["1.5"],"使用":["1.6"],"aaa":["1.6","10.4","11.0"],"appcontroller":["1.6"],"get":["1.6","6.4","27.6"],"b":["1.6","26.4"],"a":["1.6","4.0","10.1","17.1"],"query":["1.6","24.9"],"num":["1.6"],"也可以自己扩展":["1.7"],"extends":["1.7","5.1","22.6","35.9"],"constructor":["1.7","35.9"],"super":["1.7","35.9"],"forbidden":["1.7"],"httpstatus":["1.7"],"通过这样的方式实现了异常到响应的对应关系":["1.7"],"代码里只要抛出不同的异常":["1.7"],"就会返回对应的响应":["1.7"],"很方便":["1.7"],"aop执行顺序":["1.7"],"middleware是继承的express":["1.7"],"在最外层调用":["1.7"],"进入路由先调用guard判断是否有权限":["1.7"],"如有权限会跳到拦截器":["1.7"],"拦截器组织了一个链条通过next":["1.7"],"调用":["1.7"],"直至controller":["1.7"],"到controller之前会先调用pipe判断是否有权限":["1.7"],"request":["2.0","11.1"],"res":["2.0","10.10"],"response":["2.0"],"next":["2.0","11.4"],"function":["2.0","15.0","22.4","23.8","29.2","34.6","35.4"],"console":["2.0","9.0","10.4","24.9","27.10","33.1"],"log":["2.0","9.0","10.4","24.9","27.10"],"中间件触发":["2.0"],"if":["2.1","33.9","35.1"],"true":["2.1","11.2"],"details":["2.1"],"定义一个authguard守卫类":["2.1"],"实现canactivate接口":["2.1"],"handle":["2.2"],"pipe":["2.2"],"tap":["2.2"],"after":["2.2"],"然后将数据传递给控制器或下一个管道":["2.3"],"管道的主要目的是增强应用的可靠性":["2.3"],"dirname":["3.0"],"const":["3.0","11.3","12.1","17.3","23.8","31.3","35.1","35.7"],"node":["3.0","34.1","34.5"],"development":["3.0"],"bservice":["3.0"],"快速配置env配置":["4.0"],"配置环境文件":["4.0"],"import":["4.0","10.8","11.0","22.0","23.3"],"registeras":["4.0"],"from":["4.0","10.8","11.0","23.3"],"nestjs":["4.0"],"default":["4.0","32.2","34.6","35.4","38.5"],"ts注解":["5.0"],"或直接传递参数":["5.0"],"iphone":["5.1"],"静态模块":["6.0"],"http请求并返回http响应的类":["6.1"],"controller的作用是将路由映射到处理请求方法上":["6.1"],"在controller中可以使用nestjs提供的装饰器来定义":["6.1"],"路由":["6.1"],"中间件":["6.1"],"控制器管道":["6.2"],"路由管道":["6.2"],"路由参数管道":["6.2"],"需要使用":["6.3"],"装饰器声明该提供者":["6.3"],"注册到容器的提供者":["6.3"],"默认只对当前模块有效":["6.3"],"即作用域为模块":["6.3"],"usefactory":["6.4","17.4"],"return":["6.4","10.9","11.2","17.2","23.6","27.7","27.10","29.2","33.8","33.9","34.4","38.4","45.5"],"secret":["6.4"],"pipes":["7.1"],"核验请求的数据":["7.1"],"过滤器":["7.1"],"当一个请求到达应用程序时":["8.0"],"nestjs框架会将他封装成一个executioncontext对象":["8.0"],"获取属性的元数据":["9.0"],"propertymetadata":["9.0"],"new":["9.0","45.5"],"readonly":["10.1"],"record":["10.1"],"json":["10.3","11.1","12.0","12.5"],"msg":["10.3"],"message":["10.3","25.3"],"controller":["10.3"],"除了":["10.4"],"injectable":["10.5"],"roleguard":["10.5"],"canactivate":["10.5"],"inject":["10.5"],"reflector":["10.5"],"private":["10.5"],"string":["10.6"],"as":["10.8"],"app":["10.8","35.11"],"hostname":["10.10"],"必须手动":["10.10"],"end去响应":["10.10"],"nest":["10.10","10.11"],"handler2":["10.11"],"不会处理注入":["10.11"],"next的handler返回值":["10.11"],"handler默认返回值是200状态码":["10.11"],"code":["10.12"],"exception":["11.0"],"filter":["11.0"],"捕获":["11.0"],"getresponse":["11.1"],"getrequest":["11.1"],"status":["11.1"],"bbb":["11.1","15.0"],"getclass":["11.2"],"gethandler":["11.2"],"context":["11.3","35.10"],"boolean":["11.3"],"promise":["11.3"],"获取目标方法的元数据":["11.3"],"等":["11.4","22.0"],"更推荐的方式是根据":["11.4"],"gettype":["11.4"],"的结果分别":["11.4"],"switchtohttp":["11.4"],"data":["12.0"],"可以使用":["12.1"],"encodeuricomponent":["12.1"],"的":["12.1","31.1","35.3"],"api":["12.1","12.5","22.0"],"来编码":["12.1"],"unlencoded":["12.2"],"length":["12.2"],"connection":["12.2"],"keep":["12.2"],"alive":["12.2"],"需要指定":["12.3"],"content":["12.3"],"type":["12.3","33.9"],"为":["12.3"],"multipart":["12.3"],"如果只是传输":["12.4"],"数据的话":["12.4"],"person":["12.5"],"personcontroller":["12.5"],"post":["12.5"],"example":["12.5"],"需要指定content":["12.5"],"type为aplication":["12.5"],"内容会以json的形式传输":["12.5"],"光":["12.5"],"verify对密码进行解密":["14.0"],"解密符合":["14.0"],"path":["15.0"],"ccc":["15.1"],"放到一个模块中":["16.0"],"然后":["16.0"],"aservice":["16.1"],"然后监听网络端口":["16.2"],"之后":["16.2"],"应用就正常运行了":["16.2"],"onmoduleinit":["16.2"],"onapplicationbootstrap等":["16.2"],"都是我们可以实现的生命周期方法":["16.2"],"ts":["16.2"],"可以在里面做一些初始化":["16.3"],"销毁的逻辑":["16.3"],"authcontroller":["17.0"],"export":["17.0","32.2","34.6","35.4"],"class":["17.0","22.6"],"usevalue":["17.1"],"authservice":["17.2"],"perison":["17.2"],"createclient":["17.3"],"socket":["17.3"],"还可以usevalue":["17.4"],"useexisting":["17.4"],"然后通过一系列适配器和拦截器集成到nestjs中":["18.0"],"实现动态加载组件":["22.0"],"实现代码分割":["22.0"],"两种":["22.1"],"业务组件做了些什么":["22.2"],"所以正向属性代理":["22.2"],"更适合做一些开源项目的":["22.2"],"目前开源的":["22.2"],"基本都是通过这个模式实现的":["22.2"],"同样适用于类组件和函数组件":["22.2"],"方便获取组件内部状态":["22.3"],"比如":["22.3"],"state":["22.3","35.5","35.9","38.4"],"props":["22.3","22.7","33.9","34.4","35.3","35.5"],"生命周期":["22.3"],"绑定的事件函数等":["22.3"],"②":["22.3"],"es6继承可以良好继承静态属性":["22.3"],"angular":["22.4"],"advance":["22.4"],"组件中":["22.5"],"在":["22.5","33.3"],"生命周期动态加载上述的路由组件component":["22.5"],"如果在切换路由或者没有加载完毕时":["22.5"],"显示的是":["22.5"],"效果":["22.5"],"组件赋能":["22.5"],"对于属性代理虽然不能直接获取组件内的状态":["22.5"],"但是可以通过":["22.5"],"div":["22.6","27.10","29.2","31.4","35.7"],"ref":["22.6"],"index":["22.6","23.8","32.2","33.6","34.6","35.9"],"authorization":["22.7","24.9"],"component":["22.7","35.9"],"home":["22.7","35.4"],"matchpermission":["22.7"],"list":["22.7"],"indexof":["22.7"],"usetransition":["23.1"],"concurrent模式下":["23.1"],"过渡更新任务":["23.1"],"结果是0":["23.3"],"react":["23.3","33.1","33.2","33.6","33.8"],"usestate获取到最新的number":["23.5"],"所以打印的值是最新的number":["23.5"],"人话":["23.5"],"点击button时触发的log和setnumber在第一任务线程":["23.5"],"第一线程执行完毕后执行第一线程引起的一系列任务":["23.5"],"外部在第二任务线程中执行的":["23.5"],"此时setnumber已执行完毕":["23.5"],"点击按钮后执行过程":["23.5"],"线程1":["23.5"],"handleclick":["23.5"],"宏任务log":["23.5"],"微任务setnumber":["23.5"],"触发线程2":["23.5"],"name":["23.6"],"switch":["23.6","38.4"],"case":["23.6","38.4","38.5"],"increment":["23.6"],"count":["23.6"],"demo":["23.8"],"jsx":["23.8","50.0"],"childref":["23.8"],"useref":["23.8"],"null":["23.8","34.5"],"click":["23.8"],"chcildref":["23.8"],"logger":["23.8"],"这在提高用户体验和性能方面很有帮助":["24.1"],"自动缓存失效处理":["24.1"],"当数据过期或需要刷新时":["24.1"],"可以自动处理缓存失效并重新获取数据":["24.1"],"无需手动编写过期和刷新逻辑":["24.1"],"服务器状态更新":["24.1"],"无数据预取":["24.2"],"usequery":["24.9"],"querykey":["24.9"],"owner":["24.9"],"repo":["24.9"],"repos":["24.9"],"issues":["24.9"],"headers":["24.9"],"成功或错误状态":["24.10"],"例如":["24.10","50.0"],"可以是字符串":["24.10"],"loading":["24.10"],"success":["24.10"],"或":["24.10"],"hashrouter":["25.0"],"memoryrouter":["25.0"],"好处":["25.0"],"formishalffilledout":["25.3"],"are":["25.3"],"you":["25.3"],"sure":["25.3"],"可在多个地方使用消费":["26.1","27.1"],"usestore":["26.1","27.1"],"这种双向的数据流动会导致数据的不一致和混乱":["26.3"],"难以调试和维护":["26.3"],"由于数据流动不可控":["26.3"],"它将应用程序分为四个主要部分":["26.4"],"br":["26.4"],"view":["26.4"],"视图":["26.4"],"负责渲染用户界面":["26.4"],"接收用户输入并将其发送给":["26.4"],"dispatcher":["26.4"],"redux":["27.3"],"v6完全基于context":["27.3"],"api而导致性能大幅下降":["27.3"],"v7又回退到之前的内部订阅方案":["27.3"],"context更适合放类似主题这种变化不大的全局数据":["27.3"],"依赖某个atom":["27.5"],"当依赖项发生变化时更新触发atom的第一个参数修改变量":["27.5","27.6"],"deriveatom":["27.5","27.6"],"async":["27.6"],"setvalue":["27.7"],"useatom":["27.7"],"text":["27.8"],"fc":["27.8"],"value":["27.8","29.1","33.9"],"await":["27.9"],"url":["27.9"],"setcount":["27.10"],"组件a渲染":["27.10"],"button":["27.10","35.7"],"onclick":["27.10","35.7"],"如果仅更新操作":["27.11"],"而无需渲染状态的组件":["27.11"],"状态是独立的":["27.12"],"不受外部影响":["27.12"],"同时也不影响外部":["27.12"],"任何组件都可以使用":["27.13"],"但是":["27.13"],"createroot":["27.14"],"document":["27.14"],"getelementbyid":["27.14"],"root":["27.14","35.11"],"render":["27.14","35.11"],"strictmode":["27.14"],"state的根对象":["28.1"],"dispatch":["28.1"],"使":["28.2"],"action":["28.2","38.4"],"可以为":["28.2"],"son":["29.1"],"style":["29.2","50.0"],"hooks":["31.0","35.6"],"里面的":["31.0"],"对于每一个":["31.1"],"effect":["31.1"],"callback":["31.1"],"执行是在浏览器绘制视图之后":["31.2"],"接下来又改":["31.2"],"就可能会导致浏览器再次回流和重绘":["31.2"],"而且由于两次绘制":["31.2"],"样式通过":["31.3"],"标签的形式插入到":["31.3"],"head":["31.3"],"标签里面":["31.3"],"动态生成的":["31.3"],"选择器会有一小段哈希值来保证全局唯一性来避免样式发生冲突":["31.3"],"这种模式下本质上是动态生成":["31.3"],"标签":["31.3"],"title":["31.3"],"组件销毁":["31.4"],"number":["31.4"],"tip":["32.4","33.3"],"执行过程":["32.4"],"函数调用时":["32.4"],"会返回一个":["32.4"],"对象":["32.4","33.2"],"element":["33.2"],"作用":["33.2"],"可以根据需要控制":["33.2"],"这种情况":["33.3"],"中":["33.3"],"判断是":["33.4"],"elment":["33.4"],"混入":["33.4"],"cloneelement":["33.4","33.8","35.1"],"一般不需要具体指出":["33.5"],"focus":["33.7"],"prop":["33.8"],"displayname":["33.9"],"混入props":["33.9"],"childrenitem":["33.9"],"onchange":["33.9"],"ref模式获取元素或组件":["34.1"],"childspanref":["34.2"],"newfather":["34.2"],"forwardrefindex":["34.3"],"gyqmsg":["34.5"],"setgyqmsg":["34.5"],"settogyqmsg":["34.5"],"传递函数":["34.5"],"调用子组件的方法":["34.5"],"current":["34.5","38.4"],"yq":["34.5"],"vue3":["34.6"],"id":["34.6"],"typeinfo":["34.6"],"controllcomponentrender":["35.1"],"通过此函数判断":["35.1"],"只有":["35.1"],"变化的时候":["35.1"],"重新创建":["35.1"],"的依赖项":["35.2"],"在函数组件下一次执行的时候":["35.2"],"会对比":["35.2"],"依赖项里面的状态":["35.2"],"是否有改变":["35.2"],"本质上":["35.3"],"createelement":["35.3"],"会产生一个新的":["35.3"],"这个":["35.3","35.6"],"将作为对应":["35.3"],"父组件":["35.4"],"numbera":["35.4"],"setnumbera":["35.4"],"usestate":["35.4"],"numberb":["35.4"],"setnumberb":["35.4"],"父组件改变props":["35.4"],"判断是否为纯函数":["35.5"],"如果是则进行浅比较shallowequal":["35.5"],"info":["35.5"],"shallowequal过程":["35.5"],"首先新老props":["35.5"],"states比较":["35.5"],"不相等重新生成element":["35.5"],"判断新老":["35.5"],"或者":["35.5"],"有不是对象或者为":["35.5"],"usememo":["35.6"],"解决这个问题":["35.6"],"首选":["35.6"],"初衷就是为了解决这种情况的":["35.6"],"setstate":["35.7"],"需要被包裹的组件":["35.8"],"this":["35.9"],"test":["35.9"],"第三种情况就是越是靠近":["35.11"],"程序了解到事件名以后去reducer中找到对应的函数执行操作":["38.1"],"当前state":["38.2"],"和触发的事件action":["38.2"],"tasks":["38.4"],"previous":["38.4"],"使用usereducer可以使状态变化变得可预测":["38.6"],"因为它通过一个reducer函数来处理状态变化":["38.6"],"可以更好地理解状态变化的来源":["38.6"],"中间件和副作用":["38.6"],"实际使用":["45.1"],"abstract":["45.1"],"不再强依赖一些属性和方法":["45.2"],"具体的实现方式是di依赖注入":["45.2"],"容器需要有一个解析的方法":["45.4"],"从容器中解析已注册的依赖项并注入":["45.4"],"throw":["45.5"],"split":["50.0"],"这样可得到一个数组":["50.0"],"如果我想把他拆分成一个对象该如何实现":["50.0"],"reg":["50.0"],"w":["50.0"],"s":["50.0"],"replace":["50.0"],"iframe":["50.0"],"height":["50.0"],"team":["51.0"]},{"0":["22.7"],"1":["27.10","31.3","31.4","35.7"],"2":["31.2"],"3":["26.3","28.1","35.5"],"4":["22.0","22.2"],"5":["23.3"],"6":["7.1","23.5"],"8":["23.5"],"15":["6.2"],"16":["6.2"],"18":["4.0"],"22":["12.2"],"28":["33.6"],"85":["12.2"],"89":["12.2"],"100":["50.0"],"10000":["10.8"],"实现无侵入业务式的编程":["1.0"],"express的中间件的洋葱模型也是一种aop的视线":["1.0"],"因为你可以透明的在外包一层":["1.0"],"加入一些逻辑":["1.0"],"内层感知不到":["1.0"],"而nest实现aop的方式很多":["1.0"],"进一步区分为全局中间件和路由中间件":["1.1"],"包含了响应的所有信息":["1.2"],"是一个函数":["1.2"],"用来执行下一个中间件":["1.2"],"apply":["1.3"],"loggermiddleware":["1.3"],"forroutes":["1.3"],"aaa":["1.3"],"code":["1.3","1.6"],"appmodule":["1.4","3.0"],"tip":["1.4","45.4"],"如果您仔细观察全局启用守卫中的代码后会注意两种全局注册的方式":["1.4"],"useglobalguards是手动注册的方式":["1.4"],"所以他并不在ioc容器中":["1.4"],"所以在守卫中无法使用依赖注入":["1.4"],"而app":["1.4"],"ts中的方式是通过依赖注入的方式注册的":["1.4"],"所以守卫中可以使用依赖注入":["1.4"],"可以访问请求上下文":["1.5"],"并对请求或响应进行更细粒度的控制":["1.5"],"它们拥有更大的控制权":["1.5"],"可以决定是否继续执行下一个拦截器或路由处理程序":["1.5"],"甚至可以完全替换方法的返回值":["1.5"],"简洁版":["1.5"],"他们都是到达请求之前的处理函数":["1.5"],"但是权限和作用不同":["1.5"],"interceptor权限更大":["1.5"],"因为他可以获取到请求的上下文":["1.5"],"而middleware只能获取到请求和响应对象":["1.5"],"在":["1.5"],"controller":["1.5","1.7","2.1","10.1","17.0"],"handler":["1.5"],"上加一些":["1.5"],"metadata":["1.5"],"这种就只有":["1.5"],"interceptor或者":["1.5"],"guard":["1.5"],"里可以取出来":["1.5"],"pipe不仅可以对某个参数生效":["1.6"],"也可以对整个controller":["1.6"],"全局生效":["1.6"],"group":["1.6"],"usepipes":["1.6"],"的调用时机很容易想到":["1.7"],"就是在响应之前对异常做一次处理":["1.7"],"image":["1.7"],"总结":["1.7"],"基于":["1.7"],"express":["1.7"],"这种":["1.7"],"平台做了一层封装":["1.7"],"应用了":["1.7"],"mvc":["1.7"],"ioc":["1.7"],"aop":["1.7"],"等架构思想":["1.7"],"mvc中请求先经过":["1.7"],"然后调用":["1.7"],"model":["1.7"],"层的":["1.7"],"service":["1.7"],"repository":["1.7"],"完成业务逻辑":["1.7"],"最后返回对应的":["1.7"],"view":["1.7"],"是指":["1.7"],"会自动扫描带有":["1.7"],"使用":["2.0"],"添加到模块或者控制器中":["2.0"],"module":["2.0","2.2"],"在canactivate":["2.1"],"方法中":["2.1"],"通过参数context获取到请求对象":["2.1"],"调用validaterequest":["2.1"],"函数验证请求是否合法":["2.1"],"如果请求合法就返回true":["2.1"],"要在控制器中使用守卫":["2.1"],"需要将守卫添加到路由上":["2.1"],"useguard":["2.1"],"ms":["2.2"],"写入模块中作为提供者":["2.2"],"imports":["2.2"],"安全性":["2.3"],"appcontroller":["3.0","10.3"],"不使用dotenv扩展包的话需要手动readfile然后根据":["3.0"],"n拆分":["3.0"],"循环放入process":["3.0"],"key":["3.0"],"太麻烦":["3.0"],"工厂函数":["3.0"],"对于复杂要求的provider":["3.0"],"我们就可以使用":["3.0"],"usefactory":["3.0"],"工厂函数进行提供者注册":["3.0"],"name":["4.0","12.1","12.2","22.4","33.6","33.7"],"process":["4.0"],"env":["4.0"],"app":["4.0","6.4"],"age":["4.0","12.2","33.6"],"最终统一导入到config":["4.0"],"index":["4.0","23.5","33.7","34.4"],"再统一导出":["4.0"],"总之控制权不在类中":["5.0"],"而是由外部决定":["5.0"],"play":["5.1"],"student":["5.1"],"动态模块":["6.0"],"全局模块":["6.0"],"pipe":["6.1"],"dto和请求参数等":["6.1"],"service提供一种实现业务逻辑的方式":["6.1"],"他可以访问操作数据":["6.1"],"控制器":["6.2"],"方法处理器":["6.2"],"请求之后":["6.2"],"可以使用":["6.3"],"exports":["6.3","10.2","16.1"],"导出给其他模块使用":["6.3"],"提供者是单例的4":["6.3"],"提供者可以是任何值":["6.3"],"token":["6.4"],"expiresin":["6.4"],"100d":["6.4"],"模块提供者":["6.4"],"filters":["7.1"],"处理请求时的错误":["7.1"],"守卫":["7.1"],"这个对象包含了当前请求的上下文信息":["8.0"],"包括请求头":["8.0"],"请求体":["8.0"],"nest的装饰器基本都是使用reflect":["9.0"],"metadata实现的":["9.0"],"这就是":["9.0"],"nest":["9.0"],"的核心实现原理":["9.0"],"通过装饰器给":["9.0"],"或者对象添加":["9.0"],"并且开启":["9.0"],"string":["10.1","10.7","15.1"],"any":["10.1","10.6"],"inject":["10.3"],"appservice":["10.3"],"private":["10.3"],"readonly":["10.3","10.5"],"get":["10.4","11.3","27.5"],"外":["10.4"],"还可以用":["10.4"],"put":["10.4"],"delete":["10.4"],"context":["10.5","29.1"],"executioncontext":["10.5"],"boolean":["10.5"],"promise":["10.5"],"observable":["10.5"],"record":["10.6"],"console":["10.7","34.3"],"use":["10.8"],"secret":["10.8"],"abc":["10.8"],"cookie":["10.8"],"maxage":["10.8"],"这么设计是为了避免你自己返回的响应和":["10.10"],"返回的响应的冲突":["10.10"],"如果你不会自己返回响应":["10.10"],"可以通过":["10.10"],"passthrough":["10.10"],"参数告诉":["10.10"],"你可以通过":["10.11"],"httpcode修改它":["10.11"],"fff":["10.11"],"httpcode":["10.11"],"return":["10.12","15.0","23.8","27.6","27.8","45.1"],"url":["10.12"],"异常":["11.0"],"t":["11.0","38.4"],"implements":["11.0","16.2"],"exceptionfilter":["11.0"],"else":["11.1","33.4"],"ws":["11.1"],"rpc":["11.1"],"为异常的实例":["11.1"],"主机参数":["11.1"],"分辨":["11.1"],"这个executioncontext是argumentshost的子类":["11.2"],"扩展了":["11.2"],"requiredroles":["11.3"],"this":["11.3"],"roles":["11.3"],"if":["11.3"],"switchtows":["11.4"],"swtichtorpc":["11.4"],"然后再取对应的":["11.4"],"argument":["11.4"],"而":["11.4"],"encode":["12.0"],"e5":["12.2"],"因为内容是表单搜索":["12.2"],"所以跟query差不多":["12.2"],"都需要urlencoded编译一下":["12.2"],"然后指定":["12.3"],"也就是分割线":["12.3"],"body":["12.3"],"不需要用这两种":["12.4"],"可以直接指定content":["12.4"],"type":["12.4"],"后端代码同样使用":["12.5"],"来接收":["12.5"],"不需要做啥变动":["12.5"],"和":["12.5","35.6"],"都是从":["12.5"],"取值":["12.5"],"内部会根据":["12.5"],"做区分":["12.5"],"使用不同的解析方式":["12.5"],"前端post默认请求头是application":["12.5"],"所以不需要指定content":["12.5"],"json和form":["12.5"],"urlencode不适合大文件传输":["12.5"],"data适合":["12.5"],"根据头信息":["14.0"],"role":["15.0"],"data":["15.1"],"ctx":["15.1"],"这个模块":["16.0"],"acontroller":["16.1"],"ccc":["16.2"],"export":["16.2","31.4","33.9","34.3"],"class":["16.2","34.2"],"ccccontroller":["16.2"],"constructor":["16.2"],"如onapplicationshutown里通过moduleref":["16.3"],"get取出一些provider":["16.3"],"执行关闭连接等销毁逻辑":["16.3"],"auth":["17.0","45.1"],"我是a":["17.1"],"hello":["17.2","22.4","22.6"],"gethello":["17.2"],"host":["17.3"],"localhost":["17.3"],"port":["17.3"],"灵活运用这些":["17.4"],"provider":["17.4"],"类型":["17.4"],"加入":["22.0"],"loading":["22.0","32.2","50.0"],"效果":["22.0"],"两者之间有一些共性和区别":["22.1"],"可以完全隔离业务组件的渲染":["22.2"],"因为属性代理说白了是一个新的组件":["22.2"],"相比反向继承":["22.2"],"可以完全控制业务组件是否渲染":["22.2"],"可以嵌套使用":["22.2"],"多个":["22.2"],"是可以嵌套使用的":["22.2"],"而且一般不会限制包装":["22.2"],"所以无须对静态属性和方法进行额外的处理":["22.3"],"缺点":["22.3"],"函数组件无法使用":["22.3"],"和被包装的组件耦合度高":["22.3"],"需要知道被包装的原始组件的内部状态":["22.3"],"具体做了些什么":["22.3"],"otherprops":["22.4"],"alien":["22.4","33.6"],"替换":["22.4"],"元素节点":["22.4"],"appendelement":["22.4"],"createelement":["22.4"],"world":["22.4"],"my":["22.4"],"ref":["22.5"],"获取组件实例":["22.5"],"获取到组件实例":["22.5"],"就可以获取组件的一些状态":["22.5"],"或是手动触发一些事件":["22.5"],"进一步强化组件":["22.5"],"但是注意的是":["22.5"],"类组件才存在实例":["22.5"],"函数组件不存在实例":["22.5"],"hoc":["22.5"],"react":["22.6","33.3","34.2","35.3"],"render":["22.6","35.9"],"classname":["22.6"],"p":["22.6"],"匹配权限":["22.7"],"consumer":["22.7","29.2"],"permissionlist":["22.7"],"usedeferredvalue":["23.1"],"解决更新状态滞后问题":["23.1"],"const":["23.3","45.5"],"indexref":["23.3"],"function":["23.3","23.5","28.2","34.3"],"线程2":["23.5"],"微任务setnumber触发重新渲染":["23.5"],"这就是为什么handleclick函数内打印不到最新的值":["23.5"],"而handleclick函数外可以大打印到最新的值的原因":["23.5"],"js":["23.5","50.0"],"number":["23.5"],"setnumber":["23.5","31.4"],"decrement":["23.6"],"default":["23.6","31.4","33.9","34.3","50.0"],"throw":["23.6"],"new":["23.6"],"error":["23.6","45.5"],"form":["23.8"],"button":["23.8","27.7","31.4","35.9"],"onclick":["23.8","31.4","35.9"],"myform":["23.8"],"对于需要与服务器状态同步的情况":["24.1"],"可以通过提供的无缝数据同步功能来处理":["24.1"],"确保客户端数据的一致性":["24.1"],"更少的重复代码":["24.1"],"无数据失效处理":["24.2"],"inputowner":["24.9"],"setinputowner":["24.9"],"facebook":["24.9"],"inputrepo":["24.9"],"setinputrepo":["24.9"],"setquerykey":["24.9"],"issuccess":["24.10"],"表示查询是否成功完成":["24.10"],"如果查询成功完成":["24.10"],"页面松耦合":["25.0"],"lazyload":["25.0"],"want":["25.3"],"leave":["25.3"],"redirect":["25.3"],"重定向":["25.3"],"atomic":["26.1","27.1"],"state":["26.1","27.1","31.4"],"原子状态":["26.1","27.1"],"当应用程序发生错误或状态异常时":["26.3"],"很难定位问题的根源并进行调试和修复":["26.3"],"嵌套回调和依赖关系":["26.3"],"调度器":["26.4"],"负责接收来自":["26.4"],"的动作":["26.4"],"并将它们分发给注册的":["26.4"],"而并不适合存放频繁更新的复杂状态集合":["27.3"],"原子化":["27.3"],"组件内状态":["27.3"],"但是api较多":["27.3"],"使用atom":["27.5"],"await":["27.6"],"text":["27.6","27.9","31.3"],"div":["27.7","33.9"],"useatom":["27.8","27.9","27.14"],"addnumber":["27.8"],"fc":["27.9"],"value":["27.9"],"prev":["27.10"],"add":["27.10"],"b":["27.10"],"count":["27.10"],"请使用":["27.11"],"即使大家共用同一个atom状态":["27.12"],"如果不想让这个组件受外部更新影响":["27.12"],"如果某个组件使用了provider包裹":["27.13"],"那么该组件的状态是独立的":["27.13"],"getdefaultstore":["27.14"],"useatomvalue":["27.14"],"num":["27.14"],"num2":["27.14"],"navstore":["27.14"],"更新store中的state":["28.1"],"subscribe":["28.1"],"enhancer":["28.2"],"提供者":["29.0"],"themeconsumer":["29.0"],"作用有两个":["29.1"],"属性传递":["29.1"],"消费者":["29.2"],"订阅者之consumer":["29.2"],"订阅者采取":["29.2"],"props":["29.2","34.2"],"接受最近一层":["29.2"],"中value":["29.2"],"作为":["29.2"],"函数的参数":["29.2"],"可以将参数取出来":["29.2"],"useeffect":["31.0","34.3"],"会向":["31.1"],"settimeout回调函数一样":["31.1"],"放入任务队列":["31.1"],"等到主线程任务完成":["31.1"],"dom":["31.1"],"视图上可能会造成闪现突兀的效果":["31.2"],"callback":["31.2"],"中代码执行会阻塞浏览器绘制":["31.2"],"h1":["31.3"],"font":["31.3"],"size":["31.3"],"5em":["31.3"],"align":["31.3"],"center":["31.3"],"color":["31.3"],"bf4f74":["31.3"],"wrapper":["31.3"],"section":["31.3"],"padding":["31.3"],"states":["31.4"],"改变state":["31.4","35.7"],"isrender":["31.4"],"setrender":["31.4"],"传统模式":["32.2"],"挂载组件":["32.2"],"请求数据":["32.2"],"再渲染组件":["32.2"],"当组件渲染的时候":["32.4"],"返回的":["32.4"],"会被":["32.4"],"捕获":["32.4"],"然后显示":["32.4"],"log":["33.1","34.3"],"props改变":["33.1"],"是否渲染":["33.2"],"可以用":["33.2"],"属性访问到是函数":["33.3"],"并不是":["33.3"],"element":["33.3"],"对象":["33.3"],"针对这种情况":["33.3"],"像下面这种情况下":["33.3"],"typeof":["33.4"],"中某个属性":["33.5"],"而是将":["33.5"],"indexprops":["33.6","33.7"],"children":["33.8"],"mes":["33.8"],"push":["33.9"],"123s":["33.9"],"json":["33.9"],"stringify":["33.9"],"ref是一个对象":["34.1"],"forwardref":["34.2"],"father":["34.2"],"grandref":["34.2"],"父组件":["34.2"],"extends":["34.2"],"home":["34.3"],"useref":["34.3"],"prop":["34.4"],"对yq说":["34.5"],"changetype":["34.6"],"info":["34.6","35.6"],"current":["34.6"],"的改变":["34.6"],"不需要视图变化":["34.6"],"如果有改变重新执行":["35.2"],"得到新的缓存值":["35.2"],"返回值":["35.2"],"pendingprops":["35.3"],"在此":["35.3"],"更新调和阶段":["35.3"],"会对比":["35.3"],"上老":["35.3"],"oldprops":["35.3"],"和新的":["35.3"],"改变numbera":["35.4"],"改变numberb":["35.4"],"对于props":["35.4"],"null":["35.5"],"的":["35.5"],"那么直接返回":["35.5"],"false":["35.5","38.4"],"更新组件":["35.5"],"通过":["35.5"],"object":["35.5"],"keys":["35.5"],"将新老":["35.5"],"或者新老":["35.5"],"handercallback":["35.6"],"usecallback接受两个参数":["35.6"],"第一个参数是需要缓存的函数":["35.6"],"第二个参数为deps":["35.6"],"如果deps内依赖项改变返回新的函数":["35.6"],"numa":["35.7"],"比较函数":["35.8"],"用来判断是否需要更新":["35.8"],"setstate":["35.9"],"如果组件依赖于context":["35.10"],"那么当context发生变化时":["35.10"],"根组件越值得注意":["35.11"],"根组件渲染会波及到整个组件树重新":["35.11"],"子组件":["35.11"],"这样的优点就是把操作整合到一起":["38.1"],"只需要知道用户执行了什么操作去reducer中寻找响应的程序而不是直接触发这些程序":["38.1"],"然后返回新的state":["38.2"],"done":["38.4"],"changed":["38.4"],"tasksk":["38.4"],"map":["38.4"],"initstate":["38.5"],"接收接受个初始值":["38.5"],"和状态计算函数":["38.5"],"返回的dispatch来调用状态计算函数":["38.5"],"通过usestate保存状态":["38.5"],"usereducer可以配合副作用和中间件来处理状态变化时的特定逻辑":["38.6"],"使得状态管理更加灵活":["38.6"],"复杂动态表单":["38.6"],"在处理复杂的动态表单或用户输入场景时":["38.6"],"void":["45.1"],"authservice":["45.1"],"控制反转需要一个容器":["45.2"],"配置集中管理":["45.3"],"让所有的依赖项统一管理注册解耦了对象之间的强依赖关系":["45.4"],"依赖":["45.5"],"未被注册到容器":["45.5"],"请先注册到容器再去使用":["45.5"],"注册":["45.5"],"width":["50.0"],"scrolling":["50.0"],"no":["50.0"],"title":["50.0"],"untitled":["50.0"],"src":["50.0"],"https":["50.0"],"codepen":["50.0"],"io":["50.0"],"woskvxzd":["50.0"],"the":["50.0"],"animator":["50.0"],"embed":["50.0"],"qwymdbq":["50.0"],"tab":["50.0"],"2cresult":["50.0"],"frameborder":["50.0"]},{"0":["23.5","23.8"],"1":["23.3","34.3","34.5","35.9"],"2":["23.1"],"4":["23.3","26.3","35.5"],"5":["28.1"],"7":["7.1"],"17":["6.2"],"18":["6.2"],"20":["12.1"],"28":["33.7"],"222":["10.11"],"6379":["17.3"],"1231231231":["12.5"],"middleware":["1.0","1.7"],"中间件":["1.0"],"gurad":["1.0"],"守卫":["1.0"],"pipe":["1.0"],"管道":["1.0"],"放行请求":["1.2"],"不写的话":["1.2"],"请求就会被挂起":["1.2"],"path":["1.3","25.3"],"inject":["1.4"],"private":["1.4","2.1","16.2","17.0"],"readonly":["1.4","2.1","16.2","17.0"],"不行":["1.5"],"interceptor支持每个路由单独启用":["1.5"],"只作用于某个handler":["1.5"],"get":["1.5","2.1","10.3","12.2"],"bbb":["1.5"],"useinterceptors":["1.5","12.5"],"string":["1.5"],"也可以在controller级别启动":["1.5"],"作用于下面的全部handler":["1.5"],"appcontroller":["1.5","2.1","2.2"],"main":["1.6"],"js":["1.6","31.1"],"app":["1.6","2.2"],"useglobalpipes":["1.6"],"validatepipes":["1.6"],"module":["1.6","4.0"],"providers":["1.6","2.2","6.4"],"装饰器的类":["1.7"],"创建它们的对象":["1.7"],"并根据依赖关系自动注入它依赖的对象":["1.7"],"免去了手动创建和组装对象的麻烦":["1.7"],"则是把通用逻辑抽离出来":["1.7"],"通过切面的方式添加到某个地方":["1.7"],"可以复用和动态增删切面逻辑":["1.7"],"的":["1.7","17.4","35.4"],"guard":["1.7"],"interceptor":["1.7","2.2"],"思想的实现":["1.7"],"只不过是不同位置的切面":["1.7"],"它们都可以灵活的作用在某个路由或者全部路由":["1.7"],"这就是":["1.7"],"的优势":["1.7"],"我们通过源码来看了它们的调用顺序":["1.7"],"是":["1.7"],"的概念":["1.7"],"constructor":["2.1","5.1","17.0","22.5","31.4","34.2"],"appservice":["2.1","2.2","10.1"],"useguards":["2.1"],"eagonguard":["2.1"],"controllers":["2.2","6.4","17.1","17.2"],"provide":["2.2"],"可维护性":["2.3"],"xjclass":["3.0"],"make":["3.0"],"return":["3.0","11.3","15.1","27.9","27.14","34.6"],"this":["3.0","10.5"],"is":["3.0","22.4"],"method":["3.0","9.0"],"hd":["3.0"],"依赖注入其他提供者":["3.0"],"注册到全局module":["4.0"],"imports":["4.0"],"configmodule":["4.0"],"forroot":["4.0"],"isglobal":["4.0"],"true":["4.0","10.10","11.3","31.4","50.0"],"load":["4.0"],"controller":["4.0","11.2"],"内部仅仅调用一个抽象的方法":["5.0"],"具体的方法实现由第三方决定":["5.0"],"protected":["5.1"],"env配置相关":["6.0"],"同事还可以与其他服务交互以完成复杂的业务逻辑":["6.1"],"service是处理应用程序逻辑的类":["6.1"],"将业务逻辑从controller中分离出来":["6.1"],"使得controller只需处理http请求和响应":["6.1"],"控制器拦截器":["6.2"],"异常过滤器":["6.2"],"而不仅仅是服务类":["6.3"],"提供者是":["6.3"],"nestjs":["6.3"],"应用程序中的核心概念之一":["6.3"],"它们将代码块标记为可注入的":["6.3"],"authservice":["6.4","45.5"],"jwtstrategy":["6.4"],"控制器":["6.4"],"authcontroller":["6.4","17.1","17.2"],"向外提供接口":["6.4"],"guards":["7.1"],"鉴权认证相关":["7.1"],"拦截器":["7.1"],"查询参数":["8.0"],"响应对象等":["8.0"],"emitdecoratormetadata":["9.0"],"来自动添加类型相关的":["9.0"],"然后运行的时候通过这些元数据来实现依赖的扫描":["9.0"],"对象的创建等等功能":["9.0"],"的装饰器都是依赖":["9.0"],"实现的":["9.0"],"而且还提供了一个":["9.0"],"setmetadata":["9.0"],"的装饰器让我们可以给":["9.0"],"添加一些":["9.0"],"export":["10.2","16.1","22.6","27.6","34.4"],"class":["10.2","16.1","22.7"],"usefilter":["10.3"],"gethello":["10.3"],"void":["10.3"],"if":["10.3","34.6","38.4"],"xxx":["10.3"],"throw":["10.3"],"patch":["10.4"],"options":["10.4"],"head":["10.4"],"装饰器分别接受":["10.4"],"handleroles":["10.5"],"gethandler":["10.5","11.4"],"classroles":["10.5"],"console":["10.6","11.0","23.5","23.8","34.4"],"log":["10.6","10.7","11.0","23.5","34.4"],"会返回":["10.8"],"set":["10.8"],"的响应头":["10.8"],"设置了":["10.8"],"包含":["10.8"],"此时只有host满足xx":["10.9"],"1才能路由到这个controller":["10.9"],"hello":["10.11","31.3"],"修改header":["10.11"],"https":["10.12"],"www":["10.12"],"host":["11.0"],"argumentshost":["11.0"],"过滤器异常":["11.0"],"public":["11.0"],"等不同上下文":["11.1"],"argumenthost":["11.1"],"是用于切换":["11.1"],"等上下文类型的":["11.1"],"可以根据上下文类型取到对应的":["11.1"],"argument":["11.1"],"image":["11.1"],"没截到":["11.1"],"参数arg里的就是当前上下文的参数":["11.1"],"next":["11.1"],"getargs":["11.1"],"方法":["11.2","11.4"],"获取当前上下文的类":["11.2"],"获取当前请求上下文的用户信息":["11.3"],"user":["11.3","45.1"],"switchtohttp":["11.3"],"getrequest":["11.3"],"如果用户角色包含目标方法的元数据":["11.3"],"就放行":["11.3"],"还提供":["11.4"],"getclass":["11.4"],"将":["12.0"],"编译":["12.0"],"光":["12.1"],"age":["12.1"],"e5":["12.1"],"是把数据拼成":["12.2"],"query":["12.2"],"字符串放在":["12.2"],"url":["12.2"],"后面":["12.2"],"于是表单的":["12.2"],"提交方式的时候就直接用相同的方式把数据放在了":["12.2"],"body":["12.2"],"里面就是用":["12.3"],"分隔符分割的内容":["12.3"],"很明显":["12.3"],"这种方式适合传输文件":["12.3"],"为":["12.4"],"application":["12.4"],"data是用":["12.5"],"作为分割传输":["12.5"],"multipart":["12.5"],"boundary":["12.5"],"nest解析":["12.5"],"formdata":["12.5"],"使用":["12.5","29.1","45.5"],"filesinterceptor拦截器":["12.5"],"用":["12.5","32.4"],"useinterceptors装饰器启用":["12.5"],"让后通过":["12.5"],"upload":["12.5"],"edfiles取":["12.5"],"同样是":["12.5"],"body获取":["12.5"],"file":["12.5"],"anyfilesinterceptor":["12.5"],"dest":["12.5"],"uploads":["12.5"],"body2":["12.5"],"载荷":["14.0"],"签名规则":["14.0"],"aaa":["15.0"],"也可以直接把这个模块设置为全局模块":["16.0"],"这样就不需要":["16.0"],"cccservice":["16.2"],"生命周期":["16.2"],"作用":["16.2"],"初始化":["16.2"],"全局模块":["16.3"],"声明周期":["16.3"],"或者":["17.0"],"这个":["17.2"],"await":["17.3"],"connect":["17.3"],"就可以利用":["17.4"],"nest":["17.4"],"ref":["22.0","22.2"],"来获取原始组件实例":["22.0"],"操作实例下的属性和方法":["22.0"],"接下来分别介绍一下两种模式下的高阶组件":["22.1"],"的先后顺序":["22.2"],"缺点":["22.2"],"一般无法直接获取原始组件的状态":["22.2"],"如果想要获取":["22.2"],"需要":["22.2"],"获取组件实例":["22.2"],"③":["22.3"],"如果多个反向继承":["22.3"],"嵌套在一起":["22.3"],"当前状态会覆盖上一个状态":["22.3"],"这样带来的隐患是非常大的":["22.3"],"比如说有多个":["22.3"],"componentdidmount":["22.3","32.2"],"newchild":["22.4"],"children":["22.4"],"map":["22.4","34.6"],"child":["22.4"],"wrapcomponent":["22.5"],"super":["22.5","34.2"],"node":["22.5","34.4"],"获取实例":["22.5"],"world":["22.6","31.3"],"button":["22.6","27.8","27.9"],"组件内部点击":["22.6"],"default":["22.6","34.4"],"writedoc":["22.7"],"绑定文档录入页面":["22.7"],"extends":["22.7"],"writetag":["22.7"],"执行副作用":["23.1"],"b1":["23.1"],"这是分类b下的项目b1":["23.1"],"current":["23.3"],"每个回调函数捕获正确的值":["23.3"],"造成此结果的原因是当循环时":["23.3"],"每次循环执行的settimeout都会在一秒钟后执行":["23.3"],"当一秒钟后执行时当前的i已经是10了":["23.3"],"重新渲染":["23.5"],"reducertest":["23.6"],"number":["23.6","33.1"],"dispatchnumber":["23.6"],"initialstate":["23.6"],"count":["23.8","27.14"],"setcount":["23.8","27.14"],"usestate":["23.8","35.1","38.5"],"你可以通过一些简单的":["24.1"],"hooks":["24.1"],"和配置来处理数据获取和管理":["24.1"],"减少了编写重复代码的工作量":["24.1"],"总之":["24.1","38.6"],"尽管可以使用普通的数据获取库来处理数据请求":["24.1"],"但":["24.1"],"无服务器状态更新等问题":["24.2"],"issuequery":["24.9"],"span":["24.9"],"仓库":["24.9"],"input":["24.9"],"name":["24.9"],"value":["24.9","27.5","27.6"],"onchange":["24.9"],"e":["24.9"],"target":["24.9"],"isfetching":["24.10"],"表示是否正在获取数据":["24.10"],"无论是从远程服务器还是从缓存中":["24.10"],"如果正在获取数据":["24.10"],"之类的可以基于路由实现":["25.0"],"重构":["25.0"],"维护":["25.0"],"例如登录判断":["25.3"],"router":["25.3"],"render":["25.3","31.3","34.2"],"logged":["25.3"],"与创建对象形式的存储不同":["26.1","27.1"],"针对每一个变量可以是响应式的":["26.1","27.1"],"通过原子派生的方式来适应复杂的开发场景":["26.1","27.1"],"在复杂的应用程序中":["26.3"],"数据流动可能涉及多个嵌套的回调函数和依赖关系":["26.3"],"这会导致代码的可读性和可维护性下降":["26.3"],"数据存储":["26.4"],"负责管理应用程序的状态和逻辑":["26.4"],"接收来自":["26.4"],"的动作并更新自身的状态":["26.4"],"它通过将原子状态进行派生":["27.3"],"组合成新的状态":["27.3"],"类似vue的computed":["27.3"],"所谓组件内状态":["27.3"],"其实就是内部使用了usestate":["27.3"],"text":["27.5"],"div":["27.6","27.8","27.9","27.14","34.2","34.6"],"onclick":["27.7","27.8","27.9"],"addnumber":["27.9"],"组件b渲染":["27.10"],"p":["27.10"],"组件b":["27.10"],"这么做的目的":["27.11"],"防止无意义的渲染":["27.11"],"这样就不会触发更新了":["27.12"],"不受外部影响":["27.13"],"同时也不影响外部":["27.13"],"status":["27.14"],"style":["27.14"],"background":["27.14","31.3"],"pink":["27.14"],"black":["27.14"],"订阅":["28.1"],"监听store中的state变化":["28.1"],"增强器":["28.2"],"动作":["28.2"],"供给":["29.1"],"consumer":["29.1"],"属性改变":["29.1"],"混入":["29.2"],"组件":["29.2","33.6"],"说白了就是":["29.2"],"变成了":["29.2"],"themeconsumer":["29.2"],"订阅消费者":["29.2"],"和":["31.0"],"uselayouteffect":["31.0"],"更新":["31.1"],"执行完成":["31.1"],"视图绘制完毕":["31.1"],"才执行":["31.1"],"一句话概括如何选择":["31.2"],"修改":["31.2"],"4em":["31.3"],"papayawhip":["31.3"],"这个是时候":["31.3"],"的作用就出现了":["31.3"],"的执行在":["31.3"],"改变props":["31.4"],"br":["31.4"],"false":["31.4"],"卸载组件":["31.4"],"做数据初始化":["31.4"],"将滑动处理函数":["31.4"],"异步模式":["32.2"],"渲染组件":["32.2"],"异步组件的好处":["32.2"],"不再需要":["32.2"],"或":["32.2"],"useeffect":["32.2","34.4","35.11"],"指定的组件":["32.4"],"等待":["32.4"],"加载组件完成后":["32.4"],"再渲染真正的组件":["32.4"],"动态引入":["32.4"],"cloneelement":["33.2"],"强化":["33.2"],"混入新的":["33.2"],"是不能直接渲染的":["33.3"],"直接渲染会报错":["33.3"],"details":["33.3"],"view":["33.3"],"the":["33.3"],"code":["33.3"],"null":["33.4","34.4"],"index":["33.4"],"直接传入或者是抽离到子组件中":["33.5"],"组件一方面直接将":["33.6"],"alien":["33.7"],"mes":["33.7"],"let":["33.7"],"us":["33.7"],"区别":["33.8","35.6"],"显示注入在dom":["33.8"],"view内可以直接看到":["33.8"],"隐式注入再函数内使用cloneelemnt":["33.8"],"item":["33.9","34.6"],"createref":["34.1"],"component":["34.2"],"son":["34.2","34.5"],"如上代码所示":["34.3"],"流程主要分为几个方面":["34.3"],"通过":["34.3"],"创建一个":["34.3"],"对象":["34.3"],"将当前":["34.3"],"对象传递给子组件":["34.3"],"hocindex":["34.4"],"useref":["34.4"],"函数没有实例":["34.5"],"所以使用useimperativehandle":["34.5"],"里面传递参数模拟类组件实例":["34.5"],"forwawrdref使函数组件可以被ref获取实例":["34.5"],"这样的话其实跟类组件的性质是一样的":["34.5"],"sonmes":["34.5"],"setsonmes":["34.5"],"useimperativehandle创建实例方法":["34.5"],"第一个参数是要传递的ref对象":["34.5"],"第二个参数是一个函数":["34.5"],"第三个参数是一个数组":["34.5"],"数组中的值发生变化时":["34.5"],"才会重新执行第二个参数的函数":["34.5"],"sonrtate":["34.5"],"添加依赖项":["34.6"],"使用react提供的usememo优化":["35.1"],"setnumbera":["35.1"],"setnumberb":["35.1"],"usememo":["35.1"],"执行":["35.2"],"的返回值":["35.2"],"如果":["35.2"],"中有依赖项改变":["35.2"],"newprop":["35.3"],"是否相等":["35.3"],"如果相等函数组件就会放弃子组件的调和更新":["35.3"],"从而子组件不会重新渲染":["35.3"],"如果上述把":["35.3"],"对象缓存起来":["35.3"],"上面":["35.3"],"会浅比较":["35.4"],"如果相等则不会重新渲染":["35.4"],"否则重新渲染":["35.4"],"对于state":["35.4"],"浅比较只会比较基础数据类型":["35.4"],"对于引用类型":["35.4"],"比如":["35.4"],"demo":["35.4"],"中":["35.4"],"单纯的改变":["35.4"],"的属性名":["35.5"],"key":["35.5"],"变成数组":["35.5"],"判断数组的长度是否相等":["35.5"],"证明有属性增加或者减少":["35.5"],"那么更新组件":["35.5"],"遍历老":["35.5"],"或者老":["35.5"],"判断对应的新":["35.5"],"usecallback返回的是一个记忆化的回调函数":["35.6"],"只有当依赖项发生变化时":["35.6"],"回调函数才会改变":["35.6"],"这可以防止不必要的组件重新渲染":["35.6"],"例如":["35.6"],"如果你有一个经常重新渲染的父组件":["35.6"],"其中有一个子组件接收一个函数属性":["35.6"],"那么usecallback就非常有用":["35.6"],"因为它可以确保只有当函数的依赖项改变时":["35.6"],"函数才会被重新创建":["35.6"],"相反":["35.6"],"usememo返回的是一个记忆化的值":["35.6"],"这个值是运行函数的结果":["35.6"],"只有当依赖项改变时":["35.6"],"numb":["35.7"],"可以通过新老props":["35.7"],"state比较":["35.7"],"判断是否渲染":["35.7"],"但是如果是引用类型":["35.7"],"比如对象":["35.7"],"返回true则不更新":["35.8"],"返回false则更新":["35.8"],"组件会重新渲染":["35.10"],"不会走shouldcomponentupdate":["35.10"],"一是浪费性能":["35.11"],"二是可能执行":["35.11"],"更加符合常理":["38.1"],"这样action行为会随着时间的推移积累到状态中":["38.2"],"task":["38.4"],"else":["38.4"],"setstate":["38.5"],"function":["38.5"],"usereducer可以帮助更好地处理不同字段的状态变化":["38.6"],"usereducer适用于需要更精细控制状态逻辑":["38.6"],"处理复杂状态变化":["38.6"],"instance":["45.1"],"constroller":["45.1"],"这个容器接手类的控制权":["45.2"],"注册的时候不需要一个一个new生成多个实例了":["45.4"],"而是直接调用实例方法进行注册":["45.4"],"lazy":["50.0"],"allowtransparency":["50.0"],"allowfullscreen":["50.0"],"see":["50.0"],"pen":["50.0"],"a":["50.0"],"href":["50.0"],"by":["50.0"],"耿延":["50.0"]},{"0":["24.9"],"1":["23.8","24.9","27.14"],"2":["23.3","34.3"],"3":["33.9"],"5":["22.0"],"19":["6.2"],"85":["12.1"],"89":["12.1"],"123":["27.14"],"3000":["1.2"],"interceptor":["1.0","1.6"],"拦截器":["1.0"],"exceptionfilter":["1.0"],"异常过滤器":["1.0"],"listen":["1.2"],"method":["1.3"],"requestmethod":["1.3"],"get":["1.3"],"this":["1.4"],"gethello":["1.4","2.1","10.11"],"所以":["1.4","31.1"],"当需要注入别的":["1.4"],"provider":["1.4","17.2"],"的时候":["1.4"],"就要用第二种全局":["1.4"],"的声明方式":["1.4"],"也可以作用于全局":["1.5"],"main":["1.5"],"app":["1.5"],"useglobalinterceptors":["1.5"],"new":["1.5","10.3"],"module":["1.5"],"imports":["1.5"],"controllers":["1.5"],"providers":["1.5"],"appservice":["1.5"],"provide":["1.5","1.6"],"useclass":["1.5","1.6","2.2"],"第二种方式跟guard作用相同":["1.5"],"不管是":["1.6"],"guard":["1.6"],"还是最终调用的":["1.6"],"过程中都可以抛出一些异常":["1.6"],"如何对某种异常做出某种响应呢":["1.6"],"在最外层":["1.7"],"到了某个路由之后":["1.7"],"会先调用":["1.7"],"用于判断路由有没有权限访问":["1.7"],"然后会调用":["1.7"],"对":["1.7"],"contoller":["1.7"],"前后扩展一些逻辑":["1.7"],"在到达目标":["1.7"],"之前":["1.7"],"还会调用":["1.7"],"来对参数做检验和转换":["1.7"],"所有的":["1.7"],"的异常都会被":["1.7"],"处理":["1.7"],"返回不同的响应":["1.7"],"就是通过这种":["1.7"],"的架构方式":["1.7"],"实现了松耦合":["1.7"],"易于维护和扩展的架构":["1.7"],"在上面的代码中":["2.0"],"我们将loggermiddleware中间件添加到了appmodule模块中":["2.0"],"并使用forroutes":["2.0"],"方法指定了该中间件适用于所有路由":["2.0"],"这样":["2.0"],"每次请求到达控制器之前":["2.0"],"都会先执行loggermiddleware中间件中的代码":["2.0"],"string":["2.1","11.0"],"将authguard守卫添加到路由上":["2.1"],"并使用":["2.1"],"装饰器指定守卫":["2.1"],"这样每次请求到达控制器之前都会先执行authguard守卫中的代码":["2.1"],"以确保请求的合法性":["2.1"],"appmodule":["2.2","10.2"],"管道的应用场景":["2.3"],"将做为参数传递给":["3.0"],"方法":["3.0","11.1"],"authcontroller":["3.0"],"authmodule":["3.0","6.4"],"constroctor":["4.0"],"直接注入":["4.0"],"传递泛型类型":["4.0"],"configtype会提供类型":["4.0"],"而不需要处理业务逻辑":["6.1"],"在service中":["6.1"],"可以编写业务逻辑和调用其他服务":["6.1"],"路由":["6.2"],"之后是控制器":["6.2"],"之后是全局":["6.2"],"服务器响应":["6.2"],"并提供与其它代码块之间的依赖关系":["6.3"],"当需要在组件或控制器中使用一个实例时":["6.3"],"会自动处理依赖关系并将实例提供给需要的组件或控制器":["6.3"],"exports":["6.4"],"export":["6.4","22.4","23.5","23.8","27.10","38.5"],"class":["6.4"],"interceptors":["7.1"],"处理http请求前后所执行的逻辑":["7.1"],"executioncontext只在当前请求有效":["8.0"],"不可以和其他请求共享":["8.0"],"todo":["9.0"],"https":["9.0"],"juejin":["9.0"],"cn":["9.0"],"book":["9.0"],"7226988578700525605":["9.0"],"section":["9.0"],"7235075295521275965":["9.0"],"enter":["9.0"],"from":["9.0"],"course":["9.0"],"center":["9.0"],"utm":["9.0"],"source":["9.0"],"xxxx":["10.3"],"httpstatus":["10.3"],"bad":["10.3"],"request":["10.3"],"请求":["10.4"],"getclass":["10.5"],"return":["10.5","17.3","23.5","27.5","33.3"],"true":["10.5"],"sid":["10.8"],"也就是":["10.8"],"sesssionid":["10.8"],"之后每次请求都会自动带上这个":["10.8"],"里的参数就可以通过":["10.9"],"取出来":["10.9"],"end":["10.10"],"ddd":["10.10"],"注入request后可以手动取任何参数":["10.10"],"ggg":["10.11"],"header":["10.11"],"aaa":["10.11"],"bbb":["10.11"],"a":["11.0"],"b":["11.0"],"触发了aaaexception异常":["11.0"],"自定义异常":["11.0"],"方法就是取出当前上下文的":["11.1"],"reqeust":["11.1"],"如果是":["11.1"],"基于":["11.1"],"tcp":["11.1"],"的微服务等上下文":["11.1"],"就分别调用":["11.1"],"swtichtows":["11.1"],"switchtorpc":["11.1"],"获取当前上下文的方法":["11.2"],"controller下的方法":["11.2"],"image":["11.2"],"some":["11.3"],"includes":["11.3"],"可以结合":["11.4"],"reflector":["11.4"],"来取出其中的":["11.4"],"metadata":["11.4"],"里":["12.2"],"tip":["12.2","23.3"],"通过":["12.2","33.4"],"分割的数据需要encoded编译一下":["12.2"],"如果大量的数据那么都需要去编译":["12.2"],"太耗费资源和时间":["12.2"],"所以需要更好的方式来传递大量数据form":["12.2"],"data":["12.2","24.9"],"而且可以传输多个文件":["12.3"],"但是毕竟多了一些只是用来分隔的":["12.3"],"所以请求体会增大":["12.3"],"就行":["12.4"],"uploadedfiles":["12.5"],"files":["12.5"],"array":["12.5"],"express":["12.5"],"multer":["12.5"],"报错cannot":["12.5"],"convert":["12.5"],"to":["12.5"],"primitive":["12.5"],"value的原因是":["12.5"],"是一个对象":["12.5"],"而不是一个字符串":["12.5"],"所以不能直接返回":["12.5"],"需要转换成字符串":["12.5"],"返回token":["14.0"],"aaaguard":["15.0"],"了":["16.0"],"amodule":["16.1"],"onmoduledestroy":["16.2"],"销毁":["16.2"],"beforeapplicationshutdown":["16.2"],"销毁前":["16.2"],"onapplicationshutdown":["16.2"],"moduleref都是nest常用功能":["16.3"],"inject":["17.0"],"支持通过参数注入别的":["17.2"],"ioc":["17.4"],"容器中注入任何对象":["17.4"],"可以对原始组件做一些事件监听":["22.0"],"错误监控等":["22.0"],"无法直接继承静态属性":["22.2"],"如果需要继承需要手动处理":["22.2"],"或者引入第三方库":["22.2"],"因为本质上是产生了一个新组件":["22.2"],"所以需要配合":["22.2"],"forwardref":["22.2"],"来转发":["22.2"],"当前":["22.3"],"会覆盖上一个":["22.3"],"这样副作用串联起来":["22.3"],"影响很大":["22.3"],"cloneelement":["22.4"],"default":["22.4","23.5","23.8","27.6","27.10"],"可以做一些其他的操作":["22.5"],"box":["22.6"],"组件外部点击":["22.6"],"绑定标签录入页面":["22.7"],"绑定标签列表页面":["22.7"],"绑定文档列表页面":["22.7"],"项目b2":["23.1"],"这是分类b下的项目b2":["23.1"],"alt":["23.1"],"text":["23.1","33.9"],"let会在每次循环的时候保存当前作用域的变量":["23.3"],"所以每次循环的时候都会保存当前的i":["23.3"],"所以打印出来的结果是0":["23.3"],"不会产生新的作用域":["23.3"],"所以每次循环的时候都是共享一个作用域":["23.3"],"所以每次循环的时候都会覆盖上一次的i":["23.3"],"所以最后打印出来的结果都是10":["23.3"],"button":["23.5","23.6","27.14","34.6"],"onclick":["23.5","23.6","27.14","34.6"],"点击":["23.5"],"div":["23.6","23.8","27.5","34.4"],"add":["23.6","27.7","27.8","27.9","27.14"],"log":["23.8","34.5"],"提供了一整套功能":["24.1"],"可以更好地管理数据获取":["24.1"],"缓存":["24.1"],"状态以及用户体验等方面的问题":["24.1"],"从而减少了开发工作量并提供了更好的性能和用户体验":["24.1"],"查看最新issue信息":["24.9"],"最新一条issue信息":["24.9"],"stringify":["24.9"],"dataupdatedat":["24.10"],"表示数据上次更新的时间戳":["24.10"],"refetch":["24.10"],"用于手动重新获取数据的函数":["24.10"],"扩展更容易":["25.0"],"dashboard":["25.3"],"publichome":["25.3"],"atom":["26.1","27.1"],"组件通信困难":["26.3"],"当应用程序中的组件需要共享和同步状态时":["26.3"],"传统的mvc模式无法提供一个清晰的机制来处理组件之间的通信和状态共享":["26.3"],"action":["26.4"],"动作":["26.4"],"定义用户在":["26.4"],"中执行的操作":["26.4"],"它们会被发送给":["26.4"],"state变化":["27.3"],"触发更新渲染罢了":["27.3"],"有兴趣可以阅读手动实现recoil原理":["27.3"],"danger":["27.6"],"这样会阻塞渲染线程":["27.6"],"不建议这样做":["27.6"],"异步请求应该放在组件内部":["27.6"],"或者使用异步更新atom":["27.6"],"www":["27.9"],"abc":["27.9"],"com":["27.9"],"asynctest":["27.10"],"不会触发订阅事件":["27.12"],"即使大家共用同一个atom状态":["27.13"],"p":["27.14"],"x":["27.14"],"combinereducer":["28.1"],"将多个reducers合并成一个rootreducer":["28.1"],"reducer":["28.2"],"纯函数":["28.2"],"订阅消费者":["29.0"],"会让消费":["29.1"],"的组件重新渲染":["29.1"],"son":["29.2"],"将":["29.2"],"内容转化成":["29.2"],"回调函数不会阻塞浏览器绘制视图":["31.1"],"改变布局就用":["31.2"],"其他情况就用":["31.2"],"dom":["31.3"],"更新前":["31.3"],"所以此时使用":["31.3"],"避免了浏览器出现再次重回和重排的可能":["31.3"],"解决了性能上的问题":["31.3"],"如果使用uselayouteffect的话":["31.3"],"它的执行时机在dom更新完成":["31.3"],"浏览器只需绘制即可":["31.3"],"此时插入style便可引起浏览器的重绘":["31.3"],"因为样式发生了变化":["31.3"],"做防抖处理":["31.4"],"getderivedstatefromprops":["31.4"],"props获取后":["31.4"],"得到两个参数":["31.4"],"上一个props":["31.4"],"更新或的props":["31.4"],"组件挂载后":["31.4"],"shouldcomponentupdate":["31.4"],"性能优化":["31.4"],"只有":["31.4"],"list":["31.4"],"改变":["31.4","32.2","35.1"],"渲染视图":["31.4"],"render":["31.4"],"渲染":["31.4"],"item":["31.4"],"getsnapshotbeforeupdate":["31.4"],"保存更新前的快照数据":["31.4"],"组件即将更新":["31.4"],"组件即将卸载":["31.4"],"配合做数据交互":["32.2"],"也不会因为数据交互后":["32.2"],"state":["32.2"],"而产生的二次更新作用":["32.2"],"代码逻辑更简单":["32.2"],"清晰":["32.2"],"里面的组件":["32.4"],"配合":["32.4"],"实现动态加载组件效果":["32.4"],"这样很利于代码分割":["32.4"],"不会让初始化的时候加载大量的文件":["32.4"],"或者修改":["33.2"],"的子元素":["33.2"],"这种情况需要先遍历":["33.4"],"判断":["33.4"],"元素类型":["33.4"],"针对":["33.4"],"element":["33.4"],"节点":["33.4"],"针对函数":["33.4"],"直接传递参数":["33.4"],"执行函数":["33.4"],"抽象传递给":["33.6"],"一方面混入":["33.6"],"learn":["33.7"],"react":["33.7"],"api":["33.8"],"注入":["33.8"],"myinput":["33.9"],"e":["33.9"],"target":["33.9"],"ref对象模式获取元素或组件":["34.1"],"向":["34.3"],"组件传递的":["34.3"],"对象上":["34.3"],"绑定":["34.3"],"孙组件实例":["34.3"],"子组件实例":["34.3"],"和":["34.3"],"current":["34.4"],"组件实例":["34.4"],"转发引用":["34.5"],"使函数组件可以接受ref":["34.5"],"这样就可以获取到实例":["34.5"],"forwardson":["34.5"],"parent":["34.5"],"instance":["34.5"],"console":["34.5"],"key":["34.6"],"bind":["34.6"],"null":["34.6"],"用":["35.1"],"可以达到同样的效果":["35.1"],"需要更新的值":["35.1"],"放在":["35.1"],"deps":["35.1"],"中":["35.1"],"重新形成element对象":["35.1"],"否则通过":["35.1"],"拿到上次的缓存值":["35.1"],"达到如上同样效果":["35.1"],"比起类组件":["35.1"],"我更推荐函数组件用":["35.1"],"这种方式":["35.1"],"返回的重新执行":["35.2"],"产生的值":["35.2"],"否则取上一次缓存值":["35.2"],"也就和":["35.3"],"上":["35.3"],"指向相同的内存空间":["35.3"],"也就是相等":["35.3"],"从而跳过了本次更新":["35.3"],"下属性是不会促使组件更新的":["35.4"],"因为浅比较两次":["35.4"],"还是指向同一个内存空间":["35.4"],"想要解决这个问题也容易":["35.4"],"浅拷贝就可以解决":["35.4"],"或新":["35.5"],"有没有与之对应并且相等的":["35.5"],"这个相等是浅比较":["35.5"],"如果有一个不对应或者不相等":["35.5"],"到此为止":["35.5"],"浅比较流程结束":["35.5"],"purecomponent":["35.5"],"就是这么做渲染节流优化的":["35.5"],"这个值才会重新计算":["35.6"],"这对于避免重复进行昂贵的计算或数据转换非常有用":["35.6"],"如果你有一个组件":["35.6"],"它执行一个可能非常昂贵的操作":["35.6"],"如计算一个数的阶乘":["35.6"],"那么usememo就可以用来记忆化这个计算的结果":["35.6"],"从而只有当输入的数改变时":["35.6"],"才会重新运行这个计算":["35.6"],"总的来说":["35.6"],"usecallback和usememo的主要区别在于":["35.6"],"usecallback返回的是一个记忆化的函数":["35.6"],"而usememo返回的是一个记忆化的值":["35.6"],"数组":["35.7"],"那么浅比较就会失效":["35.7"],"因为新老props":["35.7"],"state指向的是同一个内存空间":["35.7"],"所以我们需要深比较":["35.7"],"这个时候就需要用到lodash的深比较函数isequal":["35.7"],"immutable":["35.7"],"js":["35.7"],"也可以实现深比较":["35.7"],"componentwillreceiveprops":["35.11"],"等钩子":["35.11"],"造成意想不到的情况发生":["35.11"],"filter":["38.4"],"throw":["38.4"],"error":["38.4"],"未知":["38.4"],"使用中间件或副作用等情况下":["38.6"],"可以优于简单使用usestate来管理组件状态":["38.6"],"此时我们的constroller与service解耦":["45.1"],"具体调用的方法完全取决于外部依赖注入进来的方法":["45.1"],"可扩展性":["45.1"],"解耦":["45.1"],"可测试性":["45.1"],"controller":["45.5"],"on":["50.0"]}]'},t={"0.0":{t:"<resume/>",p:"",l:"Resume/index.html",a:"resume"},"1.0":{t:"# AOP",p:`后端架构一般都是MVC架构，MVC是Model View Controller的简写，请求一般会先发送到Controller 然后由它调用Model层的service来完成业务逻辑，最后返回View
 ...`,l:"articles/BackEnd/NestJs/AOP/index.html",a:"aop"},"1.1":{t:"中间件",p:`
中间件是Express的概念，Nest底层是Express/fastify(可选)，所以Nest也有中间件的概念,进一步区分为全局中间件和路由中间件

`,l:"articles/BackEnd/NestJs/AOP/index.html#中间件",a:"中间件"},"1.2":{t:"全局中间件 Middleware",p:`// main.ts
async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  app.use ...`,l:"articles/BackEnd/NestJs/AOP/index.html#全局中间件-middleware",a:"全局中间件-middleware"},"1.3":{t:"路由中间件",p:`
路由中间件首先要创建一个中间件类，然后在路由上使用

创建中间件类 nest generate middleware logger --no-spec --flat  no-spec 不生成测试文件 ...`,l:"articles/BackEnd/NestJs/AOP/index.html#路由中间件",a:"路由中间件"},"1.4":{t:"路由守卫 Guard",p:`
Guard是路由守卫的意思，可以用于在调用某个Controller之前判断权限，返回True或False来决定是否放行
n g gu auth/guards/role --no-spec

!ima ...`,l:"articles/BackEnd/NestJs/AOP/index.html#路由守卫-guard",a:"路由守卫-guard"},"1.5":{t:"拦截器 Interceptor",p:`
拦截器是在Controller之前之后执行的一段代码，可以用来做一些通用的逻辑，比如日志、异常处理等等
nest g interceptor logger --no-spec

import {
  ...`,l:"articles/BackEnd/NestJs/AOP/index.html#拦截器-interceptor",a:"拦截器-interceptor"},"1.6":{t:"Pipe",p:`

Pipe是管道的意思 ，用来对参数做校验和转换
除了路由的权限控制、目标 Controller 之前之后的处理这些都是通用逻辑外，对参数的处理也是一个通用的逻辑，所以 Nest 也抽出了对应的切面 ...`,l:"articles/BackEnd/NestJs/AOP/index.html#pipe",a:"pipe"},"1.7":{t:"ExceptionFilter",p:`
ExceptionFilter 可以对抛出的异常做处理，返回对应的响应：


创建一个filter n g filter test --no-spec --flat
::: code-group

 ...`,l:"articles/BackEnd/NestJs/AOP/index.html#exceptionfilter",a:"exceptionfilter"},"2.0":{t:"中间件",p:`::: info 存在意义
处理HTTP请求的函数，他可以在请求到达控制器之前/之后执行一些操作 他可以是全局的也可以是局部的
场景：身份验证，日志记录，错误处理
:::
::: details
中间 ...`,l:"articles/BackEnd/NestJs/Basic/Code/Concept.html",a:"中间件"},"2.1":{t:"守卫",p:`Guard 是一种用于保护路由的机制，他可以在请求到达控制器之前或者之后执行一些操作。守卫可以用于实现身份验证，权限控制，缓存等功能。在NestJs中收尾可以是全局的也可以是局部的。守卫路由
[[Ex ...`,l:"articles/BackEnd/NestJs/Basic/Code/Concept.html#守卫",a:"守卫"},"2.2":{t:"拦截器",p:`处理HTTP请求和响应的函数，在请求到达控制器之前之后执行一些操作。拦截器可以实现日志记录，错误处理，数据转换。在Nestjs中拦截器可以是全局的也可局部
@Injectable()
export c ...`,l:"articles/BackEnd/NestJs/Basic/Code/Concept.html#拦截器",a:"拦截器"},"2.3":{t:"管道",p:`管道是数据流入controller前进行的一波数据处理
其中数据处理包含了对数据的转换,验证。他可以在控制器之前或之后对数据进行预处理。然后将数据传递给控制器或下一个管道。
$$管道的主要目的是增强应 ...`,l:"articles/BackEnd/NestJs/Basic/Code/Concept.html#管道",a:"管道"},"3.0":{t:">注入基本数据",p:`因为普通数据服务不是Class，所以要使用@Inject来注入

@Module({
	providers:[
		{
			provide:'APP_NAME',
			useValue:'使用普通 ...`,l:"articles/BackEnd/NestJs/Basic/Code/Provider.html",a:"注入基本数据"},"4.0":{t:"> 案例，第三方发送短信服务。 根据不同配置使用不同的第三方运营商",p:`sms.serivce.ts
@Injectable()
export class AppController(){
	constructor(){
		private ali:aliService, ...`,l:"articles/BackEnd/NestJs/Basic/Code/env配置相关.html",a:"案例-第三方发送短信服务。-根据不同配置使用不同的第三方运营商"},"5.0":{t:"控制反转 IOC",p:`面向对象中的设计原则，用来减少计算机代码之前的耦合度。其根本思想是：”借助于第三方“ 实现具有依赖关系的对象之间的解耦

$$ 第三方举例：TS注解，或直接传递参数。总之控制权不在类中，而是由外部决定 ...`,l:"articles/BackEnd/NestJs/Basic/Code/设计模式模式.html",a:"控制反转-ioc"},"5.1":{t:"依赖注入 DI",p:`IOC 的具体实现，在类以外的地方提供服务。类内部调用的是该具体服务的抽象

	abstrct class Phone {
		playGame(name:string):string
	}
	cla ...`,l:"articles/BackEnd/NestJs/Basic/Code/设计模式模式.html#依赖注入-di",a:"依赖注入-di"},"6.0":{t:"- Nest 请求声明周期",p:`

[[Provider]]

动态Provider
asynProvider



Module

静态模块
动态模块
全局模块



[[env配置相关]]


`,l:"articles/BackEnd/NestJs/Basic/Module Contorller Service.html",a:"nest-请求声明周期"},"6.1":{t:"Module Controller Service的关系",p:`
Module 提供了一个模块化的方式来组织和管理您的应用程序的代码，同时还允许您使用依赖注入和模块之间的依赖关系来构建更加可扩展的应用程序。
$$ Module是Nestjs应用程序的基本构建块，每 ...`,l:"articles/BackEnd/NestJs/Basic/Module Contorller Service.html#module-controller-service的关系",a:"module-controller-service的关系"},"6.2":{t:"Nest 请求生命周期",p:`!img

1.  收到请求
2.  全局绑定的中间件
3.  模块绑定的中间件
4.  全局守卫
5.  控制层守卫
6.  路由守卫
7.  全局拦截器（控制器之前）
8.  控制器层拦截器 （控 ...`,l:"articles/BackEnd/NestJs/Basic/Module Contorller Service.html#nest-请求生命周期",a:"nest-请求生命周期"},"6.3":{t:"[[Provider]]",p:`提供服务,用于表示应用程序中可注入的任何东西。除了服务，Provider 还可以提供其他类型的对象，例如 Factory 工厂、配置对象、连接对象等。


提供者使用 @Injectable() 装饰 ...`,l:"articles/BackEnd/NestJs/Basic/Module Contorller Service.html#provider",a:"provider"},"6.4":{t:"Module",p:`模块是一个子程序，用于定义控制器，提供者或向其他模块开放提供者（开放模块的API）


默认情况下控制器，提供者在当前模块可用，即模块作用域
若果向其他模块提供服务可以将提供者定义在export属性中 ...`,l:"articles/BackEnd/NestJs/Basic/Module Contorller Service.html#module",a:"module"},"6.5":{t:"	",p:"",l:"articles/BackEnd/NestJs/Basic/Module Contorller Service.html#",a:""},"6.6":{t:"动态Module",p:"",l:"articles/BackEnd/NestJs/Basic/Module Contorller Service.html#动态module",a:"动态module"},"7.0":{t:"hi  我是Eagon,今天给大家分享Nest基础系列-Nestjs核心基础概念。 愿我们共同进步",p:"",l:"articles/BackEnd/NestJs/Basic/NestJs核心概念.html",a:"hi-我是eagon-今天给大家分享nest基础系列-nestjs核心基础概念。-愿我们共同进步"},"7.1":{t:"核心概念概览",p:`
模块 Modules 组合所有逻辑的地方,我理解为DI的Container
控制器 Controller处理请求
服务 Service 操作数据库以及处理所有逻辑的地方
管道 Pipes 核验请求的 ...`,l:"articles/BackEnd/NestJs/Basic/NestJs核心概念.html#核心概念概览",a:"核心概念概览"},"7.2":{t:" 重点1: NestJs 处理Https时的生命周期",p:"",l:"articles/BackEnd/NestJs/Basic/NestJs核心概念.html#重点1-nestjs-处理https时的生命周期",a:"重点1-nestjs-处理https时的生命周期"},"8.0":{t:">他代表了一个HTTP请求的执行上下文，提供了许多属性和方法，可用于在请求的生命周期内访问",p:`
ExecutionContext是在每个请求到达控制器之前被Nestjs封装产生的，他的请求是将请求的上下文，传递给控制器，拦截器，管道，守卫等各个部分。以便他们可以对请求进行处理和转换
当一个请求 ...`,l:"articles/BackEnd/NestJs/Basic/link/Execution Context 执行上下文.html",a:"他代表了一个http请求的执行上下文-提供了许多属性和方法-可用于在请求的生命周期内访问"},"9.0":{t:"# Reflect.defineMetadata",p:`::: tip
Nest中使用的是Reflect.defineMetadata来实现@Module,@Controller,@Injectable,@Get等装饰器的功能
它的作用是在类上定义元数据
 ...`,l:"articles/BackEnd/NestJs/ReflectMetaData/index.html",a:"reflect-definemetadata"},"10.0":{t:"# 装饰器总结",p:"",l:"articles/BackEnd/NestJs/decorator/index.html",a:"装饰器总结"},"10.1":{t:"@Optional()",p:`使Provider为可选


当Controller需要注入一个Provider,如果这个provider不存在的话，那么会报错，把它设置为可选的会避免这个问题


export class AppC ...`,l:"articles/BackEnd/NestJs/decorator/index.html#optional",a:"optional"},"10.2":{t:"@Global()",p:`使Provider全局可用,当一个Module被设置为@Global时，Export属性全局可用
@Global() // [!code ++]
@Module({
    imports:[],
  ...`,l:"articles/BackEnd/NestJs/decorator/index.html#global",a:"global"},"10.3":{t:"@Catch()",p:`
ExceptionFilter 是处理抛出的未捕获异常的，通过 @Catch 来指定处理的异常：
::: code-group

@Catch(HttpException)
export class ...`,l:"articles/BackEnd/NestJs/decorator/index.html#catch",a:"catch"},"10.4":{t:"@Post()",p:`

如果是POST请求，可以使用@Body获取到请求体.我们一般用 dto 的 class 来接受请求体里的参数


// dto
export class AaaDto{
    a:number, ...`,l:"articles/BackEnd/NestJs/decorator/index.html#post",a:"post"},"10.5":{t:"@SetMetaData()",p:`handle 和 class 可以通过@SetMetaData()制定元信息数据,提供给守卫，拦截器等使用
然后在 guard 或者 interceptor 里取出来：
::: code-group
 ...`,l:"articles/BackEnd/NestJs/decorator/index.html#setmetadata",a:"setmetadata"},"10.6":{t:"@Headers()",p:`
通过 @Headers 装饰器取某个请求头 或者全部请求头

@Get('/abc')
header(@Headers('Accept') accept:string,@Headers() head ...`,l:"articles/BackEnd/NestJs/decorator/index.html#headers",a:"headers"},"10.7":{t:"@Ip()",p:`
通过@Ip 拿到请求的ip

@Get('/ip')
ip(@Ip() ip:string){
    console.log(ip)
}

`,l:"articles/BackEnd/NestJs/decorator/index.html#ip",a:"ip"},"10.8":{t:"@Session() TODO",p:`::: details

通过@Session拿到session

@Get('/session')
session(@Session() session){
    console.log(sess ...`,l:"articles/BackEnd/NestJs/decorator/index.html#session-todo",a:"session-todo"},"10.9":{t:"@HostParam 用于取域名部分的参数",p:`
Controller 除了可以制定具体path生效外，还可以指定host

@Controller({host:':host.0.0.1',path:'aaa'})
export class Aaa ...`,l:"articles/BackEnd/NestJs/decorator/index.html#hostparam-用于取域名部分的参数",a:"hostparam-用于取域名部分的参数"},"10.10":{t:"@Req() @Response 直接注入Request/Response属性",p:`
前面取的是request属性，当然也可以注入request对象
::: code-group

@Controller({host:':host.0.0.1',path:'aaa'})
export ...`,l:"articles/BackEnd/NestJs/decorator/index.html#req-response-直接注入request-response属性",a:"req-response-直接注入request-response属性"},"10.11":{t:"@Next()",p:`
除了注入@Res不会返回响应外，注入@Next也不会
@Next() 当你有两个handler来处理同一个路由的时候，可以再第一个handler里注入next,调用它来吧请求转发到第二个handle ...`,l:"articles/BackEnd/NestJs/decorator/index.html#next",a:"next"},"10.12":{t:"@Redirect() 重定向",p:`@Get('abc')
@Redirect('http://baidu.com')
RedirectBaidu(){
}

@Get('abc')
@Redirect('http://baidu.co ...`,l:"articles/BackEnd/NestJs/decorator/index.html#redirect-重定向",a:"redirect-重定向"},"11.0":{t:"# Exception切换不同上下文",p:`
NestJS支持 HTTP服务 WebSocket服务 TCP通信服务
不同类型的服务在Guard/interceptor 等取到的功能不同,导致无法复用
ArgumentHost 和 Execut ...`,l:"articles/BackEnd/NestJs/exception/index.html",a:"exception切换不同上下文"},"11.1":{t:"exceptionFilter 参数 exceptions argumentsHost 切换不同上下文",p:"&lt;!-- ```ts\nimport { AaaException } from './aaa.exception';\n@Catch(AaaException)\nexport class Myex ...",l:"articles/BackEnd/NestJs/exception/index.html#exceptionfilter-参数-exceptions-argumentshost-切换不同上下文",a:"exceptionfilter-参数-exceptions-argumentshost-切换不同上下文"},"11.2":{t:"Guard等切换上下文",p:`@Injectable()
export class GuardExceptionGuard implements CanActivate {
  canActivate(
    context:  ...`,l:"articles/BackEnd/NestJs/exception/index.html#guard等切换上下文",a:"guard等切换上下文"},"11.3":{t:"为啥要多俩方法 getClass getHandler",p:`比如守卫验证权限使，需要获取目标方法的元数据，就可以通过 getHandler 方法获取到目标方法的元数据。
然后比对决定是否放行
import { CanActivate, ExecutionCon ...`,l:"articles/BackEnd/NestJs/exception/index.html#为啥要多俩方法-getclass-gethandler",a:"为啥要多俩方法-getclass-gethandler"},"11.4":{t:"总结",p:`
为了让Filter Guard Exception 支持http ws rpc等场景下复用,Nest 设计了ArgumentHost 和 ExecutionContext 类


ArgumentH ...`,l:"articles/BackEnd/NestJs/exception/index.html#总结",a:"总结"},"12.0":{t:"# HTTP数据传输方式",p:`
url param
query
form-urlencoded
form-data
json
encode: 将...编译

`,l:"articles/BackEnd/NestJs/http/index.html",a:"http数据传输方式"},"12.1":{t:"urlParam/Query",p:`都属于GET路径传参
params：/router1/:id ，    //router1/123，/router1/789 ,这里的id叫做params
--------------------
q ...`,l:"articles/BackEnd/NestJs/http/index.html#urlparam-query",a:"urlparam-query"},"12.2":{t:"form-urlencoded",p:`直接用表单提交数据，提交的就是这种
他和query的区别就是把查询的query放在了body里,然后指定下 content-type 是 application/x-www-form-urlencod ...`,l:"articles/BackEnd/NestJs/http/index.html#form-urlencoded",a:"form-urlencoded"},"12.3":{t:"form-data",p:`form data 不再是通过 &amp; 分隔数据，而是用 --------- + 一串数字做为 boundary(分隔符)。因为不是 url 的方式了，自然也不用再做 url encode。
&l ...`,l:"articles/BackEnd/NestJs/http/index.html#form-data",a:"form-data"},"12.4":{t:"Json",p:`form-urlencoded 需要对内容做 url encode，而 form data 则需要加很长的 boundary，两种方式都有一些缺点。如果只是传输 json 数据的话，不需要用这两种。
 ...`,l:"articles/BackEnd/NestJs/http/index.html#json",a:"json"},"12.5":{t:"Nest实现基本的http请求",p:`::: code-group
// [http.controller.ts]
// query: /router1?id=123 
// param : /router/1

在 Nest 里，通过  ...`,l:"articles/BackEnd/NestJs/http/index.html#nest实现基本的http请求",a:"nest实现基本的http请求"},"13.0":{t:"# NestJs",p:"",l:"articles/BackEnd/NestJs/index.html",a:"nestjs"},"14.0":{t:"- register 接收账号密码argon2 hash 加密插入数据库",p:`
login   登录接收账号密码，argon2 verify对密码进行解密
解密符合，根据头信息，载荷, 签名规则 返回token

`,l:"articles/BackEnd/NestJs/jwt/流程.html",a:"register-接收账号密码argon2-hash-加密插入数据库"},"15.0":{t:"# 合并装饰器",p:`
装饰器太多了，有时候我们需要合并装饰器，这样就可以减少代码量，提高代码可读性。

import { applyDecorators, Get, UseGuards } from '@nestjs/c ...`,l:"articles/BackEnd/NestJs/makeDecorator/index.html",a:"合并装饰器"},"15.1":{t:"自定义装饰器",p:`import { createParamDecorator, ExecutionContext } from '@nestjs/common';

export const Ccc = createP ...`,l:"articles/BackEnd/NestJs/makeDecorator/index.html#自定义装饰器",a:"自定义装饰器"},"16.0":{t:"# 全局Module和生命周期",p:`
模块导出 provider，另一个模块需要 imports 它才能用这些 provider。
多个模块需要用到同一个 provider 时，可以把这个 provider 放到一个模块中，然后 imp ...`,l:"articles/BackEnd/NestJs/module/index.html",a:"全局module和生命周期"},"16.1":{t:"全局模块",p:`注意:全局模块不推荐经常使用，注入太多的provider不清楚来源，可维护性差
@Global()
@Module({
    imports: [PrismaModule],
    provide ...`,l:"articles/BackEnd/NestJs/module/index.html#全局模块",a:"全局模块"},"16.2":{t:"生命周期Lifecycle",p:`Nest 在启动的时候，会递归解析 Module 依赖，扫描其中的 provider、controller，注入它的依赖。
全部解析完后，会监听网络端口，开始处理请求。
这个过程中，Nest 暴露了一 ...`,l:"articles/BackEnd/NestJs/module/index.html#生命周期lifecycle",a:"生命周期lifecycle"},"16.3":{t:"总结",p:`::: tip
模块可以@Global声明为全局，这样它export的provider就可以在各处使用了，不需要imports
provider,controller,module都支持启动和销毁函数 ...`,l:"articles/BackEnd/NestJs/module/index.html#总结",a:"总结"},"17.0":{t:"# 多种provider",p:`Nest 实现了IoC 从main文件臊面，分析Module引用及依赖中的关系，自动把provider注入到目标对象
::: code-group
@Module({
  imports: [Pris ...`,l:"articles/BackEnd/NestJs/provider/index.html",a:"多种provider"},"17.1":{t:"注册Value值",p:`@Module({
  imports: [PrismaModule],
  providers: [{
      provide:'a',
      useValue:'我是A'
    }]
 ...`,l:"articles/BackEnd/NestJs/provider/index.html#注册value值",a:"注册value值"},"17.2":{t:"动态注册服务",p:`@Module({
  imports: [PrismaModule],
  providers: [{
      provide:'providerTest',
      inject: ['p ...`,l:"articles/BackEnd/NestJs/provider/index.html#动态注册服务",a:"动态注册服务"},"17.3":{t:"异步动态注册服务",p:`当需要异步获取provider时，可以使用useFactory的async版本
例如: 链接redis当redis链接成功后再注册provider
@Module({
  imports: [Pris ...`,l:"articles/BackEnd/NestJs/provider/index.html#异步动态注册服务",a:"异步动态注册服务"},"17.4":{t:"总结",p:`::: tip

一般情况Provider通过@Injectable声明,然后再@Module的providers数组里注册的class
默认provier的token就是class,这样不用使用@I ...`,l:"articles/BackEnd/NestJs/provider/index.html#总结",a:"总结"},"18.0":{t:"# 文件上传",p:`::: tip
NestJS 实现文件上传是基于Express Multer实现的,然后通过一系列适配器和拦截器集成到NestJS中
:::
`,l:"articles/BackEnd/NestJs/upload/index.html",a:"文件上传"},"19.0":{t:"语法",p:"",l:"articles/English/grammar/index.html",a:"语法"},"20.0":{t:"js",p:"",l:"articles/FontEnd/js/index.html",a:"js"},"21.0":{t:"# 项目列表",p:"",l:"articles/FontEnd/react/Basic/index.html",a:"项目列表"},"21.1":{t:"高阶组件HOC",p:"",l:"articles/FontEnd/react/Basic/index.html#高阶组件hoc",a:"高阶组件hoc"},"22.0":{t:"# 高阶组件HOC",p:`总结

强化 props ，可以通过 HOC ，向原始组件混入一些状态。
渲染劫持，可以利用 HOC ，动态挂载原始组件，还可以先获取原始组件的渲染树，进行可控性修改。
可以配合 import 等 a ...`,l:"articles/FontEnd/react/HOC/index.html",a:"高阶组件hoc"},"22.1":{t:"两种不同的高阶组件",p:`常用的高阶组件有属性代理和反向继承两种，两者之间有一些共性和区别。接下来分别介绍一下两种模式下的高阶组件。
`,l:"articles/FontEnd/react/HOC/index.html#两种不同的高阶组件",a:"两种不同的高阶组件"},"22.2":{t:"属性代理",p:`属性代理，就是用组件包裹一层代理组件，在代理组件上，可以做一些，对源组件的强化操作。这里注意属性代理返回的是一个新组件，被包裹的原始组件，将在新的组件里被挂载。
function HOC(WrapCo ...`,l:"articles/FontEnd/react/HOC/index.html#属性代理",a:"属性代理"},"22.3":{t:"反向继承",p:`反向继承
反向继承和属性代理有一定的区别，在于包装后的组件继承了原始组件本身，所以此时无须再去挂载业务组件。
class Index extends React.Component{
  render ...`,l:"articles/FontEnd/react/HOC/index.html#反向继承",a:"反向继承"},"22.4":{t:"编写HOC 什么时候使用HOC",p:`

强化Props
强化 props 就是在原始组件的 props 基础上，加入一些其他的 props ，强化原始组件功能


控制渲染
HOC 反向继承模式，可以通过 super.render()  ...`,l:"articles/FontEnd/react/HOC/index.html#编写hoc-什么时候使用hoc",a:"编写hoc-什么时候使用hoc"},"22.5":{t:"动态加载Loading",p:`export default function dynamicHoc(loadRouter) {
  return class Content extends React.Component {
   ...`,l:"articles/FontEnd/react/HOC/index.html#动态加载loading",a:"动态加载loading"},"22.6":{t:"事件监控",p:`HOC 不一定非要对组件本身做些什么？也可以单纯增加一些事件监听，错误监控。
以下代码HOC ，只对组件内的点击事件做一个监听效果。
function ClickHoc (Component){
   ...`,l:"articles/FontEnd/react/HOC/index.html#事件监控",a:"事件监控"},"22.7":{t:"权限拦截",p:`::: code-group

export const Permission = React.createContext([]) 
export default function Index(){
 ...`,l:"articles/FontEnd/react/HOC/index.html#权限拦截",a:"权限拦截"},"23.0":{t:"# Hooks",p:"",l:"articles/FontEnd/react/Hooks/index.html",a:"hooks"},"23.1":{t:"API分类",p:`
关键词： concurrent
&lt;table&gt;
&lt;tr&gt;
&lt;th&gt;使用范围&lt;/th&gt;
&lt;th&gt;Hooks&lt;/th&gt;
&lt;t ...`,l:"articles/FontEnd/react/Hooks/index.html#api分类",a:"api分类"},"23.2":{t:"Hooks",p:"",l:"articles/FontEnd/react/Hooks/index.html#hooks",a:"hooks"},"23.3":{t:"useRef",p:`&lt;details&gt;
场景：稳定引用，获取dom节点，获取上一次的值

闭包 异步访问到旧变量的问题

::: code-group
 // 典型的闭包循环案例，每次循环调用setTimeo ...`,l:"articles/FontEnd/react/Hooks/index.html#useref",a:"useref"},"23.4":{t:"数据更新驱动类",p:"",l:"articles/FontEnd/react/Hooks/index.html#数据更新驱动类",a:"数据更新驱动类"},"23.5":{t:"useState",p:`&lt;details&gt;
const [state, setState] = useState(initialState);
参数接收一个初始值，返回一个数组，数组的第一个元素是当前的state ...`,l:"articles/FontEnd/react/Hooks/index.html#usestate",a:"usestate"},"23.6":{t:"useReducer",p:`对于拥有许多状态更新逻辑的组件来说，过于分散的事件处理程序可能会令人不知所措。对于这种情况，你可以将组件的所有状态更新(增删改查)逻辑整合到一个外部函数中，这个函数叫作 reducer。
reduce ...`,l:"articles/FontEnd/react/Hooks/index.html#usereducer",a:"usereducer"},"23.7":{t:"useContext",p:`作用: 传递数据，避免props层层传递，导致代码冗余
`,l:"articles/FontEnd/react/Hooks/index.html#usecontext",a:"usecontext"},"23.8":{t:"useImperativeHandle",p:`::: info 解决了什么问题?
子组件通过ref抛出方法供父组件调用
React函数 组件，父组件需要直接访问子组件的实例方法或属性的问题。
在 React 中，父组件通常通过 props 向子组 ...`,l:"articles/FontEnd/react/Hooks/index.html#useimperativehandle",a:"useimperativehandle"},"24.0":{t:"# React Query",p:"",l:"articles/FontEnd/react/ReactQuery/index.html",a:"react-query"},"24.1":{t:"出现背景/解决问题",p:"**灵魂拷问Q： 为什么用axios不可以 为什么需要出现React QueryA:尽管可以使用普通的 Axios 或其他数据获取库来处理数据请求，但在某些情况下，使用 React Query 可以带 ...",l:"articles/FontEnd/react/ReactQuery/index.html#出现背景-解决问题",a:"出现背景-解决问题"},"24.2":{t:"核心概念",p:`解决普通请求代码重复，后期维护困难。无数据缓存，无数据同步，无数据预取，无数据失效处理，无服务器状态更新等问题。
`,l:"articles/FontEnd/react/ReactQuery/index.html#核心概念",a:"核心概念"},"24.3":{t:"使用教程",p:"",l:"articles/FontEnd/react/ReactQuery/index.html#使用教程",a:"使用教程"},"24.4":{t:"自动缓存和数据同步",p:"",l:"articles/FontEnd/react/ReactQuery/index.html#自动缓存和数据同步",a:"自动缓存和数据同步"},"24.5":{t:"加载状态管理",p:"",l:"articles/FontEnd/react/ReactQuery/index.html#加载状态管理",a:"加载状态管理"},"24.6":{t:"数据同步和预取",p:"",l:"articles/FontEnd/react/ReactQuery/index.html#数据同步和预取",a:"数据同步和预取"},"24.7":{t:"自动缓存失效处理",p:"",l:"articles/FontEnd/react/ReactQuery/index.html#自动缓存失效处理",a:"自动缓存失效处理"},"24.8":{t:"服务器状态更新",p:"",l:"articles/FontEnd/react/ReactQuery/index.html#服务器状态更新",a:"服务器状态更新"},"24.9":{t:"更少的重复代码",p:`::: code-group
import as React from 'react';
​
export default function App() {
  // 存储 后端返回数据
  cons ...`,l:"articles/FontEnd/react/ReactQuery/index.html#更少的重复代码",a:"更少的重复代码"},"24.10":{t:"API",p:`


APIname
Are




data：
查询返回的数据


isLoading：
表示查询是否正在加载中。如果数据正在加载，该属性为 true；否则为 false。


isError：
表 ...`,l:"articles/FontEnd/react/ReactQuery/index.html#api",a:"api"},"24.11":{t:"总结",p:"",l:"articles/FontEnd/react/ReactQuery/index.html#总结",a:"总结"},"25.0":{t:"# React Router",p:`后端概念：发送url请求到服务器端，server会通过不同的地址返回不同的页面
为什么需要路由：

单页应用需要路由切换
通过url可以定位到页面
更有语义的组织资源

三种路由的实现方式：

Bro ...`,l:"articles/FontEnd/react/ReactRouter/index.html",a:"react-router"},"25.1":{t:"快速上手",p:"",l:"articles/FontEnd/react/ReactRouter/index.html#快速上手",a:"快速上手"},"25.2":{t:"原理分析",p:"",l:"articles/FontEnd/react/ReactRouter/index.html#原理分析",a:"原理分析"},"25.3":{t:"核心API",p:`


name
effect
demo




Link
普通链接，不会触发刷新
&lt;Link to=&quot;&quot;/&gt;


NavLink
类似Link
但是会添加当前选中状态& ...`,l:"articles/FontEnd/react/ReactRouter/index.html#核心api",a:"核心api"},"26.0":{t:"# React 全局存储/状态管理",p:"",l:"articles/FontEnd/react/Storage/index.html",a:"react-全局存储-状态管理"},"26.1":{t:"常见的状态管理模式",p:`
global：  全局式，也被称作单一数据源，将所有的数据放到一个大对象中，关键词：combineReducers();
multiple stores：  多数据源模式，将状态存放到多个数据源中， ...`,l:"articles/FontEnd/react/Storage/index.html#常见的状态管理模式",a:"常见的状态管理模式"},"26.2":{t:"Flex 架构",p:"",l:"articles/FontEnd/react/Storage/index.html#flex-架构",a:"flex-架构"},"26.3":{t:"出现背景 & 解决痛点",p:"Flux架构解决前端应用程序中状态管理和数据流动的复杂性问题。在传统的MVC（Model-View-Controller）模式中，应用程序的状态分散在多个视图和控制器之间，导致数据流动难以追踪和管理。 ...",l:"articles/FontEnd/react/Storage/index.html#出现背景-解决痛点",a:"出现背景-解决痛点"},"26.4":{t:"架构特点 & 详细介绍",p:`Flux架构通过引入单向数据流的概念，将数据的流动变得可控和可预测。它明确了数据流动的路径，并将状态的修改限制在特定的流程中。这样做的好处包括：


易于追踪和调试：由于数据流是单向的，数据的变化路径 ...`,l:"articles/FontEnd/react/Storage/index.html#架构特点-详细介绍",a:"架构特点-详细介绍"},"27.0":{t:"# Jotai",p:`引用来源：Ryun
`,l:"articles/FontEnd/react/Storage/jotai/index.html",a:"jotai"},"27.1":{t:"常见的状态管理模式",p:`
global：  全局式，也被称作单一数据源，将所有的数据放到一个大对象中，关键词：combineReducers();
multiple stores：  多数据源模式，将状态存放到多个数据源中， ...`,l:"articles/FontEnd/react/Storage/jotai/index.html#常见的状态管理模式",a:"常见的状态管理模式"},"27.2":{t:"Jotai  原子状态管理",p:"",l:"articles/FontEnd/react/Storage/jotai/index.html#jotai-原子状态管理",a:"jotai-原子状态管理"},"27.3":{t:"原子式解决了什么问题",p:`reactHook 使State的拆分和逻辑共享变得更容易
但useState 和 useContext对于多个store仍需要维护多个Context Provider 因为当Context改变，所有 ...`,l:"articles/FontEnd/react/Storage/jotai/index.html#原子式解决了什么问题",a:"原子式解决了什么问题"},"27.4":{t:"使用教程",p:"",l:"articles/FontEnd/react/Storage/jotai/index.html#使用教程",a:"使用教程"},"27.5":{t:"1. 创建 atom  派生atom  使用 useAtom",p:`::: details View The Code
import { atom, useAtom } from &quot;jotai&quot;;
import { FC } from &quot; ...`,l:"articles/FontEnd/react/Storage/jotai/index.html#_1-创建-atom-派生atom-使用-useatom",a:"_1-创建-atom-派生atom-使用-useatom"},"27.6":{t:"2. 异步派生",p:`::: details View The Code
import { atom, useAtom } from &quot;jotai&quot;;
import { FC } from &quot; ...`,l:"articles/FontEnd/react/Storage/jotai/index.html#_2-异步派生",a:"_2-异步派生"},"27.7":{t:"3. 函数组件内更新方式",p:`::: details View The Code
  const ValueAtom = atom(1)
  const Text = ()=&gt;{
    const [value,setVa ...`,l:"articles/FontEnd/react/Storage/jotai/index.html#_3-函数组件内更新方式",a:"_3-函数组件内更新方式"},"27.8":{t:"4. atom内更新方式",p:`::: details View The Code
  const ValueAtom = atom(1)
  const AddNumberAtom = atom(ge=&gt;ge(ValueAt ...`,l:"articles/FontEnd/react/Storage/jotai/index.html#_4-atom内更新方式",a:"_4-atom内更新方式"},"27.9":{t:"5. 异步更新atom 区别于第二条异步获取，异步更新不会阻塞线程",p:`::: details View The Code
  const MockData = new Promise&lt;string&gt;((r) =&gt; {
    setTimeout(() ...`,l:"articles/FontEnd/react/Storage/jotai/index.html#_5-异步更新atom-区别于第二条异步获取-异步更新不会阻塞线程",a:"_5-异步更新atom-区别于第二条异步获取-异步更新不会阻塞线程"},"27.10":{t:"6. 渲染问题",p:`:::   details View The Code

当我们点击add时，发现A和B都重新渲染了，但是问题来了，A为什么要重新渲染呀，A只是触发了更新操作，并不需要重新渲染呀？？？


这是因为， ...`,l:"articles/FontEnd/react/Storage/jotai/index.html#_6-渲染问题",a:"_6-渲染问题"},"27.11":{t:"7. 解决渲染问题 useAtomValue、useSetAtom",p:`
如果有的组件只需要监听状态的变化值，而没有更新操作 请使用useAtomValue
如果仅更新操作，而无需渲染状态的组件，请使用 useSetAtom
这么做的目的：防止无意义的渲染

`,l:"articles/FontEnd/react/Storage/jotai/index.html#_7-解决渲染问题-useatomvalue、usesetatom",a:"_7-解决渲染问题-useatomvalue、usesetatom"},"27.12":{t:"8. Provider",p:`
正常情况下，无需用Provider包裹组件
但如果需要控制某些组件的状态不发生更新，可以用Provider包裹
或者说，用Provider包裹的组件，状态是独立的，不受外部影响，同时也不影响外部，即 ...`,l:"articles/FontEnd/react/Storage/jotai/index.html#_8-provider",a:"_8-provider"},"27.13":{t:"9.store",p:`
createStore,export出去,使用Jotai的Provider提供给App


其中，store中的状态，是全局的，任何组件都可以使用，但是，如果某个组件使用了Provider包裹，那么 ...`,l:"articles/FontEnd/react/Storage/jotai/index.html#_9-store",a:"_9-store"},"27.14":{t:"实际使用",p:`::: code-group
import { createStore, atom } from &quot;jotai&quot;;

const myStore = createStore();
 ...`,l:"articles/FontEnd/react/Storage/jotai/index.html#实际使用",a:"实际使用"},"28.0":{t:"# Redux",p:"",l:"articles/FontEnd/react/Storage/redux/index.html",a:"redux"},"28.1":{t:"API介绍",p:`
reducer 纯函数，接收两个参数，一个是state，一个是action，返回一个新的state
createStore 创建一个 root 存放 state的根对象
dispatch 更新sto ...`,l:"articles/FontEnd/react/Storage/redux/index.html#api介绍",a:"api介绍"},"28.2":{t:"摘要",p:`
middleware 中间件,中间件用于增强 dispatch 功能，返回一个增强后的 dispatch（比如 redux-thunk 使 action 可以为 function）
enhancer ...`,l:"articles/FontEnd/react/Storage/redux/index.html#摘要",a:"摘要"},"29.0":{t:"# Context Provider Consumer",p:`
const ThemeContext = React.createContext(null)
const ThemeProvider = ThemeContext.Provider  //提供者
c ...`,l:"articles/FontEnd/react/context/index.html",a:"context-provider-consumer"},"29.1":{t:"提供者Provider用法",p:`const ThemeProvider = ThemeContext.Provider  //提供者
export default function ProviderDemo(){
    const ...`,l:"articles/FontEnd/react/context/index.html#提供者provider用法",a:"提供者provider用法"},"29.2":{t:"消费者Consumer用法",p:`对于新版本想要获取 context 的消费者，React 提供了3种形式
::: code-group
React v16.6 提供了 contextType 静态属性，用来获取上面 Provider ...`,l:"articles/FontEnd/react/context/index.html#消费者consumer用法",a:"消费者consumer用法"},"30.0":{t:"!react",p:"",l:"articles/FontEnd/react/index.html",a:"react"},"31.0":{t:"# 生命周期",p:`React hooks也提供了 api ，用于弥补函数组件没有生命周期的缺陷。其原理主要是运用了 hooks 里面的 useEffect 和 useLayoutEffect
`,l:"articles/FontEnd/react/lifeCycle/index.html",a:"生命周期"},"31.1":{t:"useEffect",p:`useEffect(()=&gt;{
    return destory
},dep)


第一个参数callback 返回销毁函数 下次执行useEffect会首先执行这个销毁函数。 销毁定时器, ...`,l:"articles/FontEnd/react/lifeCycle/index.html#useeffect",a:"useeffect"},"31.2":{t:"useLayoutEffect",p:`useLayoutEffect 和 useEffect 不同的地方是采用了同步执行


首先 useLayoutEffect 是在 DOM 更新之后，浏览器绘制之前，这样可以方便修改 DOM，获取 D ...`,l:"articles/FontEnd/react/lifeCycle/index.html#uselayouteffect",a:"uselayouteffect"},"31.3":{t:"useInsertionEffect",p:`在介绍 useInsertionEffect 用途之前，先看一下 useInsertionEffect 的执行时机。
React.useEffect(()=&gt;{
    console.log( ...`,l:"articles/FontEnd/react/lifeCycle/index.html#useinsertioneffect",a:"useinsertioneffect"},"31.4":{t:"类组件生命周期在函数组件内使用Effect替代方案",p:`::: code-group
// componentDidMount
React.useEffect(()=&gt;{
    /* 请求数据 ， 事件监听 ， 操纵dom */
},[])  /* ...`,l:"articles/FontEnd/react/lifeCycle/index.html#类组件生命周期在函数组件内使用effect替代方案",a:"类组件生命周期在函数组件内使用effect替代方案"},"32.0":{t:"# 渲染调优",p:"",l:"articles/FontEnd/react/optimizeRender/index.html",a:"渲染调优"},"32.1":{t:"懒加载和异步渲染",p:"",l:"articles/FontEnd/react/optimizeRender/index.html#懒加载和异步渲染",a:"懒加载和异步渲染"},"32.2":{t:"异步渲染 Suspense(悬念)",p:`::: info
Suspense 是 React 提出的一种同步的代码来实现异步操作的方案
Suspense可以让组件 await等待异步操作，直到异步操作完成，才会渲染组件。
:::
用法
//  ...`,l:"articles/FontEnd/react/optimizeRender/index.html#异步渲染-suspense-悬念",a:"异步渲染-suspense-悬念"},"32.3":{t:"懒加载(动态加载)",p:"",l:"articles/FontEnd/react/optimizeRender/index.html#懒加载-动态加载",a:"懒加载-动态加载"},"32.4":{t:"React.lazy",p:`React.lazy 接受一个函数，这个函数需要动态调用 import()
它必须返回一个 Promise ，该 Promise 需要 resolve 一个 default export 的 Reac ...`,l:"articles/FontEnd/react/optimizeRender/index.html#react-lazy",a:"react-lazy"},"32.5":{t:"React.lazy和Suspense实现动态加载原理",p:"",l:"articles/FontEnd/react/optimizeRender/index.html#react-lazy和suspense实现动态加载原理",a:"react-lazy和suspense实现动态加载原理"},"33.0":{t:"# props",p:"",l:"articles/FontEnd/react/props/index.html",a:"props"},"33.1":{t:"监听props改变",p:`函数组件中可以用 useEffect 来作为 props 改变后的监听函数。(不过有一点值得注意, useEffect 初始化会默认执行一次)
  React.useEffect(()=&gt;{
  ...`,l:"articles/FontEnd/react/props/index.html#监听props改变",a:"监听props改变"},"33.2":{t:"Render Children 模式",p:`① props 插槽组件

&lt;Container&gt;
    &lt;Children&gt;
&lt;/Container&gt;


上述可以在 Container 组件中，通过 pro ...`,l:"articles/FontEnd/react/props/index.html#render-children-模式",a:"render-children-模式"},"33.3":{t:"Render Props 模式",p:`&lt;Container&gt;
   { (ContainerProps)=&gt; &lt;Children {...ContainerProps}  /&gt; }
&lt;/Containe ...`,l:"articles/FontEnd/react/props/index.html#render-props-模式",a:"render-props-模式"},"33.4":{t:"组合模式",p:`如果 Container 的 Children 既有函数也有组件，这种情况应该怎么处理呢？
&lt;Container&gt;
    &lt;Children /&gt;
    { (Contai ...`,l:"articles/FontEnd/react/props/index.html#组合模式",a:"组合模式"},"33.5":{t:"操作Props 抽象Props",p:`::: tip
抽象 props 一般用于跨层级传递 props ，一般不需要具体指出 props 中某个属性，而是将 props 直接传入或者是抽离到子组件中。
:::
`,l:"articles/FontEnd/react/props/index.html#操作props-抽象props",a:"操作props-抽象props"},"33.6":{t:"混入 props",p:`::: details View The Code
function Son(props){
    console.log(props)
    return &lt;div&gt; hello,w ...`,l:"articles/FontEnd/react/props/index.html#混入-props",a:"混入-props"},"33.7":{t:"抽离Props",p:`::: details View The Code
function Son(props){
    console.log(props)
    return &lt;div&gt; hello,w ...`,l:"articles/FontEnd/react/props/index.html#抽离props",a:"抽离props"},"33.8":{t:"props 的显式注入和隐式注入",p:`显式注入
&lt;Father&gt;
    &lt;Son data='{data}' name='123'&gt;
&lt;/Father&gt;

隐式注入
function Father(p ...`,l:"articles/FontEnd/react/props/index.html#props-的显式注入和隐式注入",a:"props-的显式注入和隐式注入"},"33.9":{t:"demo",p:`::: code-group

用于表单状态管理的&lt;Form&gt; 和 &lt;FormItem&gt; 组件

&lt;Form&gt;用于管理表单状态；
&lt;FormItem&gt;用 ...`,l:"articles/FontEnd/react/props/index.html#demo",a:"demo"},"34.0":{t:"# Ref",p:"",l:"articles/FontEnd/react/ref/index.html",a:"ref"},"34.1":{t:"获取Ref的三种方式",p:`
ref是一个字符串
::: details View The Code

/* 类组件 */
class Children extends Component{  
    render=()=&g ...`,l:"articles/FontEnd/react/ref/index.html#获取ref的三种方式",a:"获取ref的三种方式"},"34.2":{t:"转发Ref(跨层级获取Ref)",p:`如果我想在父组件 获取 孙/子 组件的实例

通过回调函数将子组件的Ref作为参数
::: details View The Code

function ParentComponent(){
  c ...`,l:"articles/FontEnd/react/ref/index.html#转发ref-跨层级获取ref",a:"转发ref-跨层级获取ref"},"34.3":{t:"组合转发Ref",p:`::: details View The Code
// 表单组件
class Form extends React.Component{
    render(){
       return &l ...`,l:"articles/FontEnd/react/ref/index.html#组合转发ref",a:"组合转发ref"},"34.4":{t:"高阶组件转发",p:"如果通过高阶组件包裹一个原始类组件，就会产生一个问题，如果高阶组件 HOC 没有处理 ref ，那么由于高阶组件本身会返回一个新组件，所以当使用 HOC 包装后组件的时候，标记的 ref 会指向 HO ...",l:"articles/FontEnd/react/ref/index.html#高阶组件转发",a:"高阶组件转发"},"34.5":{t:"组件通信",p:`
类组件通信: 因为类组件有实例，所以我们可以直接获取实例然后调用实例方法来操作
函数组件通信: 对于函数组件，本身是没有实例的，所以我们要借用forwardRef(使函数组件可以接收Ref) + u ...`,l:"articles/FontEnd/react/ref/index.html#组件通信",a:"组件通信"},"34.6":{t:"函数组件数据缓存",p:`函数组件每一次 render ，函数上下文会重新执行，那么有一种情况就是
在执行一些事件方法改变数据或者保存新数据的时候，有没有必要更新视图，有没有必要把数据放到 state 中。如果视图层更新不依赖 ...`,l:"articles/FontEnd/react/ref/index.html#函数组件数据缓存",a:"函数组件数据缓存"},"35.0":{t:"# 渲染控制",p:"",l:"articles/FontEnd/react/render/index.html",a:"渲染控制"},"35.1":{t:"React 几种控制 render 方法",p:`
第一种就是从父组件直接隔断子组件的渲染，经典的就是 memo，缓存 element 对象。
父组件 render ，子组件有没有必要跟着父组件一起 render ，如果没有必要，则就需要阻断更新
: ...`,l:"articles/FontEnd/react/render/index.html#react-几种控制-render-方法",a:"react-几种控制-render-方法"},"35.2":{t:"useMemo用法",p:`::: details
const cacheSomething = useMemo(create,deps)


create：第一个参数为一个函数，函数的返回值作为缓存值，如上 demo 中把 C ...`,l:"articles/FontEnd/react/render/index.html#usememo用法",a:"usememo用法"},"35.3":{t:"useMemo原理",p:"useMemo 会记录上一次执行 create 的返回值，并把它绑定在函数组件对应的 fiber 对象上，只要组件不销毁，缓存值就一直存在，但是 deps 中如果有一项改变，就会重新执行 create ...",l:"articles/FontEnd/react/render/index.html#usememo原理",a:"usememo原理"},"35.4":{t:"pureComponent",p:`纯组件是一种发自组件本身的渲染优化策略，当开发类组件选择了继承 PureComponent ，就意味这要遵循其渲染规则。规则就是浅比较 state 和 props 是否相等。
基本使用
::: det ...`,l:"articles/FontEnd/react/render/index.html#purecomponent",a:"purecomponent"},"35.5":{t:"pureComponent原理",p:`

pureComponentPrototype有一个prototype属性，isPureReactComponent，这个属性是一个布尔值，用来标识当前组件是否是纯组件，如果是纯组件，那么在更新时， ...`,l:"articles/FontEnd/react/render/index.html#purecomponent原理",a:"purecomponent原理"},"35.6":{t:"pureComponent注意事项",p:`PureComponent可以让组件自发的做一层性能上的调优，但是父组件给是PureComponent的子组件绑定事件要小心，避免两种情况

避免使用箭头函数，不要给是PureComponent子组件 ...`,l:"articles/FontEnd/react/render/index.html#purecomponent注意事项",a:"purecomponent注意事项"},"35.7":{t:"shouldComponentUpdate",p:`有的时候把控制渲染交给React组件本身处理靠不住，那么我们便可以自定义渲染方案决定组建是否更新

使用

class Index extends React.Component {
  state  ...`,l:"articles/FontEnd/react/render/index.html#shouldcomponentupdate",a:"shouldcomponentupdate"},"35.8":{t:"React.Memo",p:`React.memo(Component,compare)
Component: 需要被包裹的组件
compare: 比较函数，用来判断是否需要更新，返回true则不更新，返回false则更新

`,l:"articles/FontEnd/react/render/index.html#react-memo",a:"react-memo"},"35.9":{t:"React.Memo的特点",p:`

memo 当二个参数 compare 不存在时，会用浅比较原则处理 props ，相当于仅比较 props 版本的 pureComponent 。


memo 同样适合类组件和函数组件。


D ...`,l:"articles/FontEnd/react/render/index.html#react-memo的特点",a:"react-memo的特点"},"35.10":{t:"打破渲染限制的方法使Memo和PureComponent失效",p:`
forceUpdate 如果更新状态使用的forceUpdate 而不是 setState 会跳过shouldComponentUpdate的判断，直接更新组件
Context 如果组件依赖于con ...`,l:"articles/FontEnd/react/render/index.html#打破渲染限制的方法使memo和purecomponent失效",a:"打破渲染限制的方法使memo和purecomponent失效"},"35.11":{t:"控制渲染的场景",p:`
大屏展示组件数据量大，渲染耗时长，可以使用React.memo局部更新
表单，React 一般会采用受控组件的模式去管理表单数据层，表单数据层完全托管于 props 或是 state ，而用户操作表 ...`,l:"articles/FontEnd/react/render/index.html#控制渲染的场景",a:"控制渲染的场景"},"37.0":{t:"context",p:"",l:"articles/FontEnd/relevance/context.html",a:"context"},"38.0":{t:"# reducer",p:`
action + state  = new state

`,l:"articles/FontEnd/relevance/reducer.html",a:"reducer"},"38.1":{t:"与state的区别",p:`state是用户触发函数来执行具体的一步一步操作，reducer是把操作整合到一起，用户触发事件名进而执行相应的处理函数
例如：用户触发添加程序, 程序了解到事件名以后去reducer中找到对应的函数 ...`,l:"articles/FontEnd/relevance/reducer.html#与state的区别",a:"与state的区别"},"38.2":{t:"命名原因",p:`reducer是根据reduce命名 ,它接收目前的结果和当前的值，然后返回下一个结果.
React中的reducer也是这样的他们都接受 当前state 和触发的事件action ,然后返回新的st ...`,l:"articles/FontEnd/relevance/reducer.html#命名原因",a:"命名原因"},"38.3":{t:" ",p:"",l:"articles/FontEnd/relevance/reducer.html#",a:""},"38.4":{t:"reduce实现reducer",p:`::: code-group
import tasksReducer from './tasksReducer.js';

let actions = [
  {type: 'added', id:  ...`,l:"articles/FontEnd/relevance/reducer.html#reduce实现reducer",a:"reduce实现reducer"},"38.5":{t:"实现useReducer",p:`通过useState保存当前状态＋action = new state
::: code-group
const App = ()=&gt;{
  const [state,dispatch] = u ...`,l:"articles/FontEnd/relevance/reducer.html#实现usereducer",a:"实现usereducer"},"38.6":{t:"实际用途",p:`useReducer是React提供的一个Hook，用于管理组件的状态（state）。它的实际用途包括：


状态复杂逻辑：当组件的状态逻辑较为复杂，涉及多个状态变化时，可以使用useReducer来 ...`,l:"articles/FontEnd/relevance/reducer.html#实际用途",a:"实际用途"},"39.0":{t:"useRef",p:"",l:"articles/FontEnd/relevance/useRef.html",a:"useref"},"40.0":{t:"base",p:"",l:"articles/FontEnd/vue/base/index.html",a:"base"},"41.0":{t:"# vue",p:"",l:"articles/FontEnd/vue/index.html",a:"vue"},"43.0":{t:"前置",p:"",l:"articles/algorithm/base/index.html",a:"前置"},"44.0":{t:"时间复杂度",p:"",l:"articles/algorithm/base/time.html",a:"时间复杂度"},"45.0":{t:"# Nest主要设计模式",p:"",l:"articles/designModel/IOCDI/index.html",a:"nest主要设计模式"},"45.1":{t:"Dependency Injection 依赖注入",p:`class UserService {
  getList(id) {
    // 获取用户的逻辑 
  }
}

class AdminService{
  getList(id){
    // ...`,l:"articles/designModel/IOCDI/index.html#dependency-injection-依赖注入",a:"dependency-injection-依赖注入"},"45.2":{t:"Inversion of Control  控制反转",p:`控制反转的本质就是降低耦合度，不再强依赖一些属性和方法。具体的实现方式是DI依赖注入
控制反转需要一个容器，这个容器接手类的控制权
`,l:"articles/designModel/IOCDI/index.html#inversion-of-control-控制反转",a:"inversion-of-control-控制反转"},"45.3":{t:"好处",p:`
解耦和模块化
更方便的依赖注入
配置集中管理

`,l:"articles/designModel/IOCDI/index.html#好处",a:"好处"},"45.4":{t:"如何控制反转",p:`控制反转需要的条件如下

需要一个管理容器  Container
容器需要拥有register方法用来管理容器的注册
容器需要有一个解析的方法 （从容器中解析已注册的依赖项并注入)
让所有的依赖项统一 ...`,l:"articles/designModel/IOCDI/index.html#如何控制反转",a:"如何控制反转"},"45.5":{t:"案例",p:`  abstract class Service {
    getList: () =&gt; void;
    putList: () =&gt; void;
  }

  class Cont ...`,l:"articles/designModel/IOCDI/index.html#案例",a:"案例"},"46.0":{t:"设计模式",p:"",l:"articles/designModel/index.html",a:"设计模式"},"47.0":{t:"<myIndex/>",p:"",l:"index.html",a:"myindex"},"48.0":{t:"# 记录和楠楠的日常生活",p:"",l:"nannan/index.html",a:"记录和楠楠的日常生活"},"49.0":{t:"# 我们的故事",p:"",l:"nannan/story/index.html",a:"我们的故事"},"50.0":{t:"# 根据空格拆分字符串",p:` const str = \`remote_addr：192.168.3.69:48512
status_code：200
content_type：
method：GET
proto：HTTP/1.1 ...`,l:"otherArticles/index.html",a:"根据空格拆分字符串"},"51.0":{t:"<!-- ---",p:`layout :  false
layout: page
&lt;team/&gt; --&gt;
`,l:"team/index.html",a:""}},n={previewLength:100,buttonLabel:"搜索",placeholder:"情输入关键词",allow:[],ignore:[]},r={INDEX_DATA:e,PREVIEW_LOOKUP:t,Options:n};export{r as default};
