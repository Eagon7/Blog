const t={map:'[{"resume":["0.0"],"nestjs":["1.0"],"js":["2.0"],"react":["3.0","4.0","5.0","6.0"],"快速上手":["3.1"],"原理分析":["3.2"],"api分类":["4.1"],"数据更新驱动类":["4.2"],"usestate":["4.3"],"常见的状态管理模式":["6.1","7.1"],"jotai":["7.0","7.2"],"原子式解决了什么问题":["7.3"],"使用教程":["7.4"],"实际使用":["7.14"],"redux":["8.0"],"api介绍":["8.1"],"摘要":["8.2"],"vue":["9.0"],"前置":["11.0"],"时间复杂度":["12.0"],"nest主要设计模式":["13.0"],"dependency":["13.1"],"inversion":["13.2"],"好处":["13.3"],"如何控制反转":["13.4"],"案例":["13.5"],"设计模式":["14.0"],"myindex":["15.0"],"记录和楠楠的日常生活":["16.0"],"我们的故事":["17.0"]},{"0":["7.14","8.1"],"1":["6.1","7.1","7.5","13.3"],"2":["7.6"],"3":["7.7"],"4":["7.8"],"5":["7.9"],"6":["7.10"],"7":["7.11"],"8":["7.12"],"9":["7.13"],"router":["3.0"],"速通":["4.0"],"alt":["4.1"],"ts":["4.3","7.14"],"const":["4.3","7.14"],"state":["4.3"],"setstate":["4.3"],"initialstate":["4.3"],"参数接收一个初始值":["4.3"],"全局存储":["6.0"],"global":["6.1","7.1"],"全局式":["6.1","7.1"],"引用来源":["7.0"],"原子状态管理":["7.2"],"reacthook":["7.3"],"使state的":["7.3"],"拆分":["7.3"],"和":["7.3"],"创建":["7.5"],"atom":["7.5","7.14"],"派生atom":["7.5"],"使用":["7.5"],"useatom":["7.5"],"异步派生":["7.6"],"details":["7.6","7.7","7.8","7.9","7.10"],"view":["7.6","7.8","7.9","7.10"],"the":["7.6","7.8","7.9","7.10"],"code":["7.6","7.8","7.9","7.10","7.14"],"typescript":["7.6","13.1","13.5"],"import":["7.6","7.14"],"函数组件内更新方式":["7.7"],"atom内更新方式":["7.8"],"异步更新atom":["7.9"],"区别于第二条异步获取":["7.9"],"异步更新不会阻塞线程":["7.9"],"渲染问题":["7.10"],"当我们点击add时":["7.10"],"发现a和b都重新渲染了":["7.10"],"但是问题来了":["7.10"],"a为什么要重新渲染呀":["7.10"],"a只是触发了更新操作":["7.10"],"provider":["7.12"],"store":["7.13","7.14"],"group":["7.14"],"createstore":["7.14"],"from":["7.14"],"jotai":["7.14"],"mystore":["7.14"],"export":["7.14"],"countatom":["7.14"],"reducer":["8.1"],"纯函数":["8.1"],"middleware":["8.2"],"中间件":["8.2"],"injection":["13.1"],"依赖注入":["13.1"],"class":["13.1","13.5"],"userservice":["13.1"],"getlist":["13.1","13.5"],"id":["13.1"],"获取用户的逻辑":["13.1"],"controller":["13.1"],"constructor":["13.1"],"this":["13.1"],"of":["13.2"],"控制反转需要的条件如下":["13.4"],"abstract":["13.5"],"service":["13.5"],"void":["13.5"],"putlist":["13.5"],"layout":["18.0"]},{"1":["4.3","7.8","13.4"],"text":["4.1"],"返回一个数组":["4.3"],"数组的第一个元素是当前的state":["4.3"],"第二个元素是更新state的函数":["4.3"],"注意事项":["4.3"],"案例":["4.3"],"此时点击按钮":["4.3"],"log打印出来的值并不是更改过后的number":["4.3"],"状态管理":["6.0"],"也被称作单一数据源":["6.1","7.1"],"将所有的数据放到一个大对象中":["6.1","7.1"],"关键词":["6.1","7.1"],"ryun":["7.0"],"逻辑共享":["7.3"],"变得更容易":["7.3"],"但usestate":["7.3"],"details":["7.5"],"view":["7.5","7.7"],"the":["7.5","7.7"],"code":["7.5","7.7"],"typescript":["7.5","7.7","7.8","7.9"],"import":["7.5"],"atom":["7.6","7.8"],"useatom":["7.6"],"from":["7.6"],"jotai":["7.6"],"fc":["7.6"],"react":["7.6"],"const":["7.6","7.8","7.9","13.1"],"valueatom":["7.8"],"mockdata":["7.9"],"new":["7.9","13.1"],"promise":["7.9"],"string":["7.9","13.5"],"r":["7.9"],"settimeout":["7.9"],"并不需要重新渲染呀":["7.10"],"这是因为":["7.10"],"如果使用useatom":["7.10"],"即使你不引入它的value值":["7.10"],"但它由useatomvalue包裹":["7.10"],"当更新时":["7.10"],"useatomvalue会触发订阅事件":["7.10"],"从而触发渲染":["7.10"],"如果不理解可以阅读":["7.10"],"recoil原理":["7.10"],"理解":["7.10"],"解决渲染问题":["7.11"],"useatomvalue":["7.11"],"正常情况下":["7.12"],"无需用provider包裹组件":["7.12"],"createstore":["7.13"],"export出去":["7.13"],"statusatom":["7.14"],"false":["7.14","18.0"],"监听发生变化":["7.14"],"sub":["7.14"],"console":["7.14"],"log":["7.14"],"value":["7.14"],"is":["7.14"],"changed":["7.14"],"to":["7.14"],"get":["7.14"],"set":["7.14"],"接收两个参数":["8.1"],"一个是state":["8.1"],"一个是action":["8.1"],"中间件用于增强":["8.2"],"dispatch":["8.2"],"功能":["8.2"],"service":["13.1"],"read":["13.1"],"处理用户数据的逻辑":["13.1"],"result":["13.1"],"control":["13.2"],"解耦和模块化":["13.3"],"container":["13.5"],"创建一个变量存贮依赖项":["13.5"],"private":["13.5"],"dependencies":["13.5"],"key":["13.5"]},{"1":["7.7","7.9","8.1"],"2":["6.1","7.1","7.14","13.3"],"3000":["7.9"],"而是更改前的值":["4.3"],"这意味着log时更改未发生":["4.3"],"原因":["4.3"],"setnumber是异步的":["4.3"],"触发handleclick时":["4.3"],"任务线程会先执行同步再执行异步":["4.3"],"所以log打印的是更改前的值":["4.3"],"外部log可以获取到最新的值的原因是":["4.3"],"combinereducers":["6.1","7.1"],"multiple":["6.1","7.1"],"usecontext对于多个store仍需要维护多个context":["7.3"],"provider":["7.3"],"因为当context改变":["7.3"],"所有消费该context的组件都会重新渲染即使是组件仅用到了":["7.3"],"context的一部分":["7.3"],"from":["7.5","7.10"],"jotai":["7.5"],"fc":["7.5","7.10"],"mockdata":["7.6"],"new":["7.6"],"promise":["7.6"],"string":["7.6"],"r":["7.6"],"settimeout":["7.6"],"mock":["7.6","7.9"],"data":["7.6","7.9","13.1"],"const":["7.7"],"valueatom":["7.7","7.9"],"atom":["7.7","7.9","7.10"],"addnumberatom":["7.8"],"ge":["7.8"],"get":["7.8"],"a组件使用即订阅":["7.10"],"atom原子更新触发订阅事件从而更新":["7.10"],"解决办法":["7.10"],"参考7":["7.10"],"typescript":["7.10"],"import":["7.10"],"react":["7.10","7.14"],"usesetatom":["7.11"],"如果有的组件只需要监听状态的变化值":["7.11"],"但如果需要控制某些组件的状态不发生更新":["7.12"],"可以用provider包裹":["7.12"],"使用jotai的provider提供给app":["7.13"],"其中":["7.13"],"default":["7.14","13.1"],"main":["7.14"],"reactdom":["7.14"],"返回一个新的state":["8.1"],"createstore":["8.1"],"返回一个增强后的":["8.2"],"js":["13.1"],"export":["13.1"],"return":["13.1"],"msg":["13.1"],"focused":["13.1"],"code":["13.1"],"focus":["13.1"],"此时controller":["13.1"],"和":["13.1"],"存在了强耦合的关联":["13.1"],"控制反转":["13.2"],"需要一个管理容器":["13.4"],"container":["13.4"],"any":["13.5"],"注册方法":["13.5"],"register":["13.5"],"dependency":["13.5"],"this":["13.5"]},{"0":["7.10"],"1":["7.6"],"2":["13.4"],"3000":["7.6"],"在执行完同步的log后执行异步setnumber":["4.3"],"异步setnumber触发重新渲染":["4.3"],"重新执行index函数":["4.3"],"usestate获取到最新的number":["4.3"],"所以打印的值是最新的number":["4.3"],"function":["4.3"],"stores":["6.1","7.1"],"多数据源模式":["6.1","7.1"],"将状态存放到多个数据源中":["6.1","7.1"],"容易导致不必要的":["7.3"],"无用渲染":["7.3"],"造成性能损失":["7.3"],"比如react":["7.3"],"react":["7.5"],"创建atom":["7.5","7.6"],"const":["7.5","7.10"],"valueatom":["7.5","7.6"],"派生atom":["7.6"],"依赖某个atom":["7.6"],"text":["7.7"],"value":["7.7"],"set":["7.8","7.9"],"arg":["7.8","7.9"],"addnumberatom":["7.9"],"null":["7.9"],"async":["7.9"],"get":["7.9"],"result":["7.9"],"useatom":["7.10"],"useatomvalue":["7.10"],"usesetatom":["7.10"],"jotai":["7.10"],"countatom":["7.10"],"a":["7.10"],"而没有更新操作":["7.11"],"请使用useatomvalue":["7.11"],"或者说":["7.12"],"用provider包裹的组件":["7.12"],"store中的状态":["7.13"],"是全局的":["7.13"],"dom":["7.14"],"client":["7.14"],"app":["7.14"],"tsx":["7.14"],"index":["7.14"],"css":["7.14"],"provider":["7.14"],"创建一个":["8.1"],"root":["8.1"],"存放":["8.1"],"比如":["8.2"],"redux":["8.2"],"thunk":["8.2"],"无法复用":["13.1"],"若我们想用authservice时必须新注册一个类来实现":["13.1"],"并且需要改动getuser里面的代码":["13.1"],"那我们此时就需要解决这个问题":["13.1"],"使用di":["13.1"],"依赖是service":["13.1"],"依赖的标准需要拥有一个getlist方法":["13.1"],"并且接收一个id":["13.1"],"控制反转的本质就是降低耦合度":["13.2"],"更方便的依赖注入":["13.3"],"解析方法":["13.5"],"resolve":["13.5"],"if":["13.5"],"page":["18.0"]},{"0":["4.3"],"2":["8.1"],"3":["6.1","7.1","13.3","13.4"],"index":["4.3"],"number":["4.3"],"setnumber":["4.3"],"console":["4.3","7.10"],"log":["4.3","7.10"],"可在多个地方使用消费":["6.1","7.1"],"usestore":["6.1","7.1"],"redux":["7.3"],"v6完全基于context":["7.3"],"api而导致性能大幅下降":["7.3"],"v7又回退到之前的内部订阅方案":["7.3"],"context更适合放类似主题这种变化不大的全局数据":["7.3"],"依赖某个atom":["7.5"],"当依赖项发生变化时更新触发atom的第一个参数修改变量":["7.5","7.6"],"deriveatom":["7.5","7.6"],"async":["7.6"],"get":["7.6"],"setvalue":["7.7"],"useatom":["7.7"],"return":["7.7","7.10","13.5"],"text":["7.8"],"fc":["7.8"],"value":["7.8"],"await":["7.9"],"url":["7.9"],"setcount":["7.10"],"组件a渲染":["7.10"],"div":["7.10"],"button":["7.10"],"onclick":["7.10"],"如果仅更新操作":["7.11"],"而无需渲染状态的组件":["7.11"],"状态是独立的":["7.12"],"不受外部影响":["7.12"],"同时也不影响外部":["7.12"],"任何组件都可以使用":["7.13"],"但是":["7.13"],"createroot":["7.14"],"document":["7.14"],"getelementbyid":["7.14"],"root":["7.14"],"render":["7.14"],"strictmode":["7.14"],"state的根对象":["8.1"],"dispatch":["8.1"],"使":["8.2"],"action":["8.2"],"可以为":["8.2"],"不再强依赖一些属性和方法":["13.2"],"具体的实现方式是di依赖注入":["13.2"],"容器需要拥有register方法用来管理容器的注册":["13.4"],"throw":["13.5"],"team":["18.0"]},{"1":["7.10"],"3":["8.1"],"重新渲染":["4.3"],"handleclick":["4.3"],"atomic":["6.1","7.1"],"state":["6.1","7.1"],"原子状态":["6.1","7.1"],"而并不适合存放频繁更新的复杂状态集合":["7.3"],"原子化":["7.3"],"组件内状态":["7.3"],"但是api较多":["7.3"],"get":["7.5","13.1"],"使用atom":["7.5"],"return":["7.6","7.8"],"await":["7.6"],"text":["7.6","7.9"],"div":["7.7"],"button":["7.7"],"useatom":["7.8","7.9","7.14"],"addnumber":["7.8"],"fc":["7.9"],"value":["7.9"],"prev":["7.10"],"add":["7.10"],"b":["7.10"],"count":["7.10"],"请使用":["7.11"],"即使大家共用同一个atom状态":["7.12"],"如果不想让这个组件受外部更新影响":["7.12"],"如果某个组件使用了provider包裹":["7.13"],"那么该组件的状态是独立的":["7.13"],"getdefaultstore":["7.14"],"useatomvalue":["7.14"],"num":["7.14"],"num2":["7.14"],"navstore":["7.14"],"更新store中的state":["8.1"],"subscribe":["8.1"],"function":["8.2"],"enhancer":["8.2"],"实际使用":["13.1"],"abstract":["13.1"],"authservice":["13.1"],"xxx":["13.1"],"控制反转需要一个容器":["13.2"],"配置集中管理":["13.3"],"容器需要有一个解析的方法":["13.4"],"new":["13.5"],"error":["13.5"],"依赖":["13.5"],"未被注册到容器":["13.5"],"请先注册到容器再去使用":["13.5"],"const":["13.5"]},{"5":["8.1"],"return":["4.3","7.9","7.14"],"button":["4.3","7.8","7.9"],"onclick":["4.3","7.7","7.8","7.9"],"与创建对象形式的存储不同":["6.1","7.1"],"针对每一个变量可以是响应式的":["6.1","7.1"],"通过原子派生的方式来适应复杂的开发场景":["6.1","7.1"],"它通过将原子状态进行派生":["7.3"],"组合成新的状态":["7.3"],"类似vue的computed":["7.3"],"所谓组件内状态":["7.3"],"其实就是内部使用了usestate":["7.3"],"text":["7.5"],"value":["7.5","7.6"],"div":["7.6","7.8","7.9","7.14"],"export":["7.6"],"addnumber":["7.9"],"组件b渲染":["7.10"],"p":["7.10"],"组件b":["7.10"],"这么做的目的":["7.11"],"防止无意义的渲染":["7.11"],"这样就不会触发更新了":["7.12"],"不受外部影响":["7.13"],"同时也不影响外部":["7.13"],"count":["7.14"],"setcount":["7.14"],"status":["7.14"],"style":["7.14"],"background":["7.14"],"pink":["7.14"],"black":["7.14"],"订阅":["8.1"],"监听store中的state变化":["8.1"],"增强器":["8.2"],"动作":["8.2"],"instance":["13.1"],"constroller":["13.1"],"这个容器接手类的控制权":["13.2"],"从容器中解析已注册的依赖项并注入":["13.4"],"让所有的依赖项统一管理注册解耦了对象之间的强依赖关系":["13.4"],"authservice":["13.5"]},{"1":["7.14"],"123":["7.14"],"点击":["4.3"],"export":["4.3","7.10"],"default":["4.3","7.6","7.10"],"atom":["6.1","7.1"],"state变化":["7.3"],"触发更新渲染罢了":["7.3"],"有兴趣可以阅读手动实现recoil原理":["7.3"],"return":["7.5"],"div":["7.5"],"danger":["7.6"],"这样会阻塞渲染线程":["7.6"],"不建议这样做":["7.6"],"异步请求应该放在组件内部":["7.6"],"或者使用异步更新atom":["7.6"],"add":["7.7","7.8","7.9","7.14"],"www":["7.9"],"abc":["7.9"],"com":["7.9"],"asynctest":["7.10"],"不会触发订阅事件":["7.12"],"即使大家共用同一个atom状态":["7.13"],"p":["7.14"],"button":["7.14"],"onclick":["7.14"],"x":["7.14"],"combinereducer":["8.1"],"将多个reducers合并成一个rootreducer":["8.1"],"reducer":["8.2"],"纯函数":["8.2"],"此时我们的constroller与service解耦":["13.1"],"具体调用的方法完全取决于外部依赖注入进来的方法":["13.1"],"可扩展性":["13.1"],"解耦":["13.1"],"可测试性":["13.1"],"controller":["13.5"]}]'},e={"0.0":{t:"<resume/>",p:"",l:"Resume/index.html",a:"resume"},"1.0":{t:"# NestJs",p:"",l:"articles/BackEnd/nestjs/index.html",a:"nestjs"},"2.0":{t:"js",p:"",l:"articles/FontEnd/js/index.html",a:"js"},"3.0":{t:"# React Router",p:"",l:"articles/FontEnd/react/ReactRouter/index.html",a:"react-router"},"3.1":{t:"快速上手",p:"",l:"articles/FontEnd/react/ReactRouter/index.html#快速上手",a:"快速上手"},"3.2":{t:"原理分析",p:"",l:"articles/FontEnd/react/ReactRouter/index.html#原理分析",a:"原理分析"},"4.0":{t:"# React 速通",p:"",l:"articles/FontEnd/react/basic/index.html",a:"react-速通"},"4.1":{t:"API分类",p:`!Alt text
`,l:"articles/FontEnd/react/basic/index.html#api分类",a:"api分类"},"4.2":{t:"数据更新驱动类",p:"",l:"articles/FontEnd/react/basic/index.html#数据更新驱动类",a:"数据更新驱动类"},"4.3":{t:"useState",p:`const [state, setState] = useState(initialState);
参数接收一个初始值，返回一个数组，数组的第一个元素是当前的state，第二个元素是更新state的函 ...`,l:"articles/FontEnd/react/basic/index.html#usestate",a:"usestate"},"5.0":{t:"react",p:"",l:"articles/FontEnd/react/index.html",a:"react"},"6.0":{t:"# React 全局存储/状态管理",p:"",l:"articles/FontEnd/react/storage/index.html",a:"react-全局存储-状态管理"},"6.1":{t:"常见的状态管理模式",p:`
global：  全局式，也被称作单一数据源，将所有的数据放到一个大对象中，关键词：combineReducers();
multiple stores：  多数据源模式，将状态存放到多个数据源中， ...`,l:"articles/FontEnd/react/storage/index.html#常见的状态管理模式",a:"常见的状态管理模式"},"7.0":{t:"# Jotai",p:`引用来源：Ryun
`,l:"articles/FontEnd/react/storage/jotai/index.html",a:"jotai"},"7.1":{t:"常见的状态管理模式",p:`
global：  全局式，也被称作单一数据源，将所有的数据放到一个大对象中，关键词：combineReducers();
multiple stores：  多数据源模式，将状态存放到多个数据源中， ...`,l:"articles/FontEnd/react/storage/jotai/index.html#常见的状态管理模式",a:"常见的状态管理模式"},"7.2":{t:"Jotai  原子状态管理",p:"",l:"articles/FontEnd/react/storage/jotai/index.html#jotai-原子状态管理",a:"jotai-原子状态管理"},"7.3":{t:"原子式解决了什么问题",p:`reactHook 使State的拆分和逻辑共享变得更容易
但useState 和 useContext对于多个store仍需要维护多个Context Provider 因为当Context改变，所有 ...`,l:"articles/FontEnd/react/storage/jotai/index.html#原子式解决了什么问题",a:"原子式解决了什么问题"},"7.4":{t:"使用教程",p:"",l:"articles/FontEnd/react/storage/jotai/index.html#使用教程",a:"使用教程"},"7.5":{t:"1. 创建 atom  派生atom  使用 useAtom",p:`::: details View The Code
import { atom, useAtom } from &quot;jotai&quot;;
import { FC } from &quot; ...`,l:"articles/FontEnd/react/storage/jotai/index.html#_1-创建-atom-派生atom-使用-useatom",a:"_1-创建-atom-派生atom-使用-useatom"},"7.6":{t:"2. 异步派生",p:`::: details View The Code
import { atom, useAtom } from &quot;jotai&quot;;
import { FC } from &quot; ...`,l:"articles/FontEnd/react/storage/jotai/index.html#_2-异步派生",a:"_2-异步派生"},"7.7":{t:"3. 函数组件内更新方式",p:`::: details View The Code
  const ValueAtom = atom(1)
  const Text = ()=&gt;{
    const [value,setVa ...`,l:"articles/FontEnd/react/storage/jotai/index.html#_3-函数组件内更新方式",a:"_3-函数组件内更新方式"},"7.8":{t:"4. atom内更新方式",p:`::: details View The Code
  const ValueAtom = atom(1)
  const AddNumberAtom = atom(ge=&gt;ge(ValueAt ...`,l:"articles/FontEnd/react/storage/jotai/index.html#_4-atom内更新方式",a:"_4-atom内更新方式"},"7.9":{t:"5. 异步更新atom 区别于第二条异步获取，异步更新不会阻塞线程",p:`::: details View The Code
  const MockData = new Promise&lt;string&gt;((r) =&gt; {
    setTimeout(() ...`,l:"articles/FontEnd/react/storage/jotai/index.html#_5-异步更新atom-区别于第二条异步获取-异步更新不会阻塞线程",a:"_5-异步更新atom-区别于第二条异步获取-异步更新不会阻塞线程"},"7.10":{t:"6. 渲染问题",p:`:::   details View The Code

当我们点击add时，发现A和B都重新渲染了，但是问题来了，A为什么要重新渲染呀，A只是触发了更新操作，并不需要重新渲染呀？？？


这是因为， ...`,l:"articles/FontEnd/react/storage/jotai/index.html#_6-渲染问题",a:"_6-渲染问题"},"7.11":{t:"7. 解决渲染问题 useAtomValue、useSetAtom",p:`
如果有的组件只需要监听状态的变化值，而没有更新操作 请使用useAtomValue
如果仅更新操作，而无需渲染状态的组件，请使用 useSetAtom
这么做的目的：防止无意义的渲染

`,l:"articles/FontEnd/react/storage/jotai/index.html#_7-解决渲染问题-useatomvalue、usesetatom",a:"_7-解决渲染问题-useatomvalue、usesetatom"},"7.12":{t:"8. Provider",p:`
正常情况下，无需用Provider包裹组件
但如果需要控制某些组件的状态不发生更新，可以用Provider包裹
或者说，用Provider包裹的组件，状态是独立的，不受外部影响，同时也不影响外部，即 ...`,l:"articles/FontEnd/react/storage/jotai/index.html#_8-provider",a:"_8-provider"},"7.13":{t:"9.store",p:`
createStore,export出去,使用Jotai的Provider提供给App


其中，store中的状态，是全局的，任何组件都可以使用，但是，如果某个组件使用了Provider包裹，那么 ...`,l:"articles/FontEnd/react/storage/jotai/index.html#_9-store",a:"_9-store"},"7.14":{t:"实际使用",p:`::: code-group
import { createStore, atom } from &quot;jotai&quot;;

const myStore = createStore();
 ...`,l:"articles/FontEnd/react/storage/jotai/index.html#实际使用",a:"实际使用"},"8.0":{t:"# Redux",p:"",l:"articles/FontEnd/react/storage/redux/index.html",a:"redux"},"8.1":{t:"API介绍",p:`
reducer 纯函数，接收两个参数，一个是state，一个是action，返回一个新的state
createStore 创建一个 root 存放 state的根对象
dispatch 更新sto ...`,l:"articles/FontEnd/react/storage/redux/index.html#api介绍",a:"api介绍"},"8.2":{t:"摘要",p:`
middleware 中间件,中间件用于增强 dispatch 功能，返回一个增强后的 dispatch（比如 redux-thunk 使 action 可以为 function）
enhancer ...`,l:"articles/FontEnd/react/storage/redux/index.html#摘要",a:"摘要"},"9.0":{t:"# vue",p:"",l:"articles/FontEnd/vue/index.html",a:"vue"},"11.0":{t:"前置",p:"",l:"articles/algorithm/base/index.html",a:"前置"},"12.0":{t:"时间复杂度",p:"",l:"articles/algorithm/base/time.html",a:"时间复杂度"},"13.0":{t:"# Nest主要设计模式",p:"",l:"articles/designModel/IOCDI/index.html",a:"nest主要设计模式"},"13.1":{t:"Dependency Injection 依赖注入",p:`class UserService {
  getList(id) {
    // 获取用户的逻辑 
  }
}

class Controller {
  constructor() {
     ...`,l:"articles/designModel/IOCDI/index.html#dependency-injection-依赖注入",a:"dependency-injection-依赖注入"},"13.2":{t:"Inversion of Control  控制反转",p:`控制反转的本质就是降低耦合度，不再强依赖一些属性和方法。具体的实现方式是DI依赖注入
控制反转需要一个容器，这个容器接手类的控制权
`,l:"articles/designModel/IOCDI/index.html#inversion-of-control-控制反转",a:"inversion-of-control-控制反转"},"13.3":{t:"好处",p:`
解耦和模块化
更方便的依赖注入
配置集中管理

`,l:"articles/designModel/IOCDI/index.html#好处",a:"好处"},"13.4":{t:"如何控制反转",p:`控制反转需要的条件如下

需要一个管理容器  Container
容器需要拥有register方法用来管理容器的注册
容器需要有一个解析的方法 （从容器中解析已注册的依赖项并注入)
让所有的依赖项统一 ...`,l:"articles/designModel/IOCDI/index.html#如何控制反转",a:"如何控制反转"},"13.5":{t:"案例",p:`  abstract class Service {
    getList: () =&gt; void;
    putList: () =&gt; void;
  }

  class Cont ...`,l:"articles/designModel/IOCDI/index.html#案例",a:"案例"},"14.0":{t:"设计模式",p:"",l:"articles/designModel/index.html",a:"设计模式"},"15.0":{t:"<myIndex/>",p:"",l:"index.html",a:"myindex"},"16.0":{t:"# 记录和楠楠的日常生活",p:"",l:"nannan/index.html",a:"记录和楠楠的日常生活"},"17.0":{t:"# 我们的故事",p:"",l:"nannan/story/index.html",a:"我们的故事"},"18.0":{t:"<!-- ---",p:`layout :  false
layout: page
&lt;team/&gt; --&gt;
`,l:"team/index.html",a:""}},a={previewLength:100,buttonLabel:"搜索",placeholder:"情输入关键词",allow:[],ignore:[]},o={INDEX_DATA:t,PREVIEW_LOOKUP:e,Options:a};export{o as default};
